{"id":"MOD_clsExcel","name":"clsExcel","kind":"standard","procedures":["Private Function SheetNames_read()","Public Function xl_wkb_Close()","Public Function XL_Wkb_Open_RDOnly(strDateiname As String, Optional Pwd As String = \"\") As Object","Public Function XL_Wkb_Open_RDWR(strDateiname As String, Optional Pwd As String = \"\") As Object","Public Function XL_Wkb_Add(Optional xlVorl As String) As Object","Public Function XL_actWkb_SaveAs(strDateiname As String)","Public Function XL_Visible(X As Boolean)","Public Function XL_Close()","Public Function XL_Close_Sure()","Public Function SetRange(iRow As Long, iCol As Long, IRowEnd As Long, IColEnd As Long) As Object","Public Function SetRangeRow(iRow As Long, IRowEnd As Long) As Object","Public Function SetRangeToLastRow(iRow As Long) As Object","Public Function SelectSheet(Optional ByVal Sheet As Variant = 1) As Object","Public Function SelectSheet_Test(Optional ByVal Sheet As Variant = 1) As Boolean","Public Function GetRangeFromActSheet() As Object","Public Function CellStr2RowCol(Cell1 As String)","Public Function GetCellAsStr(iRow As Long, iCol As Long) As String","Public Function GetRangeAsStr(ByVal iRow As Long, ByVal iCol As Long, Optional ByVal IRowEnd As Long = -1, Optional ByVal IColEnd As Long = -1) As String","Private Function File_exist(ByVal file As String) As Integer","Private Function XLSSuch(Optional ByVal startdir As String = \"C:\\\", Optional ByVal StBeschriftung As String = \"Exceldatei (*.xl*) suchen\") As String","Private Function XLSSuchNeu(Optional ByVal startdir As String = \"C:\\\", Optional ByVal StBeschriftung As String = \"Exceldatei (*.txt) suchen\") As String"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"'---------------------------------------------------------------------------------------\n' Klassenmodul    : clsExcel\n' DateTime        : 25.10.2007 20:33\n' Author          : Klaus Oberdalhoff\n' Purpose         : Diverse Excel-Funktionen (Sammelsurium) als Klasse zusammengefasst\n'---------------------------------------------------------------------------------------\nOption Compare Database\nOption Explicit\n\n\n'Diese Tabellen können nur aus dem VBA-Editor direkt oder per VBA wieder eingeblendet werden.\n'per VBA über Sheets(\"Name_des_Blattes\").Visible = xlVeryHidden - siehe als Ansatz dazu Arbeitsblatt ausblenden.\n'Sheets(\"Tabelle1\").Visible =  xlVeryHidden  =  2\n'Sheets(\"Tabelle1\").Visible = True\n\n'ActiveSheet.Name = \"Date (altered)\"\n'If you are renaming the first sheet use:\n'Sheets(1).Name = \"Date (altered)\"\n'If you are renaming a sheet with a specific name use:\n'Sheets(\"Sheet1\").Name = \"Date (altered)\"\n\n\n' Benötigt die Klasse FileDialog\n' ##############################\n   \n    Const xlMaximized As Long = -4137\n    Const xlMinimized As Long = -4140\n    Const xlNormal = -4143\n    \n    Const xlUp = -4162\n    Const xlToLeft = -4159\n    Const xlToRight = -4161\n    Const xlDown = -4121\n    \n    Dim m_xlObj As Object\n    Dim m_objActiveWkb As Object\n    Dim m_objActSheet As Object\n    Dim m_objActRange As Object\n    Dim m_Sheetnames As Variant\n    \n'Ein Dummy ....\nDim m_FarbNoMatrix\n\n    Dim m_NewWkb As Object\n    \n    Dim m_xl_ForeignOpen As Boolean\n    Dim m_IsDirty As Boolean\n\n    Dim m_xl_Col As Long\n    Dim m_xl_Row As Long\n\n    Dim m_xl_RowStart As Long\n    Dim m_xl_ColStart As Long\n    \n    Dim m_xl_RowEnd As Long\n    Dim m_xl_ColEnd As Long\n       \n    Dim m_xl_RdOnly As Boolean\n    Dim m_SheetVersion As String\n\n    Dim m_WkbDateiname As String\n\n    Dim m_Actual_Sheet_No As Long\n    '\n    \nPublic Property Get xlSheetnameTable() As Object\n    If Not IsArray(m_Sheetnames) Then\n        SheetNames_read\n    End If\n    Set xlSheetnameTable = m_Sheetnames\nEnd Property\n   \nPublic Property Get xlSheetCount() As Integer\n    xlSheetCount = m_objActiveWkb.Sheets.Count\nEnd Property\n   \nPublic Property Get xlSheetnameNum(Optional si As Variant) As Variant\n    Dim i As Long\n    If Not IsArray(m_Sheetnames) Then\n        SheetNames_read\n    End If\n    If Len(Trim(Nz(si))) = 0 Then\n        xlSheetnameNum = m_Sheetnames(1)\n    ElseIf IsNumeric(si) And si <= UBound(m_Sheetnames) Then\n        xlSheetnameNum = m_Sheetnames(si)\n    Else\n        xlSheetnameNum = -1\n        For i = 1 To UBound(m_Sheetnames)\n            If m_Sheetnames(i) = si Then\n                xlSheetnameNum = i\n                Exit For\n            End If\n        Next i\n    End If\nEnd Property\n\nPrivate Function SheetNames_read()\nDim i As Long\n\nReDim m_Sheetnames(1)\nFor i = 1 To m_objActiveWkb.Sheets.Count\n    ReDim Preserve m_Sheetnames(i)\n    m_Sheetnames(i) = m_objActiveWkb.Sheets(i).Name\nNext i\n\nEnd Function\n\nPublic Function xl_wkb_Close()\nIf Not m_objActiveWkb Is Nothing Then\n    m_objActiveWkb.Close\n    Set m_objActiveWkb = Nothing\nEnd If\nEnd Function\n   \n\n'---------------------------------------------------------------------------------------\n' Procedure : XL_Wkb_Open_RDOnly\n' DateTime  : 25.10.2007 22:22\n' Author    : Klaus Oberdalhoff\n' Purpose   : Workbook Read Only öffnen\n'---------------------------------------------------------------------------------------\n'\nPublic Function XL_Wkb_Open_RDOnly(strDateiname As String, Optional Pwd As String = \"\") As Object\n    \n    On Error GoTo 0\n      \n    m_WkbDateiname = strDateiname\n    \n    If Not File_exist(m_WkbDateiname) Then\n        m_WkbDateiname = XLSSuch()\n    End If\n    \n    If Not File_exist(m_WkbDateiname) Then\n        MsgBox \"Kein gültiger Dateiname\"\n        Exit Function\n    End If\n\n    If m_xlObj Is Nothing Then\n        Set m_xlObj = xlObj()\n    End If\n\n    DoEvents\n    Sleep 10\n    DoEvents\n    DBEngine.Idle dbRefreshCache\n    DBEngine.Idle dbFreeLocks\n    DoEvents\n    \n    With m_xlObj\n    '   .Workbooks.Add  'neue Tabelle erstellen\n       .Workbooks.Open m_WkbDateiname, 0, True, , Pwd, Pwd\n       .Application.DisplayAlerts = False\n '      .Application.ActiveWorkbook.RejectAllChanges\n       \n       Set m_objActiveWkb = .Application.ActiveWorkbook\n       m_FarbNoMatrix = m_objActiveWkb.Colors\n    End With\n    \n    DoEvents\n    Sleep 10\n    DoEvents\n    DBEngine.Idle dbRefreshCache\n    DBEngine.Idle dbFreeLocks\n    DoEvents\n    \n    m_xl_RdOnly = True\n    m_IsDirty = False\n           \n    SheetNames_read\n    Set XL_Wkb_Open_RDOnly = m_objActiveWkb\n\nEnd Function\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : XL_Wkb_Open_RDWR\n' DateTime  : 25.10.2007 22:22\n' Author    : Klaus Oberdalhoff\n' Purpose   : Workbook Read Write öffnen\n'---------------------------------------------------------------------------------------\n'\nPublic Function XL_Wkb_Open_RDWR(strDateiname As String, Optional Pwd As String = \"\") As Object\n    \n    On Error GoTo 0\n    \n    m_WkbDateiname = strDateiname\n    \n    If Not File_exist(m_WkbDateiname) Then\n        m_WkbDateiname = XLSSuch()\n    End If\n    \n    If Not File_exist(m_WkbDateiname) Then\n        MsgBox \"Kein gültiger Dateiname\"\n        Exit Function\n    End If\n\n    If m_xlObj Is Nothing Then\n        Set m_xlObj = xlObj()\n    End If\n\n    With m_xlObj\n    '   .Workbooks.Add  'neue Tabelle erstellen\n       .Workbooks.Open m_WkbDateiname, 3, False, , Pwd, Pwd\n       .Application.DisplayAlerts = True\n '      .Application.ActiveWorkbook.RejectAllChanges\n       \n       Set m_objActiveWkb = .Application.ActiveWorkbook\n    End With\n    \n    m_xl_RdOnly = False\n    m_IsDirty = True\n    \n    m_FarbNoMatrix = m_objActiveWkb.Colors\n    SheetNames_read\n    Set XL_Wkb_Open_RDWR = m_objActiveWkb\n\nEnd Function\n\n'---------------------------------------------------------------------------------------\n' Procedure : XL_Wkb_Add\n' DateTime  : 25.10.2007 22:27\n' Author    : Klaus Oberdalhoff\n' Purpose   : Neues Workbook öffnen\n'---------------------------------------------------------------------------------------\n'\nPublic Function XL_Wkb_Add(Optional xlVorl As String) As Object\n       \n    Dim xlVorlage As String\n       \n    If m_xlObj Is Nothing Then\n        Set m_xlObj = xlObj()\n    End If\n\n    xlVorlage = \"\"\n    If Len(Trim(Nz(xlVorl))) > 0 Then\n        If Len(Trim(Dir(xlVorl))) > 0 Then\n            xlVorlage = xlVorl\n        End If\n    End If\n\n    With m_xlObj\n        If Len(Trim(Nz(xlVorlage))) > 0 Then\n           .Workbooks.Add xlVorlage  'neue Tabelle mit Vorlage erstellen\n        Else\n           .Workbooks.Add  'neue Tabelle erstellen\n        End If\n    \n       Set m_objActiveWkb = .Application.ActiveWorkbook\n'       m_objActiveWkb.AcceptAllChanges ' set Excel file read write\n       \n       .Application.DisplayAlerts = True\n    End With\n\n    m_xl_RdOnly = False\n    m_IsDirty = True\n    \n    SheetNames_read\n    Set XL_Wkb_Add = m_objActiveWkb\n    \nEnd Function\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : XL_actWkb_SaveAs\n' DateTime  : 25.10.2007 22:22\n' Author    : Klaus Oberdalhoff\n' Purpose   : Workbook speichern unter\n'---------------------------------------------------------------------------------------\n'\nPublic Function XL_actWkb_SaveAs(strDateiname As String)\n       \n    Dim m_WkbDateiname1 As String\n    Const xlOpenXMLWorkbookMacroEnabled As Long = 52\n    \n    m_WkbDateiname1 = Nz(strDateiname)\n    If Len(Trim(Nz(strDateiname))) = 0 Then\n        m_WkbDateiname1 = XLSSuchNeu()\n    End If\n       \n    If File_exist(m_WkbDateiname1) Then\n        If vbYes = MsgBox(\"Achtung, Datei existiert bereits, überschreiben (J/N)\", vbQuestion + vbYesNo, strDateiname) Then\n            Kill m_WkbDateiname1\n        Else\n            Exit Function\n        End If\n    End If\n    \n    If File_exist(m_WkbDateiname1) Then\n        MsgBox \"Fehler: Dateiname existiert\"\n        Exit Function\n    End If\n      \n    If m_xlObj Is Nothing Then\n        MsgBox \"Fehler: Excel nicht offen\"\n        Exit Function\n    End If\n    \n    If m_objActiveWkb Is Nothing Then\n        MsgBox \"Fehler: Excel-Workbook nicht offen\"\n        Exit Function\n    End If\n    \n    m_objActiveWkb.SaveAs fileName:=m_WkbDateiname1, FileFormat:=xlOpenXMLWorkbookMacroEnabled\n    \n    m_WkbDateiname = m_WkbDateiname1\n    m_IsDirty = False\n       \nEnd Function\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : xlObj\n' DateTime  : 25.10.2007 20:35\n' Author    : Klaus Oberdalhoff\n' Purpose   : Excel öffnen und Excel-Main-Objekt zurückgeben\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get xlObj() As Object\n\nIf m_xlObj Is Nothing Then\n    On Error Resume Next 'See if Excel is running\n        \n    Set m_xlObj = GetObject(, \"Excel.Application\")\n     If err.Number <> 0 Then 'Excel Not running\n       err.clear   ' Clear Err object in case error occurred.\n       'Create a new instance of Excel\n       Set m_xlObj = CreateObject(\"Excel.Application\")\n       'Wenn Excel noch nicht gestartet war True, sonst False\n       m_xl_ForeignOpen = False\n     Else\n       'Activate instance of Excel\n         m_xlObj.Activate\n         m_xl_ForeignOpen = True\n     End If\n    \n    With m_xlObj\n        'Alle Excel Events unterbinden\n        .EnableEvents = False\n        .WindowState = xlMaximized\n    '        .Visible = False\n        .Visible = True\n    End With\n    \nEnd If\n\nSet xlObj = m_xlObj\n\nOn Error GoTo 0\n\nEnd Property\n\nPublic Function XL_Visible(X As Boolean)\nIf m_xlObj Is Nothing Then\n    Exit Function\nEnd If\nm_xlObj.Visible = X\nEnd Function\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : XL_Close\n' DateTime  : 25.10.2007 20:37\n' Author    : Klaus Oberdalhoff\n' Purpose   : Excel schliessen\n'---------------------------------------------------------------------------------------\n'\nPublic Function XL_Close()\n\n   On Error GoTo XL_Close_Error\n\nOn Error GoTo XL_Close_Err\n\nIf m_xlObj Is Nothing Then\n    Exit Function\nEnd If\n\nIf Not m_xl_RdOnly = True And Len(Trim(Nz(m_WkbDateiname))) > 0 And m_IsDirty = True Then\n    m_objActiveWkb.Save\n'    If Len(Trim(Nz(Dir(m_WkbDateiname)))) > 0 Then Kill m_WkbDateiname\n'\n''Wenn Excel von hier gestartet wurde (boolXL = True), Excel wieder schließen\n''If boolXL = True Then xlObj.Application.Quit\n'\n'    m_objActiveWkb.SaveAs filename:=m_WkbDateiname\nEnd If\n\nXL_Close_Err:\nOn Error Resume Next\n\nIf Not m_objActiveWkb Is Nothing Then\n    m_objActiveWkb.Close\n    Set m_objActiveWkb = Nothing\nEnd If\n\n'Nur wenn Excel von hier gestartet wurde (m_xl_ForeignOpen = False), Excel wieder schließen\nIf m_xl_ForeignOpen = True Then\n    With m_xlObj\n        .Activate = True\n        .Visible = True\n        .Application.ScreenUpdating = True\n        .DisplayAlerts = True\n        .EnableEvents = True\n        .WindowState = xlMaximized\n    End With\n    DoEvents\nElse\n    m_xlObj.Application.Quit\n    Set m_xlObj = Nothing\n    DoEvents\nEnd If\nOn Error GoTo 0\n\n   On Error GoTo 0\n   Exit Function\n\nXL_Close_Error:\n\n    MsgBox \"Error \" & err.Number & \" (\" & err.description & \") in procedure XL_Close of Klassenmodul clsExcel\"\nEnd Function\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : XL_Close\n' DateTime  : 25.10.2007 20:37\n' Author    : Klaus Oberdalhoff\n' Purpose   : Excel schliessen\n'---------------------------------------------------------------------------------------\n'\nPublic Function XL_Close_Sure()\n\n   On Error GoTo XL_Close_Error\n\nOn Error GoTo XL_Close_Err\n\nIf m_xlObj Is Nothing Then\n    Exit Function\nEnd If\n\nIf Not m_xl_RdOnly = True And Len(Trim(Nz(m_WkbDateiname))) > 0 And m_IsDirty = True Then\n    m_objActiveWkb.Save\n'    If Len(Trim(Nz(Dir(m_WkbDateiname)))) > 0 Then Kill m_WkbDateiname\n'\n''Wenn Excel von hier gestartet wurde (boolXL = True), Excel wieder schließen\n''If boolXL = True Then xlObj.Application.Quit\n'\n'    m_objActiveWkb.SaveAs filename:=m_WkbDateiname\nEnd If\n\nXL_Close_Err:\nOn Error Resume Next\n\nIf Not m_objActiveWkb Is Nothing Then\n    m_objActiveWkb.Close\n    Set m_objActiveWkb = Nothing\nEnd If\n\nDoEvents\nSleep 120\nDoEvents\n\n    m_xlObj.Application.Quit\n    Set m_xlObj = Nothing\n    \n    DoEvents\n    Sleep 10\n    DoEvents\n    DBEngine.Idle dbRefreshCache\n    DBEngine.Idle dbFreeLocks\n    DoEvents\n\n\nOn Error GoTo 0\n\n   Exit Function\n\nXL_Close_Error:\n\n    MsgBox \"Error \" & err.Number & \" (\" & err.description & \") in procedure XL_Close of Klassenmodul clsExcel\"\nEnd Function\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : Class_Program_Version\n' DateTime  : 25.10.2007 20:35\n' Author    : Klaus Oberdalhoff\n' Purpose   : Version der Klasse zurückgeben\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get Class_Program_Version() As String\n    Class_Program_Version = \"1.3.2.1 - 25.10.2007 - Autor: Klaus Oberdalhoff\"\nEnd Property\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : xlAktWbk\n' DateTime  : 25.10.2007 20:36\n' Author    : Klaus Oberdalhoff\n' Purpose   : Aktives Workbook-Objekt zurückgeben sofern bereits geöffnet\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get xlAktWbk() As Object\nIf m_objActiveWkb Is Nothing Then\n    MsgBox \"Fehler: Erst Workbook öffnen\"\nElse\n    Set xlAktWbk = m_objActiveWkb\nEnd If\nEnd Property\n\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : SetRange\n' DateTime  : 25.10.2007 20:37\n' Author    : Klaus Oberdalhoff\n' Purpose   : Aus Zeilen und Spaltennummern das aktuelle Range-Objekt setzen\n'---------------------------------------------------------------------------------------\n'\nPublic Function SetRange(iRow As Long, iCol As Long, IRowEnd As Long, IColEnd As Long) As Object\nm_xl_RowStart = iRow\nm_xl_RowEnd = IRowEnd\nm_xl_ColStart = iCol\nm_xl_ColEnd = IColEnd\n\nSet m_objActRange = m_objActSheet.Range(m_objActSheet.Cells(m_xl_RowStart, m_xl_ColStart), _\n                                        m_objActSheet.Cells(m_xl_RowEnd, m_xl_ColEnd))\nSet SetRange = m_objActRange\nEnd Function\n\n'---------------------------------------------------------------------------------------\n' Procedure : SetRangeRow\n' DateTime  : 25.10.2007 20:37\n' Author    : Klaus Oberdalhoff\n' Purpose   : Aus Zeilen und Spaltennummern das aktuelle Range-Objekt setzen\n'---------------------------------------------------------------------------------------\n'\nPublic Function SetRangeRow(iRow As Long, IRowEnd As Long) As Object\nm_xl_RowStart = iRow\nm_xl_RowEnd = IRowEnd\n\nSet m_objActRange = m_objActSheet.Range(m_objActSheet.rows(m_xl_RowStart), _\n                                        m_objActSheet.rows(m_xl_RowEnd))\nSet SetRangeRow = m_objActRange\nEnd Function\n\n'---------------------------------------------------------------------------------------\n' Procedure : SetRangeToLastRow\n' DateTime  : 25.10.2007 20:37\n' Author    : Klaus Oberdalhoff\n' Purpose   : Aus Zeilen und Spaltennummern das aktuelle Range-Objekt setzen\n'---------------------------------------------------------------------------------------\n'\nPublic Function SetRangeToLastRow(iRow As Long) As Object\nm_xl_RowStart = iRow\n\nSet m_objActRange = m_objActSheet.Range(m_objActSheet.rows(m_xl_RowStart), _\n                                        m_objActSheet.rows(m_objActSheet.rows.Count))\nSet SetRangeToLastRow = m_objActRange\nEnd Function\n\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : ActSheetRange\n' DateTime  : 25.10.2007 20:39\n' Author    : Klaus Oberdalhoff\n' Purpose   : \"Used Range\" des aktuellen Sheets zurückgeben\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get ActSheetRange() As Object\nDim i As Long, r As Long, c As Long, t As Long\nFor i = 1 To 256 '&H100&\n    t = m_objActSheet.Cells(&H10000, i).End(xlUp).row\n    If t > r Then r = t\n    If t > 1 Then c = i\nNext i\nSet m_objActRange = SetRange(1, 1, r, c)\nm_xl_RowStart = 1\nm_xl_RowEnd = r\nm_xl_ColStart = 1\nm_xl_ColEnd = c\nSet ActSheetRange = m_objActRange\nEnd Property\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : LastRow\n' DateTime  : 25.10.2007 20:39\n' Author    : Klaus Oberdalhoff\n' Purpose   : Höchste/letzte Zeilennummer einer bestimmten Spalte zurückgeben\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get lastRow(Optional col As Long = &H1&) As Long ' Letzte Reihe\nIf col < 1 Then col = 1\nIf col > &H100& Then col = &H100&\nm_xl_RowEnd = m_objActSheet.Cells(&H10000, col).End(xlUp).row\nlastRow = m_xl_RowEnd\nEnd Property\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : LastCol\n' DateTime  : 25.10.2007 20:40\n' Author    : Klaus Oberdalhoff\n' Purpose   : Höchste/letzte Spaltennummer einer bestimmten Zeile zurückgeben\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get LastCol(Optional row As Long = &H1&) As Long  ' Letzte Spalte\nIf row < 1 Then row = 1\nIf row > &H10000 Then row = &H10000\nm_xl_ColEnd = m_objActSheet.Cells(row, &H100&).End(xlToLeft).Column\nLastCol = m_xl_ColEnd\nEnd Property\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : Row\n' DateTime  : 25.10.2007 22:09\n' Author    : Klaus Oberdalhoff\n' Purpose   : Aktive Reihen-Nr lesen\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get row() As Long\nrow = m_xl_Row\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : Row\n' DateTime  : 25.10.2007 22:09\n' Author    : Klaus Oberdalhoff\n' Purpose   : Aktive Reihen-Nr setzen\n'---------------------------------------------------------------------------------------\n'\nPublic Property Let row(iRow As Long)\nIf iRow >= 0 And iRow < 65000 Then\n    m_xl_Row = iRow\nElse\n    m_xl_Row = 0\nEnd If\nEnd Property\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : Col\n' DateTime  : 25.10.2007 22:10\n' Author    : Klaus Oberdalhoff\n' Purpose   : Aktive Spalten-Nr lesen\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get col() As Long\ncol = m_xl_Col\nEnd Property\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : Col\n' DateTime  : 25.10.2007 22:10\n' Author    : Klaus Oberdalhoff\n' Purpose   : Aktive Spalten-Nr setzen\n'---------------------------------------------------------------------------------------\n'\nPublic Property Let col(iCol As Long)\nIf iCol >= 0 And iCol < 257 Then\n    m_xl_Col = iCol\nElse\n    m_xl_Col = 0\nEnd If\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : RowStart\n' DateTime  : 25.10.2007 22:11\n' Author    : Klaus Oberdalhoff\n' Purpose   : StartReihen-Nr lesen\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get RowStart() As Long\nRowStart = m_xl_RowStart\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : RowStart\n' DateTime  : 25.10.2007 22:11\n' Author    : Klaus Oberdalhoff\n' Purpose   : StartReihen-Nr setzen\n'---------------------------------------------------------------------------------------\n'\nPublic Property Let RowStart(iRow As Long)\nIf iRow >= 0 And iRow < 65000 Then\n    m_xl_RowStart = iRow\nElse\n    m_xl_RowStart = 0\nEnd If\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : ColStart\n' DateTime  : 25.10.2007 22:12\n' Author    : Klaus Oberdalhoff\n' Purpose   : StartSpaltenNr lesen\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get ColStart() As Long\nColStart = m_xl_ColStart\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : ColStart\n' DateTime  : 25.10.2007 22:12\n' Author    : Klaus Oberdalhoff\n' Purpose   : StartSpaltenNr setzen\n'---------------------------------------------------------------------------------------\n'\nPublic Property Let ColStart(iCol As Long)\nIf iCol >= 0 And iCol < 257 Then\n    m_xl_ColStart = iCol\nElse\n    m_xl_ColStart = 0\nEnd If\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : RowEnd\n' DateTime  : 25.10.2007 22:12\n' Author    : Klaus Oberdalhoff\n' Purpose   : Endezeilen-Nr lesen\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get RowEnd() As Long\nRowEnd = m_xl_RowEnd\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : RowEnd\n' DateTime  : 25.10.2007 22:12\n' Author    : Klaus Oberdalhoff\n' Purpose   : Endezeilen-Nr setzen\n'---------------------------------------------------------------------------------------\n'\nPublic Property Let RowEnd(iRow As Long)\nIf iRow >= 0 And iRow < 65000 Then\n    m_xl_RowEnd = iRow\nElse\n    m_xl_RowEnd = 0\nEnd If\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : ColEnd\n' DateTime  : 25.10.2007 22:13\n' Author    : Klaus Oberdalhoff\n' Purpose   : EndeSpalten-Nr lesen\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get ColEnd() As Long\nColEnd = m_xl_ColEnd\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : ColEnd\n' DateTime  : 25.10.2007 22:13\n' Author    : Klaus Oberdalhoff\n' Purpose   : EndeSpalten-Nr setzen\n'---------------------------------------------------------------------------------------\n'\nPublic Property Let ColEnd(iCol As Long)\nIf iCol >= 0 And iCol < 257 Then\n    m_xl_ColEnd = iCol\nElse\n    m_xl_ColEnd = 0\nEnd If\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : AktCell\n' DateTime  : 25.10.2007 22:14\n' Author    : Klaus Oberdalhoff\n' Purpose   : Aktive Zelle aus Zeilen- und Spaltennr\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get AktCell() As Object\nSet AktCell = m_objActSheet.Range(GetCellAsStr(m_xl_Row, m_xl_Col))\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : StartCell\n' DateTime  : 25.10.2007 22:15\n' Author    : Klaus Oberdalhoff\n' Purpose   : Start Zelle aus Zeilen- und Spaltennr\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get StartCell() As Object\nSet StartCell = m_objActSheet.Range(GetCellAsStr(m_xl_RowStart, m_xl_ColStart))\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : EndCell\n' DateTime  : 25.10.2007 22:15\n' Author    : Klaus Oberdalhoff\n' Purpose   : Ende Zelle aus Zeilen- und Spaltennr\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get EndCell() As Object\nSet EndCell = m_objActSheet.Range(GetCellAsStr(m_xl_RowEnd, m_xl_ColEnd))\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : ActSheet\n' DateTime  : 25.10.2007 22:16\n' Author    : Klaus Oberdalhoff\n' Purpose   : Active Sheet Objekt\n'---------------------------------------------------------------------------------------\n'\nPublic Property Get ActSheet() As Object\nIf m_objActiveWkb Is Nothing Then\n    MsgBox \"Fehler: Erst Workbook öffnen\"\nElse\n    If m_objActSheet Is Nothing Then\n        Set m_objActSheet = m_objActiveWkb.Worksheets(1)\n    End If\n    m_objActSheet.Select\n    Set ActSheet = m_objActSheet\nEnd If\nEnd Property\n\n'---------------------------------------------------------------------------------------\n' Procedure : SelectSheet\n' DateTime  : 25.10.2007 22:16\n' Author    : Klaus Oberdalhoff\n' Purpose   : Sheet auswählen entweder via Zahl oder \"Name\"\n'---------------------------------------------------------------------------------------\n'\nPublic Function SelectSheet(Optional ByVal Sheet As Variant = 1) As Object\n'Sheet kann Index (numerisch) oder Name (Text) sein\n\nIf m_objActiveWkb Is Nothing Then\n    MsgBox \"Fehler: Erst Workbook öffnen\"\nElse\n    Set m_objActSheet = Nothing\n    Set m_objActSheet = m_objActiveWkb.Worksheets(Sheet)\n    m_objActSheet.Select\n    If m_objActSheet Is Nothing Then\n        MsgBox \"Fehler: Kein Sheet vorhanden\"\n    End If\nEnd If\nSet SelectSheet = m_objActSheet\nEnd Function\n\nPublic Function SelectSheet_Test(Optional ByVal Sheet As Variant = 1) As Boolean\nDim obj As Object\n   On Error GoTo SelectSheet_Test_Error\n\nSelectSheet_Test = False\nSet obj = SelectSheet(Sheet)\nSelectSheet_Test = True\n\n   On Error GoTo 0\n   Exit Function\n\nSelectSheet_Test_Error:\n\nSelectSheet_Test = False\n    err.clear\n    \n    DoEvents\n    Sleep 10\n    DoEvents\n    DBEngine.Idle dbRefreshCache\n    DBEngine.Idle dbFreeLocks\n    DoEvents\n\nEnd Function\n\n'---------------------------------------------------------------------------------------\n' Procedure : GetRangeFromActSheet\n' DateTime  : 25.10.2007 22:17\n' Author    : Klaus Oberdalhoff\n' Purpose   : Range aus Start- und Ende Zeile- und Spaltennr\n'---------------------------------------------------------------------------------------\n'\nPublic Function GetRangeFromActSheet() As Object\nSet GetRangeFromActSheet = m_objActSheet.Range(m_objActSheet.Cells(m_xl_RowStart, m_xl_ColStart), m_objActSheet.Cells(m_xl_RowEnd, m_xl_ColEnd))\nEnd Function\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : CellStr2RowCol\n' DateTime  : 25.10.2007 22:18\n' Author    : Klaus Oberdalhoff\n' Purpose   : Umrechnen Rangewert eines Strings z.B. \"C1:G7\" in Start- und Ende Zeile- und Spalten-Nr\n'---------------------------------------------------------------------------------------\n'\nPublic Function CellStr2RowCol(Cell1 As String)\nDim i As Long\nDim j As Long\nDim iCol As Long\nDim iRowEnd_Start As Long\nDim strRow As String\nDim Cell As String\n\nCell = UCase(Cell1)\nIf Len(Trim(Nz(Cell))) = 0 Then Exit Function\n\nstrRow = \"\"\nj = Len(Cell)\niRowEnd_Start = InStr(1, Cell, \":\")\n    \nIf iRowEnd_Start > 0 Then\n    j = iRowEnd_Start - 1\n    For i = 1 To j\n        If IsNumeric(Mid(Cell, i, 1)) Then\n            strRow = strRow & Mid(Cell, i, 1)\n        Else\n            iCol = iCol + (Asc(Mid(Cell, i, 1)) - 64)\n        End If\n    Next i\n    m_xl_RowStart = CLng(strRow)\n    m_xl_ColStart = iCol\n    \n    iCol = 0\n    strRow = \"\"\n    \n    j = Len(Cell)\n    For i = iRowEnd_Start + 1 To j\n        If IsNumeric(Mid(Cell, i, 1)) Then\n            strRow = strRow & Mid(Cell, i, 1)\n        Else\n            iCol = iCol + (Asc(Mid(Cell, i, 1)) - 64)\n        End If\n    Next i\n    m_xl_RowEnd = CLng(strRow)\n    m_xl_ColEnd = iCol\n    \n    iCol = 0\n    strRow = \"\"\nElse\n    j = Len(Cell)\n    For i = 1 To j\n        If IsNumeric(Mid(Cell, i, 1)) Then\n            strRow = strRow & Mid(Cell, i, 1)\n        Else\n            iCol = iCol + (Asc(Mid(Cell, i, 1)) - 64)\n        End If\n    Next i\n    m_xl_Row = CLng(strRow)\n    m_xl_Col = iCol\n    \n    iCol = 0\n    strRow = \"\"\n\nEnd If\n\nEnd Function\n\n'---------------------------------------------------------------------------------------\n' Procedure : GetCellAsStr\n' DateTime  : 25.10.2007 22:19\n' Author    : Klaus Oberdalhoff\n' Purpose   : Stringwert einer Zelle z.B: \"C7\" aus Zeilen- und Spalten-Nr\n'---------------------------------------------------------------------------------------\n'\nPublic Function GetCellAsStr(iRow As Long, iCol As Long) As String\nIf Not (iCol > 256 Or iCol <= 0 Or iRow > 65000 Or iRow <= 0) Then\n    If iCol > 26 Then\n        GetCellAsStr = Chr$(64 + (iCol \\ 26)) & Chr$(64 + (iCol Mod 26)) & CStr(iRow)\n    Else\n        GetCellAsStr = Chr$(64 + iCol) & CStr(iRow)\n    End If\nEnd If\nEnd Function\n\n'---------------------------------------------------------------------------------------\n' Procedure : GetRangeAsStr\n' DateTime  : 25.10.2007 22:21\n' Author    : Klaus Oberdalhoff\n' Purpose   : Stringwert einers Ranges z.B: \"C7:G19\" aus Start- und Ende- Zeilen- und Spalten-Nr\n'---------------------------------------------------------------------------------------\n'\nPublic Function GetRangeAsStr(ByVal iRow As Long, ByVal iCol As Long, Optional ByVal IRowEnd As Long = -1, Optional ByVal IColEnd As Long = -1) As String\n\nIf IRowEnd = -1 And IColEnd = -1 Then\n    IRowEnd = iRow\n    IColEnd = iCol\nEnd If\n\nIf Not (iCol > 256 Or iCol <= 0 Or iRow > 65000 Or iRow <= 0 Or _\n    IColEnd > 256 Or IColEnd <= 0 Or IRowEnd > 65000 Or IRowEnd <= 0) Then\n    If iCol > 26 Then\n        GetRangeAsStr = Chr$(64 + (iCol \\ 26)) & Chr$(64 + (iCol Mod 26)) & CStr(iRow)\n    Else\n        GetRangeAsStr = Chr$(64 + iCol) & CStr(iRow)\n    End If\n    GetRangeAsStr = GetRangeAsStr & \":\"\n    If IColEnd > 26 Then\n        GetRangeAsStr = GetRangeAsStr & Chr$(64 + (IColEnd \\ 26)) & Chr$(64 + (IColEnd Mod 26)) & CStr(IRowEnd)\n    Else\n        GetRangeAsStr = GetRangeAsStr & Chr$(64 + IColEnd) & CStr(IRowEnd)\n    End If\nEnd If\n\nEnd Function\n\n\n'**********************************************************************************\n'Function File_Exist ()\n'\n'   Überprüft, ob die Datei vorhanden ist\n'   Rückgabe:  True, Datei vorhanden\n'              False, Datei nicht vorhanden\n'**********************************************************************************\nPrivate Function File_exist(ByVal file As String) As Integer\nDim f\n\nf = FreeFile\nOn Error GoTo File_existError\nOpen file For Input Access Read As #f\nClose #f\nFile_exist = True\nExit Function\n\nFile_existError:\nFile_exist = False\nExit Function\n\nEnd Function\n\n\n'---------------------------------------------------------------------------------------\n' Procedure : XLSSuch\n' DateTime  : 25.10.2007 22:23\n' Author    : Klaus Oberdalhoff\n' Purpose   : Bestehenden XLS-Dateiname via FileDialog suchen (zum lesen öffnen)\n' Purpose   : Verwendet Klassenmodul FileDialog\n'---------------------------------------------------------------------------------------\n'\nPrivate Function XLSSuch(Optional ByVal startdir As String = \"C:\\\", Optional ByVal StBeschriftung As String = \"Exceldatei (*.xl*) suchen\") As String\n\nDim fd As New FileDialog\n         \nConst OFN_FILEMUSTEXIST = &H1000\nConst OFN_PATHMUSTEXIST = &H800\nConst OFN_HIDEREADONLY = &H4\nConst OFN_READONLY = &H1\nConst OFN_OVERWRITEPROMPT = &H2\n   \n   With fd  ' CommonDialog aufrufen\n    ' Erläuterungen im Code des KlassenModuls FileDialog\n      \n      .DialogTitle = StBeschriftung\n      .InitDir = startdir\n      \n      .DefaultExt = \"XLS\"             'Standard-Endung wenn vom Benutzer nix anderes angegeben\n'                                      ' Ansonsten wird Filter1 verwendet\n'      .Flags = OFN_FILEMUSTEXIST Or OFN_PATHMUSTEXIST Or OFN_READONLY\n      .Flags = OFN_FILEMUSTEXIST Or OFN_PATHMUSTEXIST\n                      \n' Hier können bis max. 5 Filter für Datei-Endungen definiert werden\n      \n      .Filter1Text = \"Excel-Dateien (*.xl*)\"\n      .Filter1Suffix = \"*.xl*\"\n      .Filter2Text = \"Excel-Dateien (*.xls)\"\n      .Filter2Suffix = \"*.xls\"\n      .Filter3Text = \"Alle Dateien (*.*)\"\n      .Filter3Suffix = \"*.*\"\n'      .Filter4Text = \"MDB-Dateien (*.mdb)\"\n'      .Filter4Suffix = \"*.mdb\"\n'      .Filter5Text = \"MD*-Dateien (*.md*)\"\n'      .Filter5Suffix = \"*.md*\"\n\n'      ... bis max. Filter5Text/Suffix ...\n'\n      .ShowOpen                          ' oder .ShowSave\n   End With\n   \nXLSSuch = fd.fileName\n\nEnd Function\n\n'---------------------------------------------------------------------------------------\n' Procedure : XLSSuchNeu\n' DateTime  : 25.10.2007 22:24\n' Author    : Klaus Oberdalhoff\n' Purpose   : Noch nicht bestehenden XLS-Dateiname via FileDialog suchen (zum schreiben öffnen)\n' Purpose   : Verwendet Klassenmodul FileDialog\n'---------------------------------------------------------------------------------------\n'\nPrivate Function XLSSuchNeu(Optional ByVal startdir As String = \"C:\\\", Optional ByVal StBeschriftung As String = \"Exceldatei (*.txt) suchen\") As String\n\nDim fd As New FileDialog\n         \nConst OFN_FILEMUSTEXIST = &H1000\nConst OFN_PATHMUSTEXIST = &H800\nConst OFN_HIDEREADONLY = &H4\nConst OFN_READONLY = &H1\nConst OFN_OVERWRITEPROMPT = &H2\n   \n   With fd  ' CommonDialog aufrufen\n    ' Erläuterungen im Code des KlassenModuls FileDialog\n      \n      .DialogTitle = StBeschriftung\n      .InitDir = startdir\n      \n      .DefaultExt = \"XLS\"             'Standard-Endung wenn vom Benutzer nix anderes angegeben\n'                                      ' Ansonsten wird Filter1 verwendet\n'      .Flags = OFN_FILEMUSTEXIST Or OFN_PATHMUSTEXIST Or OFN_READONLY\n'      .Flags = OFN_FILEMUSTEXIST Or OFN_PATHMUSTEXIST\n      .Flags = OFN_OVERWRITEPROMPT Or OFN_PATHMUSTEXIST\n\n' Hier können bis max. 5 Filter für Datei-Endungen definiert werden\n      \n      .Filter1Text = \"Excel-Dateien (*.xl*)\"\n      .Filter1Suffix = \"*.xl*\"\n      .Filter2Text = \"Excel-Dateien (*.xls)\"\n      .Filter2Suffix = \"*.xls\"\n      .Filter3Text = \"Alle Dateien (*.*)\"\n      .Filter3Suffix = \"*.*\"\n'      .Filter4Text = \"MDB-Dateien (*.mdb)\"\n'      .Filter4Suffix = \"*.mdb\"\n'      .Filter5Text = \"MD*-Dateien (*.md*)\"\n'      .Filter5Suffix = \"*.md*\"\n\n'      ... bis max. Filter5Text/Suffix ...\n'\n      '.ShowOpen\n      '' oder\n      .ShowSave\n   \n   End With\n   \nXLSSuchNeu = fd.fileName\n\nEnd Function\n\n'    Range(\"F23\").Select\n'    With Selection\n'        .NumberFormat = \"@\"\n'        .HorizontalAlignment = xlCenter\n'        .VerticalAlignment = xlCenter\n'        .WrapText = False\n'        .AddIndent = False\n'        .ShrinkToFit = True\n'        .MergeCells = False\n'        .Locked = False\n'        .FormulaHidden = False\n'        .Orientation = 0\n'        .IndentLevel = 0\n'        .ReadingOrder = xlLTR\n'    End With\n'    With Selection.Font\n'        .Name = \"Arial\"\n'        .FontStyle = \"Standard\"\n'        .Size = 9\n'        .Strikethrough = False\n'        .Superscript = True\n'        .Subscript = False\n'        .OutlineFont = False\n'        .Shadow = False\n'        .Underline = xlUnderlineStyleNone\n'        .ColorIndex = xlAutomatic\n\n'XlUnderlineStyle kann eine der folgenden XlUnderlineStyle-Konstanten sein.\n'\n'xlUnderlineStyleNone\n'xlUnderlineStyleSingle\n'xlUnderlineStyleDouble\n'\n'xlUnderlineStyleSingleAccounting\n'xlUnderlineStyleDoubleAccounting\n\n'    End With\n'\n'    Range(\"F14:F17\").Select\n'    With Selection.Borders(xlDiagonalDown)\n'        .LineStyle = xlContinuous\n'        .Weight = xlThick\n'        .ColorIndex = 50\n'    End With\n'    With Selection.Borders(xlDiagonalUp)\n'        .LineStyle = xlContinuous\n'        .Weight = xlThick\n'        .ColorIndex = 50\n'    End With\n'    With Selection.Borders(xlEdgeLeft)\n'        .LineStyle = xlContinuous\n'        .Weight = xlThick\n'        .ColorIndex = 45\n'    End With\n'    With Selection.Borders(xlEdgeTop)\n'        .LineStyle = xlContinuous\n'        .Weight = xlThick\n'        .ColorIndex = 46\n'    End With\n'    With Selection.Borders(xlEdgeBottom)\n'        .LineStyle = xlContinuous\n'        .Weight = xlThick\n'        .ColorIndex = 46\n'    End With\n'    With Selection.Borders(xlEdgeRight)\n'        .LineStyle = xlContinuous\n'        .Weight = xlThick\n'        .ColorIndex = 50\n'    End With\n'    Selection.Borders(xlInsideHorizontal).LineStyle = xlNone\n'\n'    Range(\"DW20\").Select\n'    Selection.NumberFormat = \"0.00\"\n'    ActiveCell.FormulaR1C1 = \"=17*22\"\n'    Columns(\"DX:DZ\").Select\n'    Columns(\"DW:DW\").ColumnWidth = 9.29\n'    Range(\"DN7:FM7\").Select\n'\n\n'##################################################################################\n'  http://www.cpearson.com/excel/mainpage.aspx\n'\n'Functions For Working With Cell Colors\n'##################################################################################\n'\n'Excel does not have any  built-in worksheet functions for working with the colors of cells or fonts.\n'If you want to read or test the color of a cell, you have to use VBA procedure.\n'This page describes several functions for counting and summing cells based on the\n'color of the font or background.   All of these functions use the ColorIndex property.\n'Excel worksheets can't have the vast amount of colors that other applications support.\n'In Excel, you are limited to the 56 colors that are part of the Color Pallet for the workbook.\n'You may assign any color you want to an entry in the Color Pallet, but each workbook is\n'limited to a total of 56 different colors.\n'\n'The ColorIndex of a range is simply the offset of the color into the Color Pallet table.\n'For example, ColorIndex 6 is simply the sixth entry in the Color Pallet.\n'You can change the default colors in the Color Pallet of a workbook by using the Colors array.\n'For example, to change ColorIndex 6 from yellow (the default) to red, use the following code:\n'\n'ThisWorkbook.Colors(6) = RGB(255, 0, 0)\n'\n'If you use the Color property of a cell's Font or Interior, Excel will change the value you assign to\n'the closest match color that exists in the current Color Pallet.\n'\n'NOTE: When you change the background or font color of a cell, Excel does not consider this to\n'be changing the value of the cell.  Therefore, it will not recalculate the worksheet, nor\n'will it trigger a Worksheet_Change event procedure.  This means that the values returned by\n'these functions may not be correct immediately after you change the color of a cell.  They\n'will not return an updated value until you recalculate the worksheet by pressing ALT+F9 or by\n'changing the actual value of a cell.  There is no practical work-around to this.  You could\n'use the Worksheet_SelectionChange event procedure to force a calculation, but this could have\n'a serious and detrimental impact on performance.\n'\n'NOTE:  These functions will not detect colors that are applied by Conditional Formatting.\n'They will read only the default colors of the cell and its text.   For information about returning\n'colors in effect by conditional formatting, see the Conditional Formatting Colors page.\n'\n'It is important to remember that if a cell has no color assigned to it, and therefore\n'appears to be white, the ColorIndex is equal to the constant xlColorIndexNone, or -4142.\n'It does not equal 2, the default ColorIndex value for white.\n'Similarly, text that has not been assigned a color, and therefore appears to be black,\n'has a ColorIndex value equal to the constant xlColorIndexAutomatic, or -4105. It does not equal 1,\n'the default ColorIndex value for black.\n'\n'The sections below describe a number of VBA functions for working with cell colors.\n'\n'Returning The ColorIndex Of A Cell\n'\n'The following function will return the ColorIndex property of a cell.  InRange is the cell to\n'examine, OfText indicates whether to return  the ColorIndex of the Font (if True) or the\n'Interior (if False).  If  InRange contains more than one cell, the first cell (InRange(1,1))\n'of the range is tested.\n'\n'Function CellColorIndex(InRange As Range, Optional _\n'    OfText As Boolean = False) As Integer\n'\n' This function returns the ColorIndex value of a the Interior\n' (background) of a cell, or, if OfText is true, of the Font in the cell.\n'\n'm_xlObj.Volatile True\n'If OfText = True Then\n'    CellColorIndex = InRange(1, 1).Font.ColorIndex\n'Else\n'    CellColorIndex = InRange(1, 1).Interior.ColorIndex\n'End If\n'\n'End Function\n\n'You can call this function from a worksheet cell with a formula like\n'=CELLCOLORINDEX(A1,FALSE)\n'\n'Counting Cells With A Specific Color\n'\n'The following function will return the number of cells in a range that have either an\n'Interior (background) or Font of a specified color.  InRange is the range of cells\n'to examine, WhatColorIndex is the ColorIndex value to count, and OfText indicates\n'whether to return  the ColorIndex of the Font (if OfText is True) or the Interior\n'(if OfText is False or omitted).\n''\n'Function CountByColor(InRange As Range, _\n'    WhatColorIndex As Integer, _\n'    Optional OfText As Boolean = False) As Long\n''\n'' This function return the number of cells in InRange with\n'' a background color, or if OfText is True a font color,\n'' equal to WhatColorIndex.\n''\n'Dim Rng As Range\n'm_xlObj.Volatile True\n'\n'For Each Rng In InRange.Cells\n'If OfText = True Then\n'    CountByColor = CountByColor - _\n'            (Rng.Font.ColorIndex = WhatColorIndex)\n'Else\n'    CountByColor = CountByColor - _\n'       (Rng.Interior.ColorIndex = WhatColorIndex)\n'End If\n'Next Rng\n'\n'End Function\n'\n'You can call this function from a worksheet cell with a formula like\n'=COUNTBYCOLOR(A1:A10,3,FALSE)\n'\n'Summing The Values Of Cells With A Specific Color\n'\n'The following function will return the sum of cells in a range that have either an\n'Interior (background) or Font of a specified colorindex.  InRange is the range of\n'cells to examine, WhatColorIndex is the ColorIndex value to count, and OfText indicates\n'whether to return  the ColorIndex of the Font (if True) or the Interior (if False).\n'\n'Function SumByColor(InRange As Range, WhatColorIndex As Integer, _\n'    Optional OfText As Boolean = False) As Double\n''\n'' This function return the SUM of the values of cells in\n'' InRange with a background color, or if OfText is True a\n'' font color, equal to WhatColorIndex.\n''\n'Dim Rng As Range\n'Dim OK As Boolean\n'\n'm_xlObj.Volatile True\n'For Each Rng In InRange.Cells\n'    If OfText = True Then\n'        OK = (Rng.Font.ColorIndex = WhatColorIndex)\n'    Else\n'        OK = (Rng.Interior.ColorIndex = WhatColorIndex)\n'    End If\n'    If OK And IsNumeric(Rng.Value) Then\n'        SumByColor = SumByColor + Rng.Value\n'    End If\n'Next Rng\n'\n'End Function\n'\n'You can call this function from a worksheet cell with a formula like\n'=SUMBYCOLOR(A1:A10,3,FALSE)\n\n\n\n\n'Summing The Values Of Cells Based On The Color Of Other Cells\n'\n'The following function will return the sum of cells in a range which correspond to cells in\n'another range that have either an Interior (background) or Font of a specified color.\n'InRange is the range of cells to examine, WhatColorIndex is the ColorIndex value to count,\n'SumRange is the range of value to sum, and OfText indicates whether to return  the ColorIndex\n'of the Font (if True) or the Interior (if False).\n'\n'Function SumIfByColor(InRange As Range, _\n'    WhatColorIndex As Integer, SumRange As Range, _\n'    Optional OfText As Boolean = False) As Variant\n''\n'' This function will return the SUM of the values of cells in\n'' SumRange where the corresponding cell in InRange has a background\n'' color (or font color, if OfText is true) equal to WhatColorIndex.\n''\n'Dim OK As Boolean\n'Dim Ndx As Long\n'\n'm_xlObj.Volatile True\n'\n'If (InRange.Rows.Count <> SumRange.Rows.Count) Or _\n'    (InRange.Columns.Count <> SumRange.Columns.Count) Then\n'    SumIfByColor = CVErr(xlErrRef)\n'    Exit Function\n'End If\n'\n'For Ndx = 1 To InRange.Cells.Count\n'    If OfText = True Then\n'        OK = (InRange.Cells(Ndx).Font.ColorIndex = WhatColorIndex)\n'    Else\n'        OK = (InRange.Cells(Ndx).Interior.ColorIndex = WhatColorIndex)\n'    End If\n'    If OK And IsNumeric(SumRange.Cells(Ndx).Value) Then\n'        SumIfByColor = SumIfByColor + SumRange.Cells(Ndx).Value\n'    End If\n'Next Ndx\n'\n'End Function\n'\n'You can call this function from a worksheet cell with a formula like\n'=SUMIFBYCOLOR(A1:A10,3,B1:B10,FALSE)\n\n'Getting The Range Of Cells With A Specific Color\n'\n'The following function will return a Range object consisting of those cells in a\n'range that have either an Interior (background) or Font of a specified color.\n'InRange is the range of cells to examine, WhatColorIndex is the ColorIndex value to count,\n'and OfText indicates whether to use the ColorIndex of the Font (if OfText is True) or the\n'Interior (if OfText False or omitted).  This function uses the AddRange function to combine\n'two ranges into a single range, without the possible problems of the Application.Union method.\n'See AddRange, below, for more details about this function.\n'\n'Function RangeOfColor(InRange As Range, _\n'    WhatColorIndex As Integer, _\n'    Optional OfText As Boolean = False) As Range\n''\n'' This function returns a Range of cells in InRange with a\n'' background color, or if OfText is True a font color,\n'' equal to WhatColorIndex.\n''\n'Dim Rng As Range\n'm_xlObj.Volatile True\n'\n'For Each Rng In InRange.Cells\n'    If OfText = True Then\n'        If (Rng.Font.ColorIndex = WhatColorIndex) = True Then\n'            Set RangeOfColor = AddRange(RangeOfColor, Rng)\n'        End If\n'    Else\n'        If (Rng.Interior.ColorIndex = WhatColorIndex) = True Then\n'            Set RangeOfColor = AddRange(RangeOfColor, Rng)\n'        End If\n'    End If\n'Next Rng\n'\n'End Function\n'\n'\n''The following function will return the address, as a string, of the range returned by RangeOfColor.\n'\n'Function AddressOfRangeOfColor(InRange As Range, _\n'    WhatColorIndex As Integer, _\n'    Optional OfText As Boolean = False) As String\n''\n'' This function returns the address of the result range of RangeOfColor.\n''\n'Dim Rng As Range\n'Set Rng = RangeOfColor(InRange, WhatColorIndex, OfText)\n'If Rng Is Nothing Then\n'    AddressOfRangeOfColor = \"\"\n'Else\n'    AddressOfRangeOfColor = Rng.Address\n'End If\n'\n'End Function\n'\n'\n''Getting Range Of A Cell With A Specific Color\n''\n''The following function will return a Range object consisting of the cell in a\n''range that has either an Interior (background) or Font of a specified color.\n''InRange is the range of cells to examine, WhatColorIndex is the ColorIndex value to count,\n''FindWhich indicates which cell to return, and OfText indicates whether to return  the\n''ColorIndex of the Font (if True) or the Interior (if False). The value of FindWhich can\n''be 0 to return the address of last cell with the specified color, or any positive integer\n''to return that occurance (e.g., 3 to return the third occurance).\n''\n'Function FindColor(InRange As Range, WhatColorIndex As Integer, _\n'    FindWhich As Long, Optional OfText As Boolean = False) As Range\n''\n'' This function returns the Range of a cell in InRange with a\n'' background color, or if OfText is True a font color, equal\n'' to WhatColorIndex. Which cell address is returned depends on\n'' the value of FindWhich:\n'' 0 = last occurance\n'' 1 to n = the first, second, etc, nth occurance.\n''\n'Dim Rng As Range\n'Dim Addr As String\n'Dim OK As Boolean\n'Dim Ndx As Long\n'\n'For Each Rng In InRange\n'    If OfText = True Then\n'        OK = (Rng.Font.ColorIndex = WhatColorIndex)\n'    Else\n'        OK = (Rng.Interior.ColorIndex = WhatColorIndex)\n'    End If\n'    If OK Then\n'        Ndx = Ndx + 1\n'        If FindWhich = 0 Then\n'            Set FindColor = Rng\n'        Else\n'            If FindWhich = Ndx Then\n'                Set FindColor = Rng\n'                Exit Function\n'            End If\n'        End If\n'    End If\n'Next Rng\n'\n'End Function\n'\n'\n''The following function will return the address, as a string, of the range returned by .\n'\n'Function AddressOfFindColor(InRange As Range, _\n'   WhatColorIndex As Integer, FindWhich As Long, _\n'   Optional OfText As Boolean = False) As String\n''\n'' This function returns the address of the result of FindColor.\n''\n'Dim Rng As Range\n'Set Rng = FindColor(InRange, WhatColorIndex, FindWhich, OfText)\n'If Rng Is Nothing Then\n'    AddressOfFindColor = \"\"\n'Else\n'    AddressOfFindColor = Rng.Address\n'End If\n'\n'End Function\n'\n'\n''AddRange\n''\n''The following function will return a Range object that is the logical union of two ranges.\n''Unlike the Application.Union method, AddRange will not return duplicate cells in the result.  For example,\n''\n''Application.Union(Range(\"A1:B3\"), Range(\"B3:D5\")).Cells.Count\n''\n''will return 15, since B3 is counted twice, once in each range.\n''\n''AddRange(Range(\"A1:B3\"), Range(\"B3:D5\")).Cells.Count\n''\n''willl return 14, counting B3 only once.\n''\n'Function AddRange(ByVal Range1 As Range, _\n'    ByVal Range2 As Range) As Range\n'Dim Rng As Range\n'\n'If Range1 Is Nothing Then\n'    If Range2 Is Nothing Then\n'        Set AddRange = Nothing\n'    Else\n'    Set AddRange = Range2\n'    End If\n'Else\n'    If Range2 Is Nothing Then\n'        Set AddRange = Range1\n'    Else\n'        Set AddRange = Range1\n'        For Each Rng In Range2\n'            If m_xlObj.Intersect(Rng, Range1) Is Nothing Then\n'                Set AddRange = m_xlObj.Union(AddRange, Rng)\n'            End If\n'        Next Rng\n'    End If\n'End If\n'\n'End Function\n'\n\n \n\n'##################################################################################\n'  http://www.cpearson.com/excel/mainpage.aspx\n'\n'Sorting By Color\n'##################################################################################\n'\n'If you have color-code cells in your worksheet, you find that at times it is useful to sort\n'rows by the colors of the cells.  That is, sort all the reds at the top, followed by the blues,\n'followed by the yellows, and so on.\n'Unfortunately, Excel provides no such tool. You have to do it manually.\n'This page describes how to do it.\n'\n'The first thing you need to do is create an additional column that will contain the ColorIndex\n'(click here for more information about the ColorIndex) of either the font or the background of the cell.\n'To the right of the data you want to sort, insert a new column by selecting the cell the right of the\n'data, and choosing Columns from the Insert menu.\n'\n'Next, you need a VBA function to return the ColorIndex value of the cell.\n'Put the following code in a standard code module in your workbook.\n'\n'Function ColorIndexOfCell(Rng As Range, _\n'    Optional OfText As Boolean, _\n'    Optional DefaultAsIndex As Boolean = True) As Integer\n'\n'Dim C As Long\n'If OfText = True Then\n'    C = Rng.Font.ColorIndex\n'Else\n'    C = Rng.Interior.ColorIndex\n'End If\n'\n'If (C < 0) And (DefaultAsIndex = True) Then\n'    If OfText = True Then\n'        C = GetBlack(Rng.Worksheet.Parent)\n'    Else\n'        C = GetWhite(Rng.Worksheet.Parent)\n'    End If\n'End If\n'\n'ColorIndexOfCell = C\n'\n'End Function\n'\n'\n'Function GetWhite(WB As Workbook) As Long\n'    Dim Ndx As Long\n'    For Ndx = 1 To 56\n'        If WB.Colors(Ndx) = &HFFFFFF Then\n'            GetWhite = Ndx\n'            Exit Function\n'        End If\n'    Next Ndx\n'    GetWhite = 0\n'End Function\n'\n'Function GetBlack(WB As Workbook) As Long\n'    Dim Ndx As Long\n'    For Ndx = 1 To 56\n'        If WB.Colors(Ndx) = 0& Then\n'            GetBlack = Ndx\n'            Exit Function\n'        End If\n'    Next Ndx\n'    GetBlack = 0\n'End Function\n'\n'\n''Then, in the newly created column, enter either of the following formulas:\n''\n''If you want to sort by the Background color of the cell, use the formula\n''\n''=ColorIndexOfCell(A1,FALSE,TRUE)\n''\n''If you want to sort by the Font color of the cell, use the formula\n''\n''=ColorIndexOfCell(A1,TRUE,TRUE)\n''\n''Of course, change the reference A1 to the first cell in the range.  Use Edit, Fill, Down to fill this\n''formula down to the entire range of data you want to sort.\n''\n''In these cells, you'll see numbers between 1 and 56.  Each of the values indicates the ColorIndex of the cell.\n''\n''Now, you can sort your data in the normal way, but choose the new column as the primary or first sort key.\n''The cells will be sorted in ascending (or descending) order of the ColorIndex values.\n''\n''So far, this is all well and good if you are happy with the default order of ColorIndex values.\n''For example, by default, Red = 2, Blue= 5, and Yellow = 6.\n''Therefore, when sorting by ColorIndex values, the data will list all the reds first,\n''followed by the blues, then the yellows.\n''\n''If you want to modify this order, you will need to create a \"custom list\" and tell\n''Excel to use this list as the sort order.  First, create a custom list by going to the\n''Tools menu, Options item, Custom Lists tab, and selecting NEW LIST in the Custom Lists box.\n''Then, enter the ColorIndex values in the order you want them to appear in ascending sorts,\n''in the List Entries box. You can enter the numeric values (between 1 and 56) on separate lines\n''in the List Entries box (create a new line by pressing ALT+ENTER) or by separating the entries\n''with a comma all on the same line. (NOTE: Non-USA English users may have to use a semicolon\n''rather than a comma.)  For example, to sort in order Blue, Yellow, Red, the custom list\n''would be (without the quotes) \"5,6,2\".\n''\n''Then, in the Sort dialog box, click the Sort By drop down box, click the Options button, and choose\n''this new list from the lists displayed.\n''\n''Yes, sorting by color is a bit tricky, and something that we all would like to see built in to Excel.\n''However, until Microsoft provides this feature as a built in tool, we must make the best of what is available.\n''\n''NOTE: This method sorts by the color specified by the cell's properties.\n''It does NOT work with colors that are displayed as a result of Conditional Formatting.\n''\n'\n'\n'\n'\n''##################################################################################\n''  http://www.cpearson.com/excel/CFColors.htm\n''\n''Conditional Formatting Colors\n''##################################################################################\n''\n''Unfortunately, the Color and ColorIndex properties of a Range don't return the color of a\n''cell that is displayed if Conditional formatting is applied to the cell.  Nor does it allow\n''you to determine whether a conditional format is currently in effect for a cell.\n''In order to determine these, you need code that will test the format conditions. This page\n''describes several VBA functions that will do this for you.\n''\n''ActiveCondition\n''This function will return the number of the condition that is currently applied to the cell.\n''If the cell does not have any conditional formatting defined, or none of the conditional formats\n''are currently applied, it returns 0. Otherwise, it returns 1, 2, or 3, indicating with format\n''condition is in effect. ActiveCondition requires the GetStrippedValue function at the bottom of this page.\n''\n''NOTE: ActiveCondition may result in an inaccurate result if the following are true:\n''\n''You are calling ActiveCondtion from a worksheet cell, AND\n''The cell passed to ActiveCondtion uses a \"Formula Is\" rather than\n''\"Cell Value Is\" condition, AND\n''The formula used in the condition formula contains relative addresses\n''To prevent this problem, you must use absolute cell address in the condition formula.\n''\n''ColorOfCF\n''This function will return the RGB color in effect for either the text or the background of the cell.\n''This function requires the ActiveCondition function. You can call this function directly from a\n''worksheet cell with a formula like:\n''=ColorOfCF(A1,FALSE)\n''\n''ColorIndexOfCF\n''This function will return the color index in effect for either the text or the background of the cell.\n''This function requires the ActiveCondition function.  You can call this function directly from a\n''worksheet cell with a formula like:\n''=ColorIndexOfCF(A1,FALSE)\n''\n''\n''CountOfCF\n''This function return the number of cells in a range that have a specified conditional format applied.\n''Set the last argument to -1 to look at all format conditions, or a number between 1 and 3 to\n''specify a particular condition.  This function requires the ActiveCondition function.\n''You can call this function directly from a worksheet cell with a formula like:\n''=CountOfCF(A1:A10,1)\n''\n''SumByCFColorIndex\n''This function sums the cells that have a specified background color applied by conditional formatting.\n''\n'\n'Function ActiveCondition(Rng As Range) As Integer\n'Dim Ndx As Long\n'Dim FC As Excel.FormatCondition\n'Dim Temp As Variant\n'Dim Temp2 As Variant\n'\n'If Rng.FormatConditions.Count = 0 Then\n'    ActiveCondition = 0\n'Else\n'    For Ndx = 1 To Rng.FormatConditions.Count\n'        Set FC = Rng.FormatConditions(Ndx)\n'        Select Case FC.Type\n'            Case xlCellValue\n'            Select Case FC.Operator\n'                Case xlBetween\n'                    Temp = GetStrippedValue(FC.Formula1)\n'                    Temp2 = GetStrippedValue(FC.Formula2)\n'                    If IsNumeric(Temp) Then\n'                       If CDbl(Rng.Value) >= CDbl(FC.Formula1) And _\n'                           CDbl(Rng.Value) <= CDbl(FC.Formula2) Then\n'                           ActiveCondition = Ndx\n'                           Exit Function\n'                       End If\n'                   Else\n'                      If Rng.Value >= Temp And _\n'                         Rng.Value <= Temp2 Then\n'                         ActiveCondition = Ndx\n'                         Exit Function\n'                      End If\n'                   End If\n'\n'                Case xlGreater\n'                    Temp = GetStrippedValue(FC.Formula1)\n'                    If IsNumeric(Temp) Then\n'                       If CDbl(Rng.Value) > CDbl(FC.Formula1) Then\n'                          ActiveCondition = Ndx\n'                          Exit Function\n'                       End If\n'                    Else\n'                       If Rng.Value > Temp Then\n'                          ActiveCondition = Ndx\n'                          Exit Function\n'                       End If\n'                    End If\n'\n'                Case xlEqual\n'                    Temp = GetStrippedValue(FC.Formula1)\n'                    If IsNumeric(Temp) Then\n'                       If CDbl(Rng.Value) = CDbl(FC.Formula1) Then\n'                           ActiveCondition = Ndx\n'                           Exit Function\n'                       End If\n'                    Else\n'                       If Temp = Rng.Value Then\n'                          ActiveCondition = Ndx\n'                          Exit Function\n'                       End If\n'                    End If\n'\n'\n'                Case xlGreaterEqual\n'                    Temp = GetStrippedValue(FC.Formula1)\n'                    If IsNumeric(Temp) Then\n'                       If CDbl(Rng.Value) >= CDbl(FC.Formula1) Then\n'                           ActiveCondition = Ndx\n'                           Exit Function\n'                       End If\n'                    Else\n'                       If Rng.Value >= Temp Then\n'                          ActiveCondition = Ndx\n'                          Exit Function\n'                       End If\n'                    End If\n'\n'\n'                Case xlLess\n'                    Temp = GetStrippedValue(FC.Formula1)\n'                    If IsNumeric(Temp) Then\n'                        If CDbl(Rng.Value) < CDbl(FC.Formula1) Then\n'                           ActiveCondition = Ndx\n'                           Exit Function\n'                        End If\n'                    Else\n'                        If Rng.Value < Temp Then\n'                           ActiveCondition = Ndx\n'                           Exit Function\n'                        End If\n'                    End If\n'\n'                Case xlLessEqual\n'                    Temp = GetStrippedValue(FC.Formula1)\n'                    If IsNumeric(Temp) Then\n'                       If CDbl(Rng.Value) <= CDbl(FC.Formula1) Then\n'                          ActiveCondition = Ndx\n'                          Exit Function\n'                       End If\n'                    Else\n'                       If Rng.Value <= Temp Then\n'                          ActiveCondition = Ndx\n'                          Exit Function\n'                       End If\n'                    End If\n'\n'\n'                Case xlNotEqual\n'                    Temp = GetStrippedValue(FC.Formula1)\n'                    If IsNumeric(Temp) Then\n'                       If CDbl(Rng.Value) <> CDbl(FC.Formula1) Then\n'                          ActiveCondition = Ndx\n'                          Exit Function\n'                       End If\n'                    Else\n'                       If Temp <> Rng.Value Then\n'                          ActiveCondition = Ndx\n'                          Exit Function\n'                       End If\n'                    End If\n'\n'               Case xlNotBetween\n'                    Temp = GetStrippedValue(FC.Formula1)\n'                    Temp2 = GetStrippedValue(FC.Formula2)\n'                    If IsNumeric(Temp) Then\n'                       If Not (CDbl(Rng.Value) <= CDbl(FC.Formula1)) And _\n'                          (CDbl(Rng.Value) >= CDbl(FC.Formula2)) Then\n'                          ActiveCondition = Ndx\n'                          Exit Function\n'                       End If\n'                    Else\n'                       If Not Rng.Value <= Temp And _\n'                          Rng.Value >= Temp2 Then\n'                          ActiveCondition = Ndx\n'                          Exit Function\n'                       End If\n'                    End If\n'\n'               Case Else\n'                    Debug.Print \"UNKNOWN OPERATOR\"\n'           End Select\n'\n'\n'        Case xlExpression\n'            If m_xlObj.Evaluate(FC.Formula1) Then\n'               ActiveCondition = Ndx\n'               Exit Function\n'            End If\n'\n'        Case Else\n'            Debug.Print \"UNKNOWN TYPE\"\n'       End Select\n'\n'    Next Ndx\n'\n'End If\n'\n'ActiveCondition = 0\n'\n'\n'\n'End Function\n'\n'\n''''''''''''''''''''''''''''''''''''''''\n'\n'\n'Function ColorIndexOfCF(Rng As Range, _\n'    Optional OfText As Boolean = False) As Integer\n'\n'Dim AC As Integer\n'AC = ActiveCondition(Rng)\n'If AC = 0 Then\n'    If OfText = True Then\n'       ColorIndexOfCF = Rng.Font.ColorIndex\n'    Else\n'       ColorIndexOfCF = Rng.Interior.ColorIndex\n'    End If\n'Else\n'    If OfText = True Then\n'       ColorIndexOfCF = Rng.FormatConditions(AC).Font.ColorIndex\n'    Else\n'       ColorIndexOfCF = Rng.FormatConditions(AC).Interior.ColorIndex\n'    End If\n'End If\n'\n'End Function\n'\n'\n''''''''''''''''''''''''''''''''''''''''\n'\n'\n'Function ColorOfCF(Rng As Range, Optional OfText As Boolean = False) As Long\n'\n'Dim AC As Integer\n'AC = ActiveCondition(Rng)\n'If AC = 0 Then\n'    If OfText = True Then\n'       ColorOfCF = Rng.Font.Color\n'    Else\n'       ColorOfCF = Rng.Interior.Color\n'    End If\n'Else\n'    If OfText = True Then\n'       ColorOfCF = Rng.FormatConditions(AC).Font.Color\n'    Else\n'       ColorOfCF = Rng.FormatConditions(AC).Interior.Color\n'    End If\n'End If\n'\n'End Function\n'\n''''''''''''''''''''''''''''''''''''''''\n'\n'Function GetStrippedValue(cf As String) As String\n'    Dim Temp As String\n'    If InStr(1, cf, \"=\", vbTextCompare) Then\n'       Temp = Mid(cf, 3, Len(cf) - 3)\n'       If Left(Temp, 1) = \"=\" Then\n'           Temp = Mid(Temp, 2)\n'       End If\n'    Else\n'       Temp = cf\n'    End If\n'    GetStrippedValue = Temp\n'End Function\n'\n'\n''''''''''''''''''''''''''''''''''''''''\n'\n'Function CountOfCF(InRange As Range, _\n'    Optional Condition As Integer = -1) As Long\n'    Dim Count As Long\n'    Dim Rng As Range\n'    Dim FCNum As Integer\n'\n'    For Each Rng In InRange.Cells\n'        FCNum = ActiveCondition(Rng)\n'        If FCNum > 0 Then\n'            If Condition = -1 Or Condition = FCNum Then\n'                Count = Count + 1\n'            End If\n'        End If\n'    Next Rng\n'    CountOfCF = Count\n'End Function\n'\n''''''''''''''''''''''''''''''''''''''''\n'\n'Function SumByCFColorIndex(Rng As Range, CI As Integer) As Double\n'    Dim R As Range\n'    Dim Total As Double\n'    For Each R In Rng.Cells\n'        If ColorIndexOfCF(R, False) = CI Then\n'            Total = Total + R.Value\n'        End If\n'    Next R\n'    SumByCFColorIndex = Total\n'End Function\n'\n''RGB Colors\n''\n''A color is defined by a number made up of the Red, Green, and Blue components of the color.\n''To convert the individual components to a color value, you can use the VBA function RGB.  For example,\n''\n''ActiveCell.Interior.Color = RGB(100, 123, 50)\n''\n''However, there is no built-in method to break out the individual color components from a color value.\n''The procedure below will accomplish this.\n'\n'Sub GetRGB(ByVal RGB As Long, ByRef red As Integer, _\n'    ByRef green As Integer, ByRef blue As Integer)\n'    red = RGB And 255\n'    green = RGB \\ 256 And 255\n'    blue = RGB \\ 256 ^ 2 And 255\n'End Sub\n'\n'Function GetRGBRed(RGB As Long) As Long\n'   GetRGBRed = RGB And 255\n'End Function\n'\n'Function GetRGBGreen(RGB As Long) As Long\n'   GetRGBGreen = RGB \\ 256 And 255\n'End Function\n'\n'Function GetRGBBlue(RGB As Long) As Long\n'   GetRGBBlue = RGB \\ 256 ^ 2 And 255\n'End Function\n'\n'\n''Ist es möglich mittels VBA durch alle bedingten Formate eines Sheets\n''gehen und bzw. alle bedingten Formatierungen finden.\n''\n''Falls es noch jemand brauchen kann:\n''\n'Sub Liste_Bedingter_Formatierungen() 'Ka Prucha 2007-10-10\n' Dim Bedingt As Range, Zelle As Range\n' Dim Adr$, oldadr$, TP$, OP$, Fo1$, Fo2$, Text$\n' On Error Resume Next\n' ActiveCell.SpecialCells(xlCellTypeAllFormatConditions).Select\n' Set Bedingt = ActiveCell.SpecialCells(xlCellTypeAllFormatConditions)\n' For Each Zelle In Bedingt\n'  Adr = Zelle.MergeArea.Address\n'  If Adr <> oldadr Then\n'   oldadr = Adr     'Verbundene Zellen nur einmal ausgeben\n'   With Range(Adr)\n'    TP = .FormatConditions.item(1).Type\n'    OP = .FormatConditions.item(1).Operator\n'    Fo1 = .FormatConditions.item(1).Formula1\n'    Fo2 = .FormatConditions.item(1).Formula2\n'   End With\n'   Text = Adr\n'   Select Case TP\n'    Case xlCellValue\n'    Text = Text & \": Zellwert ist\"\n'    Select Case OP\n'     Case xlBetween: Text = Text & \" zwischen \"\n'     Case xlNotBetween: Text = Text & \" nicht zwischen \"\n'     Case xlEqual: Text = Text & \" gleich \"\n'     Case xlNotEqual: Text = Text & \" ungleich \"\n'     Case xlGreater: Text = Text & \" größer als \"\n'     Case xlLess: Text = Text & \" kleiner als \"\n'     Case xlGreaterEqual: Text = Text & \" größer gleich \"\n'     Case xlLessEqual: Text = Text & \" kleiner gleich \"\n'     Case Else\n'      MsgBox \"Unbekannter Vergleichsoperator\"\n'    End Select\n'    Case xlExpression: Text = Text & \": Formel ist \"\n'    Case Else\n'     MsgBox \"Unbekannter Bedingungstyp\"\n'   End Select\n'   Text = Text & Fo1\n'   If TP = xlCellValue Then\n'    If OP = xlBetween Or OP = xlNotBetween Then\n'     Text = Text & \" und \" & Fo2\n'    End If\n'   End If\n'   Debug.Print Text\n'  End If\n' Next\n'End Sub\n'\n'Function CreaComment(rg As Range, Kommentar As String, Optional FontSize As Long = 14, Optional ISBold As Boolean = False)\n'\n''Show Comments\n''Application.DisplayCommentIndicator = xlCommentAndIndicator\n'\n''Hide Comments\n''Application.DisplayCommentIndicator = xlCommentIndicatorOnly\n'\n''With Zelle.Comment\n'''   Set Comment Background Color\n''       .Shape.Fill.ForeColor.SchemeColor = VBA.ColorConstants.\n''\n'''   Set Comment TextColor\n''       .Shape.TextFrame.Characters.Font.ColorIndex = VBA.ColorConstants.\n''End With\n'\n'    rg.Select\n'    rg.AddComment\n'    rg.Comment.shape.TextFrame.Characters.Font.Size = FontSize\n'    rg.Comment.shape.TextFrame.Characters.Font.Bold = ISBold\n''    rg.Comment.Shape.TextFrame.Characters.Font.ColorIndex = 3 'Red\n'    rg.Comment.Visible = False\n'    rg.Comment.Text Text:=Kommentar\n'    rg.Comment.shape.TextFrame.AutoSize = True\n'\n'End Function\n'\n''Sub Kommentar_Test()\n''\n''Set WS1 = Worksheets(\"Testdatei\")\n''\n''    WS1.Range(\"C2:U459\").SelectComments\n''    Selection.ShapeRange.IncrementLeft -93#\n''    Selection.ShapeRange.IncrementTop 14.25\n''\n''    With Selection.Font\n''        .Name = \"Arial\"\n''        .FontStyle = \"Fett\"\n''        .Size = 12\n''        .Strikethrough = False\n''        .Superscript = False\n''        .Subscript = False\n''        .OutlineFont = False\n''        .Shadow = False\n''        .Underline = xlUnderlineStyleNone\n''        .ColorIndex = 3\n''    End With\n''\n''    With Selection\n''        .HorizontalAlignment = xlLeft\n''        .VerticalAlignment = xlCenter\n''        .Orientation = xlHorizontal\n''        .AutoSize = False\n''    End With\n''\n''    Selection.ShapeRange.Line.Weight = 1#\n''    Selection.ShapeRange.Line.DashStyle = msoLineSolid\n''    Selection.ShapeRange.Line.Style = msoLineSingle\n''    Selection.ShapeRange.Line.Transparency = 0#\n''    Selection.ShapeRange.Line.Visible = msoTrue\n''    Selection.ShapeRange.Line.ForeColor.RGB = RGB(0, 0, 0)\n''    Selection.ShapeRange.Line.BackColor.RGB = RGB(255, 255, 255)\n''    Selection.ShapeRange.Fill.Visible = msoTrue\n''    Selection.ShapeRange.Fill.ForeColor.SchemeColor = 15\n''    Selection.ShapeRange.Fill.Transparency = 0#\n''    Selection.ShapeRange.Fill.OneColorGradient msoGradientHorizontal, 4, 0.35\n''\n''End Sub\n''\n''\n''Private Sub Worksheet_Change(ByVal Target As Range)\n''    On Error Resume Next\n''    For Each Zelle In Cells.SpecialCells(xlCellTypeComments)\n''        With Zelle.Font\n''            .Name = \"Arial\"\n''            .FontStyle = \"Fett\"\n''            .Size = 12\n''            .Strikethrough = False\n''            .Superscript = False\n''            .Subscript = False\n''            .OutlineFont = False\n''            .Shadow = False\n''            .Underline = xlUnderlineStyleNone\n''            .ColorIndex = 3\n''        End With\n''        With Zelle\n''            .HorizontalAlignment = xlLeft\n''            .VerticalAlignment = xlCenter\n''            .Orientation = xlHorizontal\n''            '.AutoSize = False\n''        End With\n''        With Zelle.Comment\n''            .Shape.IncrementLeft -93#\n''            .Shape.IncrementTop 14.25\n''            .Shape.Line.Weight = 1#\n''            .Shape.Line.DashStyle = msoLineSolid\n''            .Shape.Line.Style = msoLineSingle\n''            .Shape.Line.Transparency = 0#\n''            .Shape.Line.Visible = msoTrue\n''            .Shape.Line.ForeColor.RGB = RGB(0, 0, 0)\n''            .Shape.Line.BackColor.RGB = RGB(255, 255, 255)\n''            .Shape.Fill.Visible = msoTrue\n''            .Shape.Fill.ForeColor.SchemeColor = 15\n''            .Shape.Fill.Transparency = 0#\n''            .Shape.Fill.OneColorGradient msoGradientHorizontal, 4, 0.35\n''        End With\n''    Next Zelle\n''End Sub\n'\n'\n'\n''Public Sub Split_Array()\n''Dim wsTemp          As Worksheet\n''Dim arrValue        As Variant\n''Dim arrColorIndex   As Variant\n''Dim arrFontColorIndex As Variant\n'\n''   Set wsTemp = Worksheets.Add\n''\n''   Worksheets(\"Tabelle1\").UsedRange.Copy wsTemp.Range(\"A1\")\n''\n''   With wsTemp.UsedRange\n''      arrValue = .Value\n''\n''      'Formel für Hintergrundfarbe\n''      ActiveWorkbook.Names.Add Name:=\"Format\", RefersToR1C1:= _\n''                               \"=GET.CELL(63,Tabelle1!RC)\"\n''      .Formula = \"=Format\"\n''      arrColorIndex = .Value\n''\n''      'Formel für Schirftfarbe\n''      ActiveWorkbook.Names.Add Name:=\"Format\", RefersToR1C1:= _\n''                               \"=GET.CELL(24,Tabelle1!RC)\"\n''      arrFontColorIndex = .Value\n''   End With\n''\n''   Application.DisplayAlerts = False\n''   wsTemp.DELETE\n''   Application.DisplayAlerts = True\n''\n''End Sub\n'''\n''    ActiveWorkbook.Names.Add Name:=\"farbe\", RefersToR1C1:= _\n''        \"=GET.CELL(63,Tabelle1!RC1)\"\n''    Worksheets(\"Tabelle2\").Range(\"A:A\").FormulaR1C1 = \"=farbe\"\n'\n''End Function\n'\n'\n''Sub makelastcell()\n''  'David McRitchie,  http://www.mvps.org/dmcritchie/excel/lastcell.htm\n''  Dim x As Long     'revised 2001-08-09 to remove false indication\n''  Dim str As String    'revised 2006-07-05 for lastcell to be is a merged cell\n''  Dim xLong As Long, clong As Long, rlong As Long\n''  On Error GoTo 0\n''  x = MsgBox(\"Do you want the activecell to become \" & _\n''      \"the lastcell\" & Chr(10) & Chr(10) & _\n''      \"Press OK to Eliminate all cells beyond \" _\n''      & ActiveCell.Address(0, 0) & Chr(10) & _\n''      \"Press CANCEL to leave sheet as it is\", _\n''      vbOKCancel + vbCritical + vbDefaultButton2)\n''  If x = vbCancel Then Exit Sub\n''  str = ActiveCell.Address\n''  Range(ActiveCell.Row + ActiveCell.MergeArea.Rows.Count & \":\" & Cells.Rows.Count).DELETE\n''  Range(Cells(1, ActiveCell.Column + ActiveCell.MergeArea.Columns.Count), _\n''     Cells(Cells.Rows.Count, Cells.Columns.Count)).DELETE\n''  xLong = ActiveSheet.UsedRange.Rows.Count   'see J-Walkenbach tip 73\n''  xLong = ActiveSheet.UsedRange.Columns.Count 'might also help\n''\n''  Beep\n''  rlong = Cells.SpecialCells(xlLastCell).Row\n''  clong = Cells.SpecialCells(xlLastCell).Column\n''  If rlong <= ActiveCell.Row And clong <= ActiveCell.Column Then Exit Sub\n''  MsgBox \"Sorry, Have failed to make \" & str & \" your last cell, \" _\n''     & \"possible merged cells involved, check your results\"\n''End Sub\n'\n'\n''GET.CELL\n''\n''Macro Sheets Only\n''Returns information about the formatting, location, or contents of a cell. Use GET.CELL in a macro whose behavior is determined by the status of a particular cell.\n''\n''Syntax\n''\n''GET.CELL(type_num, reference)\n''Type_num    is a number that specifies what type of cell information you want. The following list shows the possible values of type_num and the corresponding results.\n''\n''Type_num Returns\n''\n''1   Absolute reference of the upper-left cell in reference, as text in the current workspace reference style.\n''2   Row number of the top cell in reference.\n''3   Column number of the leftmost cell in reference.\n''4   Same as TYPE(reference).\n''5   Contents of reference.\n''6   Formula in reference, as text, in either A1 or R1C1 style depending on the workspace setting.\n''7   Number format of the cell, as text (for example, \"m/d/yy\" or \"General\").\n'\n''8   Number indicating the cell's horizontal alignment:\n''        1 = General\n''        2 = Left\n''        3 = Center\n''        4 = Right\n''        5 = Fill\n''        6 = Justify\n''        7 = Center across cells\n'\n''9   Number indicating the left-border style assigned to the cell:\n''        0 = No border\n''        1 = Thin line\n''        2 = Medium line\n''        3 = Dashed line\n''        4 = Dotted line\n''        5 = Thick line\n''        6 = Double line\n''        7 = Hairline\n''\n''10  Number indicating the right-border style assigned to the cell. See type_num 9 for descriptions of the numbers returned.\n''11  Number indicating the top-border style assigned to the cell. See type_num 9 for descriptions of the numbers returned.\n''12  Number indicating the bottom-border style assigned to the cell. See type_num 9 for descriptions of the numbers returned.\n''13  Number from 0 to 18, indicating the pattern of the selected cell as displayed in the Patterns tab of the Format Cells dialog box, which appears when you choose the Cells command from the Format menu. If no pattern is selected, returns 0.\n''14  If the cell is locked, returns TRUE; otherwise, returns FALSE.\n''15  If the cell's formula is hidden, returns TRUE; otherwise, returns FALSE.\n''16  A two-item horizontal array containing the width of the active cell and a logical value indicating whether the cell's width is set to change as the standard width changes (TRUE) or is a custom width (FALSE).\n''17  Row height of cell, in points.\n''18  Name of font, as text.\n''19  Size of font, in points.\n''\n''20  If all the characters in the cell, or only the first character, are bold, returns TRUE; otherwise, returns FALSE.\n''21  If all the characters in the cell, or only the first character, are italic, returns TRUE; otherwise, returns FALSE.\n''22  If all the characters in the cell, or only the first character, are underlined, returns TRUE; otherwise, returns FALSE.\n''23  If all the characters in the cell, or only the first character, are struck through, returns TRUE; otherwise, returns FALSE.\n''24  Font color of the first character in the cell, as a number in the range 1 to 56. If font color is automatic, returns 0.\n''25  If all the characters in the cell, or only the first character, are outlined, returns TRUE; otherwise, returns FALSE. Outline font format is not supported by Microsoft Excel for Windows.\n''26  If all the characters in the cell, or only the first character, are shadowed, returns TRUE; otherwise, returns FALSE. Shadow font format is not supported by Microsoft Excel for Windows.\n''\n''27  Number indicating whether a manual page break occurs at the cell:\n''       0 = No break\n''       1 = Row\n''       2 = Column\n''       3 = Both row and column\n'\n''28  Row level (outline).\n''29  Column level (outline).\n''30  If the row containing the active cell is a summary row, returns TRUE; otherwise, returns FALSE.\n''31  If the column containing the active cell is a summary column, returns TRUE; otherwise, returns FALSE.\n''32  Name of the workbook and sheet containing the cell If the window contains only a single sheet that has the same name as the workbook without its extension, returns only the name of the book, in the form BOOK1.XLS. Otherwise, returns the name of the sheet in the form \"[Book1]Sheet1\".\n''33  If the cell is formatted to wrap, returns TRUE; otherwise, returns FALSE.\n''34  Left-border color as a number in the range 1 to 56. If color is automatic, returns 0.\n''35  Right-border color as a number in the range 1 to 56. If color is automatic, returns 0.\n''\n''36  Top-border color as a number in the range 1 to 56. If color is automatic, returns 0.\n''37  Bottom-border color as a number in the range 1 to 56. If color is automatic, returns 0.\n''38  Shade foreground color as a number in the range 1 to 56. If color is automatic, returns 0.\n''39  Shade background color as a number in the range 1 to 56. If color is automatic, returns 0.\n''40  Style of the cell, as text.\n''41  Returns the formula in the active cell without translating it (useful for international macro sheets).\n''42  The horizontal distance, measured in points, from the left edge of the active window to the left edge of the cell. May be a negative number if the window is scrolled beyond the cell.\n''43  The vertical distance, measured in points, from the top edge of the active window to the top edge of the cell. May be a negative number if the window is scrolled beyond the cell.\n''\n''44  The horizontal distance, measured in points, from the left edge of the active window to the right edge of the cell. May be a negative number if the window is scrolled beyond the cell.\n''45  The vertical distance, measured in points, from the top edge of the active window to the bottom edge of the cell. May be a negative number if the window is scrolled beyond the cell.\n''46  If the cell contains a text note, returns TRUE; otherwise, returns FALSE.\n''47  If the cell contains a sound note, returns TRUE; otherwise, returns FALSE.\n''48  If the cells contains a formula, returns TRUE; if a constant, returns FALSE.\n''49  If the cell is part of an array, returns TRUE; otherwise, returns FALSE.\n'\n''50  Number indicating the cell's vertical alignment:\n''        1 = Top\n''        2 = Center\n''        3 = Bottom\n''        4 = Justified\n'\n''51  Number indicating the cell's vertical orientation:\n''        0 = Horizontal\n''        1 = Vertical\n''        2 = Upward\n''        3 = Downward\n'\n''52  The cell prefix (or text alignment) character, or empty text (\"\") if the cell does not contain one.\n''\n''53  Contents of the cell as it is currently displayed, as text, including any additional numbers or symbols resulting from the cell's formatting.\n''54  Returns the name of the PivotTable view containing the active cell.\n''55  Returns the position of a cell within the PivotTableView.\n''56  Returns the name of the field containing the active cell reference if inside a PivotTable view.\n''57  Returns TRUE if all the characters in the cell, or only the first character, are  formatted with a superscript font; otherwise, returns FALSE.\n''58  Returns the font style as text of all the characters in the cell, or only the first character as displayed in the Font tab of the Format Cells dialog box: for example, \"Bold Italic\".\n''59  Returns the number for the underline style:\n''        1 = none\n''        2 = single\n''        3 = double\n''        4 = single accounting\n''        5 = double accounting\n''\n''60  Returns TRUE if all the characters in the cell, or only the first characrter, are formatted with a subscript font; otherwise, it returns FALSE.\n''61  Returns the name of the PivotTable item for the active cell, as text.\n''62  Returns the name of the workbook and the current sheet in the form \"[book1]sheet1\".\n''63  Returns the fill (background) color of the cell.\n''64  Returns the pattern (foreground) color of the cell.\n''65  Returns TRUE if the Add Indent alignment option is on (Far East versions of Microsoft Excel only); otherwise, it returns FALSE.\n''66  Returns the book name of the workbook containing the cell in the form BOOK1.XLS.\n''\n'\n'Public Function Split_Array()\n'Dim wbk                       As Workbook\n'Dim wsTemp                    As Worksheet\n'Dim wsh02                     As Worksheet\n'Dim rg                        As Range\n'\n'Dim LastRow                   As Long\n'Dim LastCol                   As Long\n'\n'Dim strAktTabname             As String\n'\n'Debug.Print \"Start \" & Now\n'\n'\n''\n''    Dim m_xlObj As Object\n''    Dim m_objActiveWkb As Object\n''    Dim m_objActSheet As Object\n''    Dim m_objActRange As Object\n''\n''    Dim m_NewWkb As Object\n''\n''\n'\n'\n'    LastRow = m_objActSheet.Cells.Find(What:=\"*\", _\n'                                     SearchOrder:=xlByRows, _\n'                                     SearchDirection:=xlPrevious).Row\n'    LastCol = m_objActSheet.Cells.Find(What:=\"*\", _\n'                                     SearchOrder:=xlByColumns, _\n'                                     SearchDirection:=xlPrevious).Column\n'    Set rg = m_objActSheet.Range(Cells(1, 1), Cells(LastRow, LastCol))\n'\n'    strAktTabname = m_objActSheet.Name\n'\n'    Set wbk = m_xlObj.Workbooks.Add\n'    Set wsTemp = wbk.Worksheets(1)\n'\n'    rg.Copy wsTemp.Range(\"A1\")\n'    Set rg = wsTemp.Range(rg.Address)\n'\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"Value\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(63,!RC)\"\n'    rg.Formula = \"=Formatierung\"\n'\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"ColorIndex\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für Fontname\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"FontName\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(18,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für Schriftfarbe\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"FontColorIndex\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(24,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für m_arrFontUnderline\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"FontUnderline\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(22,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für m_arrFontBold\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"FontBold\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(20,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für m_arrFontItalic\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"FontItalic\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(21,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für m_arrFontStyle\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"FontStyle\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(58,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'Debug.Print \"m_arrFontStyle - 1\"\n'\n'    'Formel für m_Pattern\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"Pattern\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(13,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für m_PatternColorIndex\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"PatternColorIndex\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(64,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für m_BDColLeft\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"BDColLeft\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(34,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für m_BDColRight\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"BDColRight\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(35,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für m_BDColUp\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"BDColUp\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(36,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für m_BDColDown\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"BDColDown\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(37,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für m_BDLinRight\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"BDLinRight\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(9,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für m_BDLinLeft\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"BDLinLeft\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(10,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für m_BDLinTop\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"BDLinTop\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(11,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'    'Formel für m_BDLinBottom\n'    Set wsh02 = wbk.Worksheets.Add\n'    wsh02.Name = \"BDLinBottom\"\n'    wbk.Names.Add Name:=\"Formatierung\", RefersToR1C1:= _\n'                  \"=GET.CELL(12,!RC)\"\n'    wsh02.Range(rg.Address).Value = rg.Value\n'\n'Debug.Print \"m_BDLinBottom Tl 1 - Ende\"\n'\n'    ' Aufräumen\n'    m_xlObj.DisplayAlerts = False\n'    Set rg = Nothing\n'    wsTemp.DELETE\n'    wbk.Names(\"Formatierung\").DELETE\n'    m_xlObj.DisplayAlerts = True\n'\n'Debug.Print \"m_BDLinBottom Tl 2 - Ende !!!!!!!!!!!!!!!!!!!!\"\n'\n'Debug.Print \"End \" & Now\n'\n'End Function\n'\n'\n'\n'Sub ShadeAlternateRows(rngTarget As Range, intColor As Integer, lngStep As Long)\n'' ################################################################################################\n'' VBA macro tip contributed by Erlandsen Data Consulting\n'' http://www.exceltip.com/st/Row_and_column_background_color_using_VBA_in_Microsoft_Excel/488.html\n'' ################################################################################################\n'' adds a background color = intColor to every lngStep rows in rngTarget\n'' example: ShadeAlternateRows Range(\"A1:D50\"), 27, 2\n'' colors every 2 rows light yellow\n'Dim R As Long\n'    If rngTarget Is Nothing Then Exit Sub\n'    With rngTarget\n'        .Interior.ColorIndex = xlColorIndexNone\n'        ' remove any previous shading\n'        For R = lngStep To .Rows.Count Step lngStep\n'            .Rows(R).Interior.ColorIndex = intColor\n'        Next R\n'    End With\n'End Sub\n'\n'Sub ShadeAlternateColumns(rngTarget As Range, intColor As Integer, lngStep As Long)\n'' ################################################################################################\n'' VBA macro tip contributed by Erlandsen Data Consulting\n'' http://www.exceltip.com/st/Row_and_column_background_color_using_VBA_in_Microsoft_Excel/488.html\n'' ################################################################################################\n'' adds a background color = intColor to every lngStep column in rngTarget\n'' example: ShadeAlternateColumns Range(\"A1:J20\"), 27, 2\n'' colors every 2 columns light  yellow\n'Dim C As Long\n'    If rngTarget Is Nothing Then Exit Sub\n'    With rngTarget\n'        .Interior.ColorIndex = xlColorIndexNone\n'        ' remove any previous shading\n'        For C = lngStep To .Columns.Count Step lngStep\n'            .Columns(C).Interior.ColorIndex = intColor\n'        Next C\n'    End With\n'End Sub\n'\n'\n'Function Xl_SpnachZahl(ByVal X As String) As Long\n'Dim J As Long\n'Dim I As Long\n'Dim K As Long\n'Dim L As Long\n'Dim M As Long\n'Dim N As Long\n'Dim O As Long\n'\n'X = UCase(X)\n'\n'J = Len(X)\n'M = 0\n'N = 0\n'O = 0\n'L = 26\n'For I = J To 1 Step -1\n'    K = (L ^ O)\n'    M = Asc(Mid(X, I, 1)) - 64\n'    N = N + (M * K)\n'    O = O + 1\n'Next I\n'Debug.Print N\n'\n'Xl_SpnachZahl = N\n'\n'End Function\n'\n"}
