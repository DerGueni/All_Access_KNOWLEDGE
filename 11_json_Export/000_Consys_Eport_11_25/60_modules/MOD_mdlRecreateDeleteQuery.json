{"id":"MOD_mdlRecreateDeleteQuery","name":"mdlRecreateDeleteQuery","kind":"standard","procedures":["Public Function FnUndeleteObjects() As Boolean","Private Function FnUndeleteTable(dbDatabase As DAO.Database, _","Private Function FnUndeleteQuery(dbDatabase As DAO.Database, _","Private Function FnCopyQuery(dbDatabase As DAO.Database, _","Private Function PropExists(props As DAO.Properties, _","Private Sub FnCopyLvProperties(objObject As Object, _","Private Function FnGetDeletedTableNameByProp(strRealTableName As String) _"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\n' VBA MODULE: Undelete tables and queries in Microsoft Access\n' (c) 2005 Wayne Phillips (http://www.everythingaccess.com)\n' Written 18/04/2005\n'\n' REQUIREMENTS: VBA DAO Reference, Access 97/2000/2002(XP)/2003\n'\n' This module will allow you to undelete tables and queries\n' after they have been deleted in Access/Jet.\n'\n' Please note that this will only work if you haven't run the\n' 'Compact' or 'Compact And Repair' option from Access/DAO.\n' If you have run the compact option, your tables/queries\n' have been permananetly deleted.\n'\n' You may modify this code as you please,\n' However you must leave the copyright notices in place.\n' Thank you.\n'\n' USAGE: Just import this VBA module into your project\n' and call FnUndeleteObjects()\n'\n' If any un-deletable objects are found, you will be prompted\n' to choose names for the undeleted objects.\n' Note: In Access 2000, table names are usually recovered too.\n\nPublic Function FnUndeleteObjects() As Boolean\n\n'Module (c) 2005 Wayne Phillips (http://www.everythingaccess.com)\n'Written 18/04/2005\n\nOn Error GoTo ErrorHandler:\n\n    Dim strObjectName As String\n    Dim rsTables As DAO.Recordset\n    Dim dbsDatabase As DAO.Database\n\n    Dim tDef As DAO.TableDef\n    Dim qDef As DAO.QueryDef\n\n    Dim intNumDeletedItemsFound As Integer\n\n    Set dbsDatabase = CurrentDb\n\n    For Each tDef In dbsDatabase.TableDefs\n        'This is actually used as a 'Deleted Flag'\n        If tDef.attributes And dbHiddenObject Then\n\n            strObjectName = FnGetDeletedTableNameByProp(tDef.Name)\n            strObjectName = InputBox(\"A deleted TABLE has been found.\" & _\n                                     vbCrLf & vbCrLf & _\n                                     \"To undelete this object, enter a new name:\", _\n                                     \"Access Undelete Table\", strObjectName)\n\n            If Len(strObjectName) > 0 Then\n\n                 FnUndeleteTable CurrentDb, tDef.Name, strObjectName\n\n            End If\n\n            intNumDeletedItemsFound = intNumDeletedItemsFound + 1\n\n        End If\n\n    Next tDef\n\n    For Each qDef In dbsDatabase.QueryDefs\n\n        'Note 'Attributes' flag is not exposed for QueryDef objects,\n        'We could look up the flag by using MSysObjects but\n        'new queries don't get written to MSysObjects until\n        'Access is closed. Therefore we'll just check the\n        'start of the name is '~TMPCLP' ...\n\n        If InStr(1, qDef.Name, \"~TMPCLP\") = 1 Then\n\n            strObjectName = \"\"\n            strObjectName = InputBox(\"A deleted QUERY has been found.\" & _\n                                     vbCrLf & vbCrLf & _\n                                     \"To undelete this object, enter a new name:\", _\n                                     \"Access Undelete Query\", strObjectName)\n\n            If Len(strObjectName) > 0 Then\n\n                 If FnUndeleteQuery(CurrentDb, qDef.Name, strObjectName) Then\n\n                     'We'll rename the deleted object since we've made a\n                     'copy and won't be needing to re-undelete it.\n                     '(To break the condition \"~TMPCLP\" in future...)\n                     qDef.Name = \"~TMPCLQ\" & Right$(qDef.Name, Len(qDef.Name) - 7)\n\n                 End If\n\n            End If\n\n            intNumDeletedItemsFound = intNumDeletedItemsFound + 1\n\n        End If\n\n    Next qDef\n\n    If intNumDeletedItemsFound = 0 Then\n\n        MsgBox \"Unable to find any deleted tables/queries to undelete!\"\n\n    End If\n\n    Set dbsDatabase = Nothing\n    FnUndeleteObjects = True\n\nExitFunction:\n    Exit Function\n\nErrorHandler:\n    MsgBox \"Error occured in FnUndeleteObjects() - \" & _\n            err.description & \" (\" & CStr(err.Number) & \")\"\n    GoTo ExitFunction\n\nEnd Function\n\nPrivate Function FnUndeleteTable(dbDatabase As DAO.Database, _\n                                                strDeletedTableName As String, _\n                                                strNewTableName As String)\n\n'Module (c) 2005 Wayne Phillips (http://www.everythingaccess.com)\n'Written 18/04/2005\n\n    Dim tDef As DAO.TableDef\n\n    Set tDef = dbDatabase.TableDefs(strDeletedTableName)\n\n    'Remove the Deleted Flag...\n    tDef.attributes = tDef.attributes And Not dbHiddenObject\n\n    'Rename the deleted object to the original or new name...\n        tDef.Name = strNewTableName\n\n    dbDatabase.TableDefs.Refresh\n    Application.RefreshDatabaseWindow\n\n    Set tDef = Nothing\n\nEnd Function\n\nPrivate Function FnUndeleteQuery(dbDatabase As DAO.Database, _\n                                                strDeletedQueryName As String, _\n                                                strNewQueryName As String)\n\n'Module (c) 2005 Wayne Phillips (http://www.everythingaccess.com)\n'Written 18/04/2005\n\n    'We can't just remove the Deleted flag on queries\n    '('Attributes' is not an exposed property)\n    'So instead we create a new query with the SQL...\n\n    'Note: Can't use DoCmd.CopyObject as it copies the dbHiddenObject attribute!\n        If FnCopyQuery(dbDatabase, strDeletedQueryName, strNewQueryName) Then\n\n            FnUndeleteQuery = True\n            Application.RefreshDatabaseWindow\n\n        End If\n\nEnd Function\n\nPrivate Function FnCopyQuery(dbDatabase As DAO.Database, _\n                                            strSourceName As String, _\n                                            strDestinationName As String)\n\n'Module (c) 2005 Wayne Phillips (http://www.everythingaccess.com)\n'Written 18/04/2005\n\n    On Error GoTo ErrorHandler:\n\n    Dim qDefOld As DAO.QueryDef\n    Dim qDefNew As DAO.QueryDef\n    Dim field As DAO.field\n\n    Set qDefOld = dbDatabase.QueryDefs(strSourceName)\n    Set qDefNew = dbDatabase.CreateQueryDef(strDestinationName, qDefOld.sql)\n\n    'Copy root query properties...\n        FnCopyLvProperties qDefNew, qDefOld.Properties, qDefNew.Properties\n\n    For Each field In qDefOld.fields\n\n        'Copy each fields individual properties...\n            FnCopyLvProperties qDefNew.fields(field.Name), _\n                                field.Properties, _\n                                qDefNew.fields(field.Name).Properties\n\n    Next field\n\n    dbDatabase.QueryDefs.Refresh\n\n    FnCopyQuery = True\n\nExitFunction:\n    Set qDefNew = Nothing\n    Set qDefOld = Nothing\n\n    Exit Function\n\nErrorHandler:\n    MsgBox \"Error re-creating query '\" & strDestinationName & \"':\" & vbCrLf & _\n                err.description & \" (\" & CStr(err.Number) & \")\"\n    GoTo ExitFunction\n\nEnd Function\n\nPrivate Function PropExists(props As DAO.Properties, _\n                             strPropName As String) As Boolean\n\n'Module (c) 2005 Wayne Phillips (http://www.everythingaccess.com)\n'Written 18/04/2005\n\n'If properties fail to be created, we'll just ignore the errors\nOn Error Resume Next\n\n    Dim prop As DAO.Property\n\n    For Each prop In props\n\n        If prop.Name = strPropName Then\n\n            PropExists = True\n            Exit Function ' Short circuit\n\n        End If\n\n    Next prop\n\n    PropExists = False\n\nEnd Function\n\nPrivate Sub FnCopyLvProperties(objObject As Object, _\n                                                OldProps As DAO.Properties, _\n                                                NewProps As DAO.Properties)\n\n'Module (c) 2005 Wayne Phillips (http://www.everythingaccess.com)\n'Written 18/04/2005\n\n'If properties fail to be created, we'll just ignore the errors\nOn Error Resume Next\n\n    Dim prop As DAO.Property\n    Dim NewProp As DAO.Property\n\n    For Each prop In OldProps\n\n        If Not PropExists(NewProps, prop.Name) Then\n\n            If IsNumeric(prop.Value) Then\n                NewProps.append objObject.CreateProperty(prop.Name, _\n                                                         prop.Type, _\n                                                         CLng(prop.Value))\n            Else\n                NewProps.append objObject.CreateProperty(prop.Name, _\n                                                         prop.Type, _\n                                                         prop.Value)\n            End If\n\n        Else\n\n            With NewProps(prop.Name)\n\n                .Type = prop.Type\n                .Value = prop.Value\n\n            End With\n\n        End If\n\n    Next prop\n\nEnd Sub\n\nPrivate Function FnGetDeletedTableNameByProp(strRealTableName As String) _\n                                             As String\n\n'Module (c) 2005 Wayne Phillips (http://www.everythingaccess.com)\n'Written 18/04/2005\n\n'If an error occurs here, just ignore (user will override the blank name)\nOn Error Resume Next\n\n    Dim i As Long\n    Dim strNameMap As String\n\n    'Try to extract the name from the AutoCorrect data if it's available...\n\n    strNameMap = CurrentDb.TableDefs(strRealTableName).Properties(\"NameMap\")\n    strNameMap = Mid(strNameMap, 23) 'Offset of the table name...\n\n    'Find the null terminator...\n    i = 1\n    If Len(strNameMap) > 0 Then\n\n        While (i < Len(strNameMap)) And (Asc(Mid(strNameMap, i)) <> 0)\n\n            i = i + 1\n\n        Wend\n\n    End If\n\n    FnGetDeletedTableNameByProp = Left(strNameMap, i - 1)\n\nEnd Function\n"}
