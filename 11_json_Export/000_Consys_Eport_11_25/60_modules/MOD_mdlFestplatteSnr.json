{"id":"MOD_mdlFestplatteSnr","name":"mdlFestplatteSnr","kind":"standard","procedures":["Function VolSerialNoTest()","Function VolSerialNoErm(Optional lpRootPathName As String = \"C:\\\", Optional Deci As Boolean = False)"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\n' Dialog aus einer Newsgroup:\n\n'Wenn wir aber von \"Otto Normalanwender\" reden, so gibt es neben der\n'Verschlüsselung und Paßwortabfrage noch eine weitere Variante, die den\n'Datenklau zumindest ganz erheblich erschwert:\n'\n'Wie man die Benutzung der Shift-Taste beim Start und damit die\n'Umgehung des Autoexec-Makros verhindern kann, ist ja sicherlich\n'mittlerweile hinreichend bekannt. (Siehe mdlProperties)\n'Ich frage dann beim Aufstarten von Access auf die Seriennummer der\n'Festplatte ab.\n'Mit anderen Worten:\n'Selbst wenn ein ungetreuer Mitarbeiter die Datenbank nebst System.mdw\n'und  Paßwort weitergibt, würde das Programm auf einem anderen Rechner\n'nicht laufen.\n'Ich habe bisher allerdings noch nicht rausbekommen, wie man auf die\n'Seriennummer des Prozessors abfragen kann. Das wäre eine zusätzlich\n'Sicherheit.\n'Wer dazu die entsprechenden API-Aufrufe kennt, sollte sie hier doch\n'einmal in die Newsgroup stellen, sofern er mag.\n'\n'Juergen\n'\n'Nachstehend der Code für die Festplattennummer\n'Autor: unbekannt\n'Vor längerer Zeit einmal in einer englischen Access-Newsgroup gefunden\n'\n\nPrivate Declare PtrSafe Function GetVolumeInformation Lib \"kernel32\" Alias _\n\"GetVolumeInformationA\" (ByVal lpRootPathName As String, ByVal _\nlpVolumeNameBuffer As String, ByVal nVolumeNameSize As Long, _\nlpVolumeSerialNumber As Long, lpMaximumComponentLenght As Long, _\nlpFileSystemFlags As Long, ByVal lpFileSystemNameBuffer As String, _\nByVal nFileSystemNameSize As Long) As Long\n\n' Wie kann ich feststellen, in welchen Format die Festplatte ist (NTFS, FAT, FAT32)\n'\n'In lpFileSystemNameBuffer kriegst du das Gesuchte zurück. Nicht vergessen:\n'diesen Parameter ebenso wie VolumeNameBuffer vorher mit Speicherplatz\n'versorgen (lpFileSystemNameBuffer = Space$(x)).\n\n\nFunction VolSerialNoTest()\n' Testet, ob die Seriennummer mit der fest einprogrammierten Seriennummer\n' übereinstimmt\n\nDim lpRootPathName As String\nDim IngRet As Long\nDim lpVolumeNameBuffer As String\nDim nVolumeNameSize As Long\nDim lpVolumeSerialNumber As Long\nDim lpMaximumComponentLenght As Long\nDim lpFileSystemFlags As Long\nDim lpFileSystemNameBuffer As String\nDim nFileSystemNameSize As Long\nDim answer As Integer\n\nlpVolumeNameBuffer = Space$(254)\nlpFileSystemNameBuffer = Space$(254)\nnVolumeNameSize = 254\nnFileSystemNameSize = 254\n\nlpRootPathName = \"C:\\\"\nIngRet = GetVolumeInformation(lpRootPathName, lpVolumeNameBuffer, _\nnVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLenght, _\nlpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize)\n\nRem für 11111 ist die Seriennummer einzusetzen\n\nIf IngRet <> 0 Then\n   If lpVolumeSerialNumber <> 11111 Then\n       answer = MsgBox(\"Sie haben keine Berechtigung dieses Programm \" & _\n\"auf diesem Computer auszuführen.\", vbExclamation, \"Hinweis !\")\n       DoCmd.Quit\n   End If\nEnd If\n\nEnd Function\n\n\nFunction VolSerialNoErm(Optional lpRootPathName As String = \"C:\\\", Optional Deci As Boolean = False)\n\n' Seriennummer eines Laufwerks ermitteln\n' Laufwerk übergeben. Wenn Deci = False, dann wird ein Hex-Wert mit\n' Bindestrich in der Mitte z.B.: \"2AB1-1234\" zurückgegeben\n' Bei Deci = True wird der Dezimalwert zurückgegeben.\n' LpRootPathName ist der Laufwerksbuchstabe z.B. \"C:\\\"\n' 21.02.1998 Ober\n\nDim IngRet As Long\nDim lpVolumeNameBuffer As String\nDim nVolumeNameSize As Long\nDim lpVolumeSerialNumber As Long\nDim lpMaximumComponentLenght As Long\nDim lpFileSystemFlags As Long\nDim lpFileSystemNameBuffer As String\nDim nFileSystemNameSize As Long\nDim answer As Integer\nDim tmp1 As String\n\nlpVolumeNameBuffer = Space$(254)\nlpFileSystemNameBuffer = Space$(254)\n\nnVolumeNameSize = 254\nnFileSystemNameSize = 254\n\nIngRet = GetVolumeInformation(lpRootPathName, lpVolumeNameBuffer, _\nnVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLenght, _\nlpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize)\n\nIf Deci Then\n    VolSerialNoErm = lpVolumeSerialNumber\nElse\n   tmp1 = Right(\"00000000\" & Hex(lpVolumeSerialNumber), 8)\n   VolSerialNoErm = Left(tmp1, 4) & \"-\" & Right(tmp1, 4)\nEnd If\n\nEnd Function\n"}
