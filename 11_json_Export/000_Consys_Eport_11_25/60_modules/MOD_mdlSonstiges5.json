{"id":"MOD_mdlSonstiges5","name":"mdlSonstiges5","kind":"standard","procedures":["Function TextFileLesen(strFile As String, tblArray As Variant)","Function TextFileSchreibenArr(strFile As String, tblArray As Variant)","Function TextFileSchreiben(strFile As String, strSQL As String)","Function create_subfolder_from_Recordset(strPath As String, strSQL As String) As Boolean","Function rstDcount(fld As String, ByVal rsrc As String, Optional strwh As String = \"\") As Variant","Function rstDMax(fld As String, ByVal rsrc As String, Optional strwh As String = \"\") As Variant","Function rstDMin(fld As String, ByVal rsrc As String, Optional strwh As String = \"\") As Variant","Function rstDLookUp(fld As String, ByVal rsrc As String, Optional strwh As String = \"\") As Variant","Function rdTst()","Function txt2bin(xstr As String) As String","Function bin2txt(xstr As String, xdelim As String) As String","Function tst_bin2txt()","Function fCnvQM(ByVal strString As String) As String","Public Function fcnGetKorrType() As Boolean"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":["DLookUp(fld As String, ByVal rsrc As String, Optional strwh As String = \"\")"],"DCount":["Dcount(fld As String, ByVal rsrc As String, Optional strwh As String = \"\")"],"DMax":["DMax(fld As String, ByVal rsrc As String, Optional strwh As String = \"\")"],"DMin":["DMin(fld As String, ByVal rsrc As String, Optional strwh As String = \"\")"]},"source":"Option Compare Database\nOption Explicit\n\n\nFunction TextFileLesen(strFile As String, tblArray As Variant)\n\nDim intFile As Integer\n'Dim strFile As String\nDim strIn As String\nDim i As Long\n  \n  i = 0\n  ReDim tblArray(0)\n  intFile = FreeFile()\n  'strFile = \"C:\\Folder\\MyData.txt\"\n  Open strFile For Input As #intFile\n  Do While Not EOF(intFile)\n    ReDim Preserve tblArray(i)\n    Line Input #intFile, strIn\n    tblArray(i) = strIn\n    i = i + 1\n  Loop\n\n  Close #intFile\nEnd Function\n\nFunction TextFileSchreibenArr(strFile As String, tblArray As Variant)\n\n\nDim ArrFill_DAO_OK1 As Boolean, recsetSQL1 As String, iZLMax1 As Long, iColMax1 As Long, DAOARRAY1, iZl As Long, iCol As Long\n\n\nDim intFile As Integer\n'Dim strFile As String\nDim strIn As String\nDim i As Long\n\nintFile = FreeFile()\nOpen strFile For Output As #intFile\n\niZLMax1 = UBound(tblArray)\n\nFor iZl = 0 To iZLMax1\n\n      Print #intFile, CStr(tblArray(iZl))\n'          Print #intFile, \"\"\n\nNext iZl\n\nClose #intFile\n  \nEnd Function\n\nFunction TextFileSchreiben(strFile As String, strSQL As String)\n\n\nDim ArrFill_DAO_OK1 As Boolean, recsetSQL1 As String, iZLMax1 As Long, iColMax1 As Long, DAOARRAY1, iZl As Long, iCol As Long\n\n\nDim intFile As Integer\n'Dim strFile As String\nDim strIn As String\nDim i As Long\n\nintFile = FreeFile()\nOpen strFile For Output As #intFile\n\nrecsetSQL1 = strSQL\nArrFill_DAO_OK1 = ArrFill_DAO_Acc(recsetSQL1, iZLMax1, iColMax1, DAOARRAY1)\n'Info:   'AccessArray(iSpalte,iZeile) <0, 0>\nIf ArrFill_DAO_OK1 Then\n    For iZl = 0 To iZLMax1\n\n          Print #intFile, CStr(DAOARRAY1(0, iZl))\n'          Print #intFile, \"\"\n\n    Next iZl\n    Set DAOARRAY1 = Nothing\nEnd If\n\nClose #intFile\n  \nEnd Function\n\n\n\n\nFunction create_subfolder_from_Recordset(strPath As String, strSQL As String) As Boolean\n'Idee: Um (hauptsächlich für Bilder) ein eigenes Subdirectory pro ArtikelNr automatisch zu generieren\n' strPath = Pfad des Hauptdirectories, (Beispiel: \"C:\\Kunden\\Kloy\\Artikel\\Images\") Darunter werden die Directories angelegt\n' strSQL ist ein Recordset wobei die erste Spalte als Namensgeber für das Subdir fungiert\n\nDim ArrFill_DAO_OK1 As Boolean, recsetSQL1 As String, iZLMax1 As Long, iColMax1 As Long, DAOARRAY1, iZl As Long, iCol As Long\nDim pfnam As String\n\nIf Len(Trim(Nz(strSQL))) = 0 Then\n    Exit Function\nEnd If\n\nIf Not Path_erzeugen(strPath, False, True) Then\n    Exit Function\nEnd If\n\nIf Right(strPath, 1) <> \"\\\" Then\n    strPath = strPath & \"\\\"\nEnd If\n\nrecsetSQL1 = strSQL\nArrFill_DAO_OK1 = ArrFill_DAO_Acc(recsetSQL1, iZLMax1, iColMax1, DAOARRAY1)\n'Info:   'AccessArray(iSpalte,iZeile) <0, 0>\nIf ArrFill_DAO_OK1 Then\n    For iZl = 0 To iZLMax1\n        pfnam = DAOARRAY1(0, iZl)\n        MkDir strPath & pfnam\n    Next iZl\n    Set DAOARRAY1 = Nothing\nEnd If\n\nMsgBox \"Alle SubDirs erzeugt\"\n\nEnd Function\n\n\n'Public Function GetWordConstants()\n'' need to add Reference library TypeLib information\n'\n'    Dim theLibrary As TypeLibInfo\n'    Dim theLibraryPath\n'    theLibraryPath = \"C:\\Program Files (x86)\\Microsoft Office\\Office15\\Excel.exe\"\n''    theLibraryPath = \"C:\\Program Files (x86)\\Microsoft Office\\Office15\\MSWord.olb\"\n''    theLibraryPath = \"C:\\Program Files (x86)\\Microsoft Office\\Office15\\MSAcc.olb\"\n''    theLibraryPath = \"C:\\Program Files (x86)\\Microsoft Office\\Office15\\MSOutl.olb\"\n''    theLibraryPath = \"C:\\Program Files (x86)\\Microsoft Office\\Office15\\MSPPT.olb\"\n''    theLibraryPath = \"C:\\Program Files (x86)\\Common Files\\DESIGNER\\MSADDNDR.OLB\"\n''    theLibraryPath = \"C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\VBA\\VBA6\\VBE6EXT.OLB\"\n''    theLibraryPath = \"C:\\Windows\\SysWow64\\VEN2232.OLB\"\n''    theLibraryPath = \"C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\vsavb7.olb\"\n'' Get information from the Object library\n'    Set theLibrary = TypeLibInfoFromFile(theLibraryPath)\n'' Open file for output.\n'    Open \"C:\\Test\\DiversConstants.txt\" For Output As #1\n'\n'    Dim theRecord, theMember\n'    For Each theRecord In theLibrary.Constants\n'        For Each theMember In theRecord.Members\n'            '            Print #1, \"Private const \" & theMember.Name & \" = \" & theMember.Value\n''            Print #1, theMember.Name\n'            Print #1, Chr$(34) & theMember.Name & Chr$(34) & \";\" & theMember.Value & \";\" & Chr$(34) & \"Private const \" & theMember.Name & \" = \" & theMember.Value & Chr$(34) & \";\" & Chr$(34) & theRecord.Name & Chr$(34) & \";\" & Chr$(34) & UCase(Left(theMember.Name, 2)) & Chr$(34) & \";\" & Chr$(34) & \"Off2013\" & Chr$(34)\n'        Next theMember\n'    Next theRecord\n'    Set theLibrary = Nothing\n'    Close #1\n'End Function\n'\n\n\n''''Call getzerodatasummary(\"c:\\summary.txt\")\n''''Add Reference Microsoft DAO 3.6 Library or Microsoft Office xx.0 Access database engine Object Library\n'''\n''''If I understand the code correctly, that VBA code creates a document, giving ONE percentage for each table,\n''''saying how much of the NUMERIC fields are = 0\n''''The variable ithr contains the number of records of each table, but is not used here.\n''''Interesting for BI calculations of a cube (Filling mode).\n'''\n'''Sub getzerodatasummary(filename As String)\n'''Dim dbs As dao.Database, fldObj As dao.Field, rs As dao.Recordset\n'''Dim I As Integer, tablename As String, N As Integer, M As Integer, jthf As Integer, ithr As Long, fieldname As String\n'''Dim Total As Double, zeros As Double, percentage As Double\n'''On Error GoTo Error_Handler\n'''Set dbs = CurrentDb\n'''N = dbs.TableDefs.Count\n'''If (N > 0) Then\n'''    Open filename For Output As #1\n'''    For I = 0 To N - 1\n'''        tablename = dbs.TableDefs(I).Name\n'''        If (InStr(tablename, \"MSys\") <> 1) Then\n'''            Set rs = dbs.OpenRecordset(\"SELECT * FROM [\" & tablename & \"];\", dbOpenDynaset)\n'''            Total = 0\n'''            zeros = 0\n'''            If Not rs.EOF Then\n'''                With rs\n'''                    M = rs.Fields.Count\n'''                    .MoveFirst\n'''                    ithr = 0\n'''                    Do Until .EOF\n'''                        ithr = ithr + 1\n'''                        For jthf = 0 To M - 1\n'''                            ft = .Fields(jthf).Type\n'''                            If (ft = dbInteger Or ft = dbLong Or ft = dbCurrency Or ft = dbDecimal Or ft = dbDouble Or ft = dbFloat) Then\n'''                                Total = Total + 1\n'''                                If (.Fields(jthf).Value = 0) Then zeros = zeros + 1\n'''                            End If\n'''                        Next\n'''                        .MoveNext\n'''                    Loop\n'''                End With\n'''            End If\n'''            percentage = zeros / Total\n'''            Print #1, tablename & \" \" & percentage\n'''        End If\n'''    Next I\n'''    Close #1\n'''End If\n'''dbs.Close\n'''Set dbs = Nothing\n'''Set rs = Nothing\n'''Exit Sub\n'''Error_Handler:\n'''MsgBox err.Number & \":\" & err.Description\n'''End Sub\n \n\n\nFunction rstDcount(fld As String, ByVal rsrc As String, Optional strwh As String = \"\") As Variant\n\nDim db As DAO.Database\nDim rst As DAO.Recordset\nDim i As Long\nDim strSQL As String\n\nOn Error Resume Next\n\nrstDcount = \"\"\n\nIf Len(Trim(Nz(rsrc))) = 0 Or Len(Trim(Nz(fld))) = 0 Then Exit Function\n\nrsrc = Trim(rsrc)\nIf Right(rsrc, 1) = \";\" Then\n    rsrc = Left(rsrc, Len(rsrc) - 1)\nEnd If\n\nIf Len(Trim(Nz(strwh))) > 0 Then\n    strSQL = \"SELECT count(\" & fld & \") FROM (\" & rsrc & \") WHERE \" & strwh & \";\"\nElse\n    strSQL = \"SELECT count(\" & fld & \") FROM (\" & rsrc & \");\"\nEnd If\n\nSet db = CurrentDb\nSet rst = db.OpenRecordset(strSQL, dbOpenSnapshot)\nIf rst.EOF Then\n    rstDcount = 0\nElse\n    rstDcount = Nz(rst.fields(0), 0)\nEnd If\nrst.Close\nSet rst = Nothing\nSet db = Nothing\nEnd Function\n\nFunction rstDMax(fld As String, ByVal rsrc As String, Optional strwh As String = \"\") As Variant\n\nDim db As DAO.Database\nDim rst As DAO.Recordset\nDim i As Long\nDim strSQL As String\n\nOn Error Resume Next\n\nrstDMax = \"\"\n\nIf Len(Trim(Nz(rsrc))) = 0 Or Len(Trim(Nz(fld))) = 0 Or fld = \"*\" Then Exit Function\n\nrsrc = Trim(rsrc)\nIf Right(rsrc, 1) = \";\" Then\n    rsrc = Left(rsrc, Len(rsrc) - 1)\nEnd If\n\nIf Len(Trim(Nz(strwh))) > 0 Then\n    strSQL = \"SELECT max(\" & fld & \") FROM (\" & rsrc & \") WHERE \" & strwh & \";\"\nElse\n    strSQL = \"SELECT max(\" & fld & \") FROM (\" & rsrc & \");\"\nEnd If\n\nSet db = CurrentDb\nSet rst = db.OpenRecordset(strSQL, dbOpenSnapshot)\nIf rst.EOF Then\n    rstDMax = \"\"\nElse\n    rstDMax = Nz(rst.fields(0))\nEnd If\nrst.Close\nSet rst = Nothing\nSet db = Nothing\nEnd Function\n\nFunction rstDMin(fld As String, ByVal rsrc As String, Optional strwh As String = \"\") As Variant\n\nDim db As DAO.Database\nDim rst As DAO.Recordset\nDim i As Long\nDim strSQL As String\n\nOn Error Resume Next\n\nrstDMin = \"\"\n\nIf Len(Trim(Nz(rsrc))) = 0 Or Len(Trim(Nz(fld))) = 0 Or fld = \"*\" Then Exit Function\n\nrsrc = Trim(rsrc)\nIf Right(rsrc, 1) = \";\" Then\n    rsrc = Left(rsrc, Len(rsrc) - 1)\nEnd If\n\nIf Len(Trim(Nz(strwh))) > 0 Then\n    strSQL = \"SELECT Min(\" & fld & \") FROM (\" & rsrc & \") WHERE \" & strwh & \";\"\nElse\n    strSQL = \"SELECT Min(\" & fld & \") FROM (\" & rsrc & \");\"\nEnd If\n\nSet db = CurrentDb\nSet rst = db.OpenRecordset(strSQL, dbOpenSnapshot)\nIf rst.EOF Then\n    rstDMin = \"\"\nElse\n    rstDMin = Nz(rst.fields(0))\nEnd If\nrst.Close\nSet rst = Nothing\nSet db = Nothing\nEnd Function\n\n\n\nFunction rstDLookUp(fld As String, ByVal rsrc As String, Optional strwh As String = \"\") As Variant\n\nDim db As DAO.Database\nDim rst As DAO.Recordset\nDim i As Long\nDim strSQL As String\n\nOn Error Resume Next\n\nrstDLookUp = \"\"\n\nIf Len(Trim(Nz(rsrc))) = 0 Or Len(Trim(Nz(fld))) = 0 Or fld = \"*\" Then Exit Function\n\nrsrc = Trim(rsrc)\nIf Right(rsrc, 1) = \";\" Then\n    rsrc = Left(rsrc, Len(rsrc) - 1)\nEnd If\n\nIf Len(Trim(Nz(strwh))) > 0 Then\n    strSQL = \"SELECT TOP 1 \" & fld & \" FROM (\" & rsrc & \" WHERE \" & strwh & \");\"\nElse\n    strSQL = \"SELECT TOP 1 \" & fld & \" FROM (\" & rsrc & \");\"\nEnd If\n\nSet db = CurrentDb\nSet rst = db.OpenRecordset(strSQL, dbOpenSnapshot)\nIf rst.EOF Then\n    rstDLookUp = \"\"\nElse\n    rstDLookUp = Nz(rst.fields(0))\nEnd If\nrst.Close\nSet rst = Nothing\nSet db = Nothing\nEnd Function\n\n\n\nFunction rdTst()\nDim myArray As Variant\nDim i As Long\n\nCall TextFileLesen(\"C:\\Kunden\\erioTec (Kirchner - Siemens)\\20140402_SVN\\xxx.txt\", myArray)\n\nFor i = 0 To 2\n    Debug.Print myArray(i)\nNext i\nEnd Function\n\nFunction txt2bin(xstr As String) As String\nDim i As Long\nDim xs As Long\n\ntxt2bin = \"\"\nxstr = Trim(Nz(xstr))\nFor i = 1 To Len(xstr)\n    xs = Asc(Mid(xstr, i, 1))\n    txt2bin = txt2bin & Right(Long2Bin(xs), 8) & \" \"\nNext i\ntxt2bin = Trim(txt2bin)\nEnd Function\n\nFunction bin2txt(xstr As String, xdelim As String) As String\n\nDim TestArray() As String, AnzWd\nDim i As Long\n\nbin2txt = \"\"\nAnzWd = ExtractWords(xstr, TestArray(), xdelim, False)\nFor i = LBound(TestArray) To UBound(TestArray)\n    bin2txt = bin2txt & Chr$(Bin2Long(TestArray(i)))\n'    Debug.Print \"   String \" & i & \" : \" & TestArray(i)\nNext i\n\nEnd Function\n\nFunction tst_bin2txt()\n' 01100100 01100001 01110100 01100001 00100000 01101001 01110011 00100000 01100011 01101111 01101111 01101100\nDim xstr As String\nDim xdel As String\nxstr = \"01100100 01100001 01110100 01100001 00100000 01101001 01110011 00100000 01100011 01101111 01101111 01101100\"\nDebug.Print xstr\nxdel = \" \"\ntst_bin2txt = bin2txt(xstr, xdel)\nDebug.Print txt2bin(CStr(tst_bin2txt))\nEnd Function\n\n\nFunction fCnvQM(ByVal strString As String) As String\n    'Funktion, die Hochkommata - Chr(39) - innerhalb eines Strings verdoppelt,\n    'um Strings, die Hochkommata beinhalten an SQL-Syntax übergeben zu können\n\n    Dim i As Integer\n    Dim strStringNew As String\n\n    For i = 1 To Len(strString)\n        If Mid(strString, i, 1) = Chr(39) Then\n            strStringNew = strStringNew & Chr(39) & Chr(39)\n        Else\n            strStringNew = strStringNew & Mid(strString, i, 1)\n        End If\n    Next i\n\n    'Return Value\n    fCnvQM = strStringNew\nEnd Function\n\n\n'Korrekturtyp(Euro, Stunden, Beides)\nPublic Function fcnGetKorrType() As Boolean\n\n    fcnGetKorrType = Get_Priv_Property(\"prp_Korr_Stunden\")\n    \nEnd Function"}
