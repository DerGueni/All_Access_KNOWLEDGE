{"id":"MOD_mdlSonstiges4","name":"mdlSonstiges4","kind":"standard","procedures":["Function ArrFill_DAO_Acc(ByVal recsetSQL As String, ByRef iZLMax As Long, ByRef iColMax As Long, ByRef DAOARRAY) As Boolean","Function ArrFill_DAO(ByVal recsetSQL As String, ByRef iZLMax As Long, ByRef iColMax As Long, ByRef DAOARRAY, Optional ByRef DAOARRAY_Name, Optional AsExcel As Boolean = False) As Boolean","Function ArrFill_Transform2d(InArray, OutArray, bToExcel As Boolean, iZLMaxOut As Long, iColMaxOut As Long) As Boolean","Function Fill_Tbl(ByVal recsetSQL As String, ByRef DAOARRAY As Variant) As Boolean","Function ArrFill_DAO_Redim(ByVal recSetVgl As String, ByRef iZLMax As Long, ByRef iColMax As Long, ByRef DAOARRAY)","Function ArrTestFill()","Public Sub CompactDB()","Function vbnl() As String","Function ReSizeAllControls(strFormName As String, Optional dblresize As Double = 1, Optional strFontName As String = \"Arial\", Optional iFontsize As Long = 10)","Public Function GetRefs()","Function RefOtherDB(strDatabase As String)","Function SetAllowBypassKey(strDatabase As String, _","Function SetAllowByPassKeyADP(Optional onoff As Boolean = False)","Function translateNATO(strMsg As String)","Function CreateQuery(strSQL As String, Optional queryName As String = \"qrySorting\") As Boolean","Function CreateQueryPathThru(strConnServer As String, strConnDB As String, strConnTyp As String, strSQL As String, strAbfragename As String, Optional ReturnsRecords As Boolean = True, Optional IsExecute As Boolean = False) As Boolean","Function CreateQueryPathThruConnStr(strConnString As String, strSQL As String, strAbfragename As String, Optional ReturnsRecords As Boolean = True, Optional IsExecute As Boolean = False) As Boolean","Public Function c()","Public Function A2XGetQryType(psQry As String, Optional pdbs As DAO.Database) As String","Public Function IsTableDataOpen(psTable As String) As Boolean","Public Function GetA2XWorkgroupFile() As String","Public Sub A2XCompiled()","Public Function A2XGetCtlType(pctl As control) As String","Public Function chgbrightness(ByVal ccolor As Long, ByVal hell As Long) As Long","Function minl(ByVal X As Long, ByVal Y As Long) As Long","Function maxl(ByVal X As Long, ByVal Y As Long) As Long","Function Treeview_Stufe_neu_setzen(Optional ByVal tabname As String = \"tblTreeView\", Optional ByVal ndxStufe As Long = 3, Optional ByVal ndxID = 0, Optional ByVal ndxVater = 10)","Private Function Init_Stufe_Tree_Rek(ByVal DAOARRAY1, ByVal iZLMax1, ByVal ID As Long, ByVal Stufe As Long, Optional ByVal ndxStufe As Long = 3, Optional ByVal ndxID = 0, Optional ByVal ndxVater = 10) As Long","Function NamConv(strnam As String, VN As Long, Optional sKom As String = \",\")","Function ExcelTransferspreadsheet(strDateiname As String, strTabname As String, iWahlLinkImport As Long, _","Function fstrTeilen(ByVal xin As String, Optional leftright As Long = 1, Optional Dummy As Variant) As String","Function Acc_ruecksetz()","Function DirTest(strDir As String) As Boolean","Public Function DelTreeVB(ByVal path As String) As Boolean","Function DateinameTest(datname As String, Optional backslaskOK As Boolean = False)","Function ChgColLabelName_general(frmName As String)","Public Function ChgSaSoCondition(frm As Form, iMon As Variant, iJahr As Variant, Optional dwidth As Variant = 1.5)","Function OpenPasswordProtectedDB(strDbName As String, strPwd As String)"],"calls":{"DoCmd.OpenForm":["frmPersonal"],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\n' Funktionen (bzw.Subs) in diesem Modul:\n'#######################################\n'SysBeep                    Beep Beep Beep\n'ArrFill_DAO_Acc            Erstellt ein Array aus einer Abfrage oder einer Tabelle oder einem SELECT String - nur Access\n'ArrFill_DAO                Erstellt ein Array aus einer Abfrage oder einer Tabelle oder einem SELECT String - Excel oder Access - zusätzlich Feldnamen\n'ArrFill_DAO_Redim          Vergrößert ein Array aus einer Abfrage oder einer Tabelle oder einem SELECT String\n'ArrFill_Transform2d        Transformiert ein 2D Array von/nach 0 0 von/nach 1 1 Spalte / Zeile\n'ArrTestFill                Test dazu\n'Fill_Tbl                   Array in Tabelle schreiben\n'CompactDB                  Compact\n'ReSizeAllControls          Alle Controls resizen\n'GetRefs                    Alle Referenzen\n'SetAllowBypassKey          ByPass Key Allowance in fremder MDB setzen - DAO\n'SetAllowByPassKeyADP       ByPass Key Allowance in fremder MDB setzen - ADP\n'translateNATO              Wort in Nato-Alphabet übersetzen\n'CreateQuery                Erzeugen einer Abfrage aus einem SQLString\n'CreateQueryPathThru        Erzeugen einer Path-Trough Abfrage aus einem SQLString\n'addXLSModule               Von Access aus in Excel ein Modul einfügen\n'getUmrechnungskurs         Einen Umrechnungskurs von http://www.ecb.europa.eu/ holen\n'getUmrechnungskursAlle     Alle Umrechnungskurse von http://www.ecb.europa.eu/ holen\n'getUmrechnungskursCopy     Alle Umrechnungskurse kopieren\n'A2XGetQryType              Ermittelt den Abfragetypen\n'IsTableDataOpen            Ist Datentabelle offen\n'GetA2XWorkgroupFile        Ermittelt den Pfad und den Namen der Workgroup-Datei\n'A2XCompiled                Ist mdb Compiled ?\n'A2XGetCtlType              Ermittelt den Type eines Controls\n'chgbrightness              Ändert die Helligkeit der übergebenen Farbe\n'minl                       Gibt den Kleineren von 2 Werten zurück\n'maxl                       Gibt den Größeren von 2 Werten zurück\n'Treeview_Stufe_neu_setzen  Treeview Hilfsfunktion: Errechnet automatisch die Stufentiefe aus der ID und der VaterID\n'NamConv                    konvertiert einen String \"NACHNAME, VORNAME\" nach \"Nachname\" bzw \"Vorname\"\n'ExcelTransferspreadsheet   Transferspreadsheet mit zusätzlichem ID-Autowert Feld beim Import\n'ChgColLabelName_general    Changing label names to \"lbl_\" & Caption (useful for Datasheet forms)\n'OpenPasswordProtectedDB    OpenPasswordProtectedDB\n'ConvertLinkedTable2Intern  ConvertLinkedTable2Intern\n\n\n'Heinz-Josef Bomanns, Redaktionsbuero\n'> ich möchte die Tonwahltöne einer Telefonnummer über den Lautsprecher\n'> ausgeben lassen. Tipps dazu ?\n\nDeclare PtrSafe Function SysBeep Lib \"kernel32\" Alias \"Beep\" _\n                (ByVal dwFrequency As Long, _\n                 ByVal dwDuration As Long) As Long\n\n'Aufruf z.B. \"SysBeep 800, 250\"\n\n'Die passenden Frequenzen und Längen musste Dir aber selbst rausfieseln\n\n'   ***** Code Start *****\n'Compact Current Database            Author Juan M. Afan de Ribera\n \n'For Access 2000 and Access 2002. Here is a snippet of code for compacting the\n'current database. It uses the accDoDefaultAction method, that performs the\n'specified Object 's default action, and can be run from a command button on a form.\n'\n'accDoDefaultAction is a method of the hidden IAccessible Class in Office library.\n'\n\nFunction ArrFill_DAO_Acc(ByVal recsetSQL As String, ByRef iZLMax As Long, ByRef iColMax As Long, ByRef DAOARRAY) As Boolean\n\nDim db As DAO.Database\nDim rst As DAO.Recordset\nDim i As Long\n\n'Dim ArrFill_DAO_OK1 As Boolean, recsetSQL1 As String, iZLMax1 As Long, iColMax1 As Long, DAOARRAY1, iZl as long, iCol as long\n'recsetSQL1 = \"\"\n'ArrFill_DAO_OK1 = ArrFill_DAO_Acc(recsetSQL1,iZLMax1,iColMax1,DAOARRAY1)\n''Info:   'AccessArray(iSpalte,iZeile) <0, 0>\n'If ArrFill_DAO_OK1 Then\n'    For iZl = 0 To iZLMax1\n'\n'\n'\n'    Next iZl\n'    Set DAOARRAY1 = Nothing\n'End If\n\n\nArrFill_DAO_Acc = False\n\n    Set db = CurrentDb\n    Set rst = db.OpenRecordset(recsetSQL, dbOpenSnapshot, dbSeeChanges)\n    If rst.RecordCount <> 0 Then\n        rst.MoveLast\n        i = rst.RecordCount\n        rst.MoveFirst\n        DAOARRAY = rst.GetRows(i)\n\n    'Achtung Zeile und Spalte 0-basiert\n    'RowArray(iFldNr,iRecNr)\n    'RowArray(iSpalte,iZeile)\n        iZLMax = UBound(DAOARRAY, 2)\n        iColMax = UBound(DAOARRAY, 1)\n        ArrFill_DAO_Acc = True\n    End If\n    rst.Close\n    Set rst = Nothing\n\nEnd Function\n\n'Neue Version\n\nFunction ArrFill_DAO(ByVal recsetSQL As String, ByRef iZLMax As Long, ByRef iColMax As Long, ByRef DAOARRAY, Optional ByRef DAOARRAY_Name, Optional AsExcel As Boolean = False) As Boolean\n'Zusatztabelle mit Feldnamen (Zeile 0) und Feldtypen als Long (Zeile 1) und als Text (Zeile 2)\n            \nDim db As DAO.Database\nDim rst As DAO.Recordset\nDim i As Long\nDim j As Long\n\n'Dim ArrFill_DAO_OK1 As Boolean, recsetSQL1 As String, iZLMax1 As Long, iColMax1 As Long, DAOARRAY1, DAOARRAY_Name1, iZl as long, iCol as long\n'recsetSQL1 = \"\"\n'ArrFill_DAO_OK1 = ArrFill_DAO(recsetSQL1,iZLMax1,iColMax1,DAOARRAY1,DAOARRAY_Name1)\n''Info:   'AccessArray(iSpalte,iZeile) <0, 0>       'ExcelArray(iZeile, iSpalte) <1, 1>\n'If ArrFill_DAO_OK1 Then\n'    For iZl = 0 To iZLMax1\n'\n'\n'\n'    Next iZl\n'    Set DAOARRAY1 = Nothing\n'End If\n            \nDim NumArray\nDim NumtxtArray\n\nDim tmpArry\nDim iLbound As Long\nDim iCol As Long\n\nNumArray = Array(dbBigInt, dbBinary, dbBoolean, dbByte, dbChar, dbCurrency, dbDate, dbDecimal, dbDouble, dbFloat, dbGUID, dbInteger, dbLong, dbLongBinary, dbMemo, dbNumeric, dbSingle, dbText, dbTime, dbTimeStamp, dbVarBinary)\nNumtxtArray = Array(\"dbBigInt\", \"dbBinary\", \"dbBoolean\", \"dbByte\", \"dbChar\", \"dbCurrency\", \"dbDate\", \"dbDecimal\", \"dbDouble\", \"dbFloat\", \"dbGUID\", \"dbInteger\", \"dbLong\", \"dbLongBinary\", \"dbMemo\", \"dbNumeric\", \"dbSingle\", \"dbText\", \"dbTime\", \"dbTimeStamp\", \"dbVarBinary\")\n                       \nArrFill_DAO = False\n\n    Set db = CurrentDb\n    Set rst = db.OpenRecordset(recsetSQL, dbOpenSnapshot, dbSeeChanges)\n    If rst.RecordCount <> 0 Then\n        rst.MoveLast\n        i = rst.RecordCount\n        rst.MoveFirst\n        \n        If AsExcel = True Then\n          tmpArry = rst.GetRows(i)\n          iLbound = 1\n          Call ArrFill_Transform2d(tmpArry, DAOARRAY, True, iZLMax, iColMax)\n          Erase tmpArry\n          Set tmpArry = Nothing\n          ArrFill_DAO = True\n        Else\n          DAOARRAY = rst.GetRows(i)\n          iLbound = 0\n          iZLMax = UBound(DAOARRAY, 2)\n          iColMax = UBound(DAOARRAY, 1)\n          ArrFill_DAO = True\n        End If\n\n    'Function ArrFill_DAO(ByVal recsetSQL As String, ByRef iZLMax As Long, ByRef iColMax As Long, ByRef DAOARRAY) As Boolean\n    \n    'Achtung Zeile und Spalte 0-basiert\n    'RowArray(iFldNr,iRecNr)\n    'AccessArray(iSpalte,iZeile) <0, 0>\n    'ExcelArray(iZeile, iSpalte) <1, 1>\n    \n     'Zusatztabelle mit Feldnamen (Zeile 0) und Feldtypen als Long (Zeile 1) und als Text (Zeile 2)\n      If Not IsMissing(DAOARRAY_Name) Then\n            \n        If AsExcel = True Then\n          'ExcelArray(iZeile, iSpalte) <1, 1>\n          ReDim DAOARRAY_Name(iLbound To 2 + iLbound, iLbound To iColMax)\n        \n          For iCol = iLbound To iColMax\n            DAOARRAY_Name(iLbound, iCol) = rst.fields(iCol - iLbound).Name\n            DAOARRAY_Name(iLbound + 1, iCol) = rst.fields(iCol - iLbound).Type\n            For j = 0 To UBound(NumArray)\n              If NumArray(j) = rst.fields(iCol - iLbound).Type Then\n                DAOARRAY_Name(iLbound + 2, iCol) = NumtxtArray(j)\n                Exit For\n              End If\n            Next j\n          Next iCol\n        \n        Else\n          'AccessArray(iSpalte, iZeile) <0, 0>\n          ReDim DAOARRAY_Name(iLbound To iColMax, iLbound To 2 + iLbound)\n        \n          For iCol = iLbound To iColMax\n            DAOARRAY_Name(iCol, iLbound) = rst.fields(iCol).Name\n            DAOARRAY_Name(iCol, iLbound + 1) = rst.fields(iCol).Type\n            For j = 0 To UBound(NumArray)\n              If NumArray(j) = rst.fields(iCol).Type Then\n                DAOARRAY_Name(iCol, iLbound + 2) = NumtxtArray(j)\n                Exit For\n              End If\n            Next j\n          Next iCol\n        \n        End If\n      End If\n    \n    End If\n    rst.Close\n    Set rst = Nothing\n\nEnd Function\n\n\n\nFunction ArrFill_Transform2d(InArray, OutArray, bToExcel As Boolean, iZLMaxOut As Long, iColMaxOut As Long) As Boolean\n'bToExcel = True -- von Access nach Excel\n'bToExcel = False -- von Excel nach Access\n\n'Access-Arrays:\n    'Achtung Zeile und Spalte 0-basiert\n    'AccessArray(iFldNr, iRecNr)\n    'AccessArray(iSpalte, iZeile) <0, 0>\n\n'Excel-Arrays:\n    'Achtung Zeile und Spalte 1-basiert\n    'ExcelArray(iRecNr, iFldNr)\n    'ExcelArray(iZeile, iSpalte) <1, 1>\n\n\n'Dim ArrFill_Transform2d_OK1 As Boolean, InArray1, OutArray1, iZLMaxOut1, iColMaxOut1, iZl as long, iCol as long\n'ArrFill_Transform2d_OK1 = ArrFill_Transform2d(InArray1,OutArray1,True, iZLMaxOut1,iColMaxOut1)\n''Info:   'AccessArray(iSpalte,iZeile) <0, 0>       'ExcelArray(iZeile, iSpalte) <1, 1>\n\nDim i As Long, ii As Long, j As Long\nDim IZlIn As Long\nDim IColIn As Long\nDim IZl2In As Long\nDim ICol2In As Long\n\nOn Error GoTo Fehl\n\nArrFill_Transform2d = True\n\nIf bToExcel = True Then\n    ii = 1  ' Ziel Array Excel: 1 größer\nElse\n    ii = -1 ' Ziel Array Access: 1 kleiner\nEnd If\n\nIf bToExcel = False Then ' Von Excel Nach Access\n    'OutArray(iSpalte, iZeile)\n    \n    IColIn = LBound(InArray, 2)\n    ICol2In = UBound(InArray, 2)\n    IZlIn = LBound(InArray, 1)\n    IZl2In = UBound(InArray, 1)\n    \n    ReDim OutArray(IColIn + ii To ICol2In + ii, IZlIn + ii To IZl2In + ii)\n\n    For i = IZlIn To IZl2In\n        For j = IColIn To ICol2In\n            OutArray(j + ii, i + ii) = InArray(i, j)\n        Next j\n    Next i\n\nElse ' Von Access Nach Excel\n    'OutArray(iZeile, iSpalte)\n    \n    IColIn = LBound(InArray, 1)\n    ICol2In = UBound(InArray, 1)\n    IZlIn = LBound(InArray, 2)\n    IZl2In = UBound(InArray, 2)\n    \n    ReDim OutArray(IZlIn + ii To IZl2In + ii, IColIn + ii To ICol2In + ii)\n\n    For i = IZlIn To IZl2In\n        For j = IColIn To ICol2In\n            OutArray(i + ii, j + ii) = InArray(j, i)\n        Next j\n    Next i\nEnd If\n\niZLMaxOut = IZl2In + ii\niColMaxOut = ICol2In + ii\n\nExit Function\n\nFehl:\n\nArrFill_Transform2d = False\n\nMsgBox \"Error - something went wrong\"\n\nEnd Function\n\n\nFunction Fill_Tbl(ByVal recsetSQL As String, ByRef DAOARRAY As Variant) As Boolean\n\n'Dim Fill_Tbl_OK1 As Boolean, trecsetSQL1 As String, InArray1\n'Fill_Tbl_OK1 = Fill_Tbl((recsetSQL1,InArray1)\n''Info:   'AccessArray(iSpalte,iZeile) <0, 0>       'ExcelArray(iZeile, iSpalte) <1, 1>\n\nDim iZl As Long\nDim iCol As Long\n\nDim i As Long\nDim j As Long\nDim k As Long\n\n    'AccessArray(iSpalte,iZeile) <0, 0>\n    'ExcelArray(iZeile, iSpalte) <1, 1>\n\nDim db As DAO.Database\nDim rst As DAO.Recordset\n\n\n '  On Error GoTo Fill_Tbl_Error\n\nk = LBound(DAOARRAY, 1)\n\nIf k = 0 Then 'Access\n  iCol = UBound(DAOARRAY, 1)\n  iZl = UBound(DAOARRAY, 2)\nElse  'Excel\n  iCol = UBound(DAOARRAY, 2)\n  iZl = UBound(DAOARRAY, 1)\nEnd If\n\nSet db = CurrentDb\n    Set rst = db.OpenRecordset(recsetSQL, , dbSeeChanges)\n\nWith rst\n    For i = k To iZl\n        .AddNew\n            For j = k To iCol\n              On Error Resume Next\n              If k = 0 Then\n                .fields(j) = Nz(DAOARRAY(j, i))\n              Else\n                .fields(j - k) = Nz(DAOARRAY(i, j))\n              End If\n              On Error GoTo 0\n            Next j\nOn Error Resume Next\n        .update\nOn Error GoTo 0\n    Next i\n    .Close\nEnd With\n\nSet rst = Nothing\n\n   On Error GoTo 0\n   \n   Fill_Tbl = True\n   Exit Function\n\nFill_Tbl_Error:\n\nFill_Tbl = False\n  MsgBox \"Error \" & err.Number & \" (\" & err.description & \") in procedure Fill_Tbl of Module mdlSonstiges4\"\n\nEnd Function\n\n\nFunction ArrFill_DAO_Redim(ByVal recSetVgl As String, ByRef iZLMax As Long, ByRef iColMax As Long, ByRef DAOARRAY)\n'iZLMax = Input: Anzahl der Erhöhung der Zeilen, Rückgabe MaxZeilen gesamt, iColMax = Input Max anz Spalten neu\n\nDim TmpArr\nDim iZl1 As Long\nDim iCol1 As Long\nDim k As Long\nDim L As Long\n\n    Call ArrFill_DAO(recSetVgl, iZl1, iCol1, TmpArr)\n\n    ReDim Preserve DAOARRAY(iColMax, iZLMax + iZl1 + 1)\n    For k = 0 To iZl1\n        For L = 0 To iCol1\n            DAOARRAY(L, iZLMax + 1 + k) = TmpArr(L, k)\n        Next L\n    Next k\n    \n    iZLMax = iZLMax + iZl1 + 1\n    \n    Set TmpArr = Nothing\n            \nEnd Function\n\nFunction ArrTestFill()\nDim i As Long\nDim j As Long\nDim AsExcel As Boolean\n\nDim ArrFill_DAO_OK1 As Boolean, recsetSQL1 As String, iZLMax1 As Long, iColMax1 As Long, DAOARRAY1, DAOARRAY_Name1, iZl As Long, iCol As Long\n'ArrFill_DAO_OK1 = ArrFill_DAO(recsetSQL1,iZLMax1,iColMax1,DAOARRAY1,DAOARRAY_Name1, False)\n''Info: DAOARRAY1(iSpalte,iZeile)  <0, 0>\n\nDim sqlstr1 As String\n\nrecsetSQL1 = \"SELECT * FROM tblSpeisenAusgaben;\"\n\nAsExcel = True\nArrFill_DAO_OK1 = ArrFill_DAO(recsetSQL1, iZLMax1, iColMax1, DAOARRAY1, DAOARRAY_Name1, AsExcel)\n\nIf Not AsExcel Then\n    'AccessArray(iSpalte, iZeile) <0, 0>\n  Debug.Print \"AusgDatum = \" & DAOARRAY1(3, 0)\n  Debug.Print \"Bier = \" & DAOARRAY_Name1(3, 0)\n  Debug.Print \"Bier = \" & DAOARRAY_Name1(3, 1)\n  Debug.Print \"Bier = \" & DAOARRAY_Name1(3, 2)\nElse\n      'ExcelArray(iZeile, iSpalte) <1, 1>\n  Debug.Print \"AusgDatum = \" & DAOARRAY1(1, 4)\n  Debug.Print \"Bier = \" & DAOARRAY_Name1(1, 4)\n  Debug.Print \"Bier = \" & DAOARRAY_Name1(2, 4)\n  Debug.Print \"Bier = \" & DAOARRAY_Name1(3, 4)\nEnd If\n\nDim Fill_Tbl_OK1 As Boolean, trecsetSQL1 As String, iFirstCol As Long, InArray1\n\nCurrentDb.Execute (\"DELETE * FROM tblSpeisenAusgaben_Test;\")\n\ntrecsetSQL1 = \"SELECT * FROM tblSpeisenAusgaben_Test;\"\niFirstCol = 1\n\nFill_Tbl_OK1 = Fill_Tbl(trecsetSQL1, DAOARRAY1)\n''Info:   'AccessArray(iSpalte,iZeile) <0, 0>       'ExcelArray(iZeile, iSpalte) <1, 1>\n\n\n'Stop\nEnd Function\n\n\n\nPublic Sub CompactDB()\n\n   CommandBars(\"Menu Bar\"). _\n   controls(\"Tools\"). _\n   controls(\"Database utilities\"). _\n   controls(\"Compact and repair database...\"). _\n   accDoDefaultAction\n\nEnd Sub\n'   ***** Code End  *****\n\n\nFunction vbnl() As String\nvbnl = vbNewLine\nEnd Function\n\n\nFunction ReSizeAllControls(strFormName As String, Optional dblresize As Double = 1, Optional strFontName As String = \"Arial\", Optional iFontsize As Long = 10)\n\n'Konstante Steuerelement\n'#######################\n'acBoundObjectFrame Gebundenes Objektfeld\n'acCheckBox Kontrollkästchen\n'acComboBox Kombinationsfeld *\n'acListBox Listenfeld *\n'acCommandButton Befehlsschaltfläche *\n'acCustomControl ActiveX - Steuerelement\n'acImage Bild\n'acLabel Bezeichnungsfeld *\n'acLine Linie\n'acObjectFrame ungebundenes Objektfeld oder Diagramm\n'acOptionButton Optionsschaltfläche\n'acOptionGroup Optionsgruppe\n'acPage Page\n'acPageBreak Seitenwechsel\n'acRectangle Rechteck\n'acSubform Unterformular / -bericht\n'acTabCtl Registersteuerelement *\n'acTextBox Textfeld *\n'acToggleButton Umschaltfläche *\n\n'If C.ControlType = acComboBox Or _\n'   C.ControlType = acListBox Or _\n'   C.ControlType = acCommandButton Or _\n'   C.ControlType = acLabel Or _\n'   C.ControlType = acTextBox Or _\n'   C.ControlType = acTabCtl Or _\n'   C.ControlType = acToggleButton _\n'     Then\n\nDim i As Integer, Anz As Integer\nDim bOne As Boolean\nDim c As control\n\nbOne = False\n\nDoCmd.OpenForm strFormName, acDesign\nAnz = Forms(strFormName).controls.Count ' liefert die Anzahl Steuerelemente im Formular\nIf Anz <= 0 Then Exit Function ' keine Steuerelemente da\nFor i = 0 To Anz - 1\n    Set c = Forms(strFormName).controls(i)\n'    Debug.Print C.ControlType, C.Name\n    \n    If c.ControlType = acComboBox Or _\n       c.ControlType = acListBox Or _\n       c.ControlType = acCommandButton Or _\n       c.ControlType = acLabel Or _\n       c.ControlType = acTextBox Or _\n       c.ControlType = acTabCtl Or _\n       c.ControlType = acToggleButton _\n         Then\n    \n        c.FontName = strFontName\n        c.FontSize = iFontsize\n    \n'         C.Value = \"\" ' Inhalt löschen\n    End If\nNext i\n    \n' Ein Register muss zuerst gesetzt werden\nFor i = 0 To Anz - 1\n    Set c = Forms(strFormName).controls(i)\n    If c.ControlType = 123 Then ' Register\n        c.Top = c.Top * dblresize\n        c.Left = c.Left * dblresize\n        c.height = c.height * dblresize\n        c.width = c.width * dblresize\n    End If\nNext i\n    \nFor i = 0 To Anz - 1\n    Set c = Forms(strFormName).controls(i)\n    \n    If Not (c.ControlType = 124 Or c.ControlType = 123) Then  ' TabRegisterKarte (124) eines Registers (123)\n            \n        c.Top = c.Top * dblresize\n        c.Left = c.Left * dblresize\n        c.height = c.height * dblresize\n        c.width = c.width * dblresize\n    End If\n                \nNext i\n\nDoCmd.Close acForm, strFormName, acSaveYes\n\nDoCmd.OpenForm strFormName\n\nEnd Function\n\nPublic Function GetRefs()\n '====================================================================\n ' Name: GetRefs\n ' Purpose: Get a list of the current database references\n '\n ' Author:  Arvin Meyer\n ' Date: April 10, 1999\n ' Comment:\n '\n '====================================================================\nOn Error GoTo Err_GetRefs\nDim i As Integer\n\nFor i = 1 To Application.References.Count\n\n    Debug.Print Application.References(i).FullPath\n\nNext i\n\nExit_GetRefs:\n   Exit Function\n\nErr_GetRefs:\n\n   Debug.Print \"Missing Reference\"\n   Resume Next\n\nEnd Function\n\nFunction RefOtherDB(strDatabase As String)\n\n    Dim db As DAO.Database\n    Dim ws As Workspace\n    \n    Dim appAccess As Object\n    Set appAccess = CreateObject(\"Access.Application\")\n\n\n    On Error GoTo HandleErr\n    Set ws = appAccess.DBEngine.Workspaces(0)\n    Set db = ws.OpenDatabase(strDatabase)\n    \n'    Set db = DBEngine.Workspaces(0).OpenDatabase(Me.txtDBPfad)\n    \nDim i As Integer\n\nDebug.Print appAccess.References.Count\n\nFor i = 1 To appAccess.References.Count\n\n    Debug.Print appAccess.References(i).FullPath\n\nNext i\n\n\nExitHere:\n    Exit Function\n\nHandleErr:\n    GoTo ExitHere\n\nEnd Function\n\nFunction SetAllowBypassKey(strDatabase As String, _\n fSet As Boolean) As Boolean\n    ' Returns True if the property is set,\n    ' False on any error\n    ' Author: Mary Chipman\n\n    Dim db As DAO.Database\n    Dim ws As Workspace\n    Dim prop As Property\n    Const conPropNotFound = 3270\n\n\n    On Error GoTo HandleErr\n    Set ws = DBEngine.Workspaces(0)\n    Set db = ws.OpenDatabase(strDatabase)\n    db.Properties(\"AllowByPassKey\") = fSet\n    SetAllowBypassKey = True\n\n\nExitHere:\n    Exit Function\n\n\nHandleErr:\n    If err = conPropNotFound Then\n        ' If the property doesn't already exist,\n        ' you have to create it\n        Set prop = db.CreateProperty(\"AllowByPassKey\", _\n          dbBoolean, False)\n        db.Properties.append prop\n        Resume\n    Else\n        MsgBox err & \": \" & err.description, , \"Error in SetAllowBypassKey.\"\n        SetAllowBypassKey = False\n        GoTo ExitHere\n    End If\nEnd Function\n\nFunction SetAllowByPassKeyADP(Optional onoff As Boolean = False)\n    Dim prp As AccessObjectProperty\n    Const AllowByPassKey As String = \"AllowByPassKey\"\n\n    On Error Resume Next\n    Set prp = CurrentProject.Properties(AllowByPassKey)\n    If err.Number = 2455 Then\n         CurrentProject.Properties.Add AllowByPassKey, onoff\n    Else\n        prp.Value = onoff\n    End If\n    SetAllowByPassKeyADP = onoff\nEnd Function\n\n\nFunction translateNATO(strMsg As String)\nDim strWords()\nDim strOut As String\nDim i As Long\n    'strMsg = InputBox(\"Enter text:\")\n    \n    strWords = Array(\"Alpha\", \"Bravo\", \"Charlie\", \"Delta\", _\n                    \"Echo\", \"Foxtrot\", \"Golf\", \"Hotel\", _\n                    \"India\", \"Juliet\", \"Kilo\", \"Lima\", _\n                    \"Mike\", \"November\", \"Oscar\", \"Papa\", _\n                    \"Quebec\", \"Romeo\", \"Sierra\", \"Tango\", _\n                    \"Uniform\", \"Victor\", \"Whiskey\", \"Xray\", _\n                    \"Yankee\", \"Zulu\")\n                \n    If strMsg <> \"\" Then\n        For i = 1 To Len(strMsg)\n            If (Asc(LCase(Mid(strMsg, i, 1))) >= 97) And (Asc(LCase(Mid(strMsg, i, 1))) <= 122) Then\n                    strOut = strOut & \"-\" & strWords(Asc(LCase(Mid(strMsg, i, 1))) - 97)\n            Else\n                If IsNumeric(Mid(strMsg, i, 1)) Then\n                    strOut = strOut & \"-\" & Mid(strMsg, i, 1)\n                Else\n                    strOut = strOut & \"-\"\n                End If\n            End If\n        Next\n        MsgBox (strMsg & vbNewLine & \"---------------\" & vbNewLine & Mid(strOut, 2))\n    End If\n    translateNATO = Mid(strOut, 2)\nEnd Function\n\n\nFunction CreateQuery(strSQL As String, Optional queryName As String = \"qrySorting\") As Boolean\n\nDim dbs As DAO.Database\nDim qdf As DAO.QueryDef\n\n   On Error GoTo CreateQuery_Error\n\nSet dbs = CurrentDb\nIf ObjectExists(\"Query\", queryName) Then\n    DoCmd.DeleteObject acQuery, queryName\nEnd If\nSet qdf = dbs.CreateQueryDef(queryName, strSQL)\n\nDoEvents\n\n   CreateQuery = True\n   On Error GoTo 0\n   Exit Function\n\nCreateQuery_Error:\n\n'    MsgBox \"Error \" & Err.Number & \" (\" & Err.Description & \") in procedure CreateQuery of Modul DataFunctions\"\nCreateQuery = False\n\nEnd Function\n\nFunction CreateQueryPathThru(strConnServer As String, strConnDB As String, strConnTyp As String, strSQL As String, strAbfragename As String, Optional ReturnsRecords As Boolean = True, Optional IsExecute As Boolean = False) As Boolean\n\n'strConnServer = \"N2319021\"                    ' Servername\n'strConnServer = \"123.123.123.123,1234\"        ' IP und Port\n\n'strConnDB = \"Prj_Bio_Dim\"                     ' Datenbankname\n\n'strConnTyp = \"Trusted_Connection=Yes\"         ' integrated Windows Security\n'strConnTyp = \"Uid=myUsername;Pwd=myPasword\"   ' SQL Server User und Password\n\n    Dim db As DAO.Database\n    Dim qdfAbfrage As DAO.QueryDef\n\n    CreateQueryPathThru = False\n\n    On Error GoTo CreateQueryPathThru_Error\n\n\n   ' Eine Datenbank öffnen, aus der QueryDef-Objekte erstellt werden können.\n   ' Set db = OpenDatabase(\"DB1.mdb\")\n\n   Set db = CurrentDb\n\n'Exitstierende Abfrage löschen\nIf ObjectExists(\"Query\", strAbfragename) Then\n    DoCmd.DeleteObject acQuery, strAbfragename\nEnd If\n\n   ' Ein nicht temporäres QueryDef-Objekt erstellen, um\n   ' Daten von einer Microsoft SQL Server-Datenbank abzurufen.\nSet qdfAbfrage = db.CreateQueryDef(strAbfragename)\nWith qdfAbfrage\n\n'ODBC;DRIVER={SQL Server};SERVER=N2319021;DATABASE=Prj_Bio_Data;Trusted_Connection=Yes;\n'ODBC;DRIVER={SQL Server};SERVER=N2319021;DATABASE=Prj_Bio_Data;Uid=myUsername;Pwd=myPasword;\n\n      .connect = \"ODBC;DRIVER={SQL Server};SERVER=\" & strConnServer & \";DATABASE=\" & strConnDB & \";\" & strConnTyp & \";\"\n      .ReturnsRecords = ReturnsRecords\n\n\n'strSQL = \"SELECT * FROM Test;\"\n\n       .sql = strSQL\n       \n       If IsExecute Then\n           .Execute\n       End If\n\n       .Close\nEnd With\nDoEvents\nCreateQueryPathThru = True\nExit Function\n\nCreateQueryPathThru_Error:\n\nCreateQueryPathThru = False\nMsgBox \"Fehler #\" & CStr(err.Number) & \" von \"\"\" & err.Source & \"\"\": \" & err.description\nerr.clear\n\nEnd Function\n\n\nFunction CreateQueryPathThruConnStr(strConnString As String, strSQL As String, strAbfragename As String, Optional ReturnsRecords As Boolean = True, Optional IsExecute As Boolean = False) As Boolean\n\n    Dim db As DAO.Database\n    Dim qdfAbfrage As DAO.QueryDef\n\n    CreateQueryPathThruConnStr = False\n\n    On Error GoTo CreateQueryPathThru_Error\n\n\n   ' Eine Datenbank öffnen, aus der QueryDef-Objekte erstellt werden können.\n   ' Set db = OpenDatabase(\"DB1.mdb\")\n\n   Set db = CurrentDb\n\n'Exitstierende Abfrage löschen\nIf ObjectExists(\"Query\", strAbfragename) Then\n    DoCmd.DeleteObject acQuery, strAbfragename\nEnd If\n\n   ' Ein nicht temporäres QueryDef-Objekt erstellen, um\n   ' Daten von einer Microsoft SQL Server-Datenbank abzurufen.\nSet qdfAbfrage = db.CreateQueryDef(strAbfragename)\nWith qdfAbfrage\n\n      .connect = strConnString\n      .ReturnsRecords = ReturnsRecords\n      \n'strSQL = \"SELECT * FROM Test;\"\n\n       .sql = strSQL\n       If IsExecute Then\n           .Execute\n       End If\n       .Close\nEnd With\nDoEvents\n\n\nCreateQueryPathThruConnStr = True\nExit Function\n\nCreateQueryPathThru_Error:\n\nCreateQueryPathThruConnStr = False\nMsgBox \"CreateQueryPathThruConnStr - Fehler #\" & CStr(err.Number) & \" von \"\"\" & err.Source & \"\"\": \" & err.description\nerr.clear\n\nEnd Function\n\n\n''##############################################################\n'' Von Access aus in Excel ein Modul einfügen ...\n'' Henry Habermacher\n'\n''wenn 's ein bisschen hidden Functions sein dürfen geht's in etwa\n''folgendermassen:\n'\n'Public Function addXLSModule()\n'  Dim appXLS As New Excel.Application\n'  Dim wbk As Excel.Workbook\n'  Dim mdl As Excel.Module\n'  Set wbk = appXLS.Workbooks.Add\n'  appXLS.Visible = True\n'  wbk.Modules.Add\n'  wbk.Modules(1).Name = \"MyModule\"\n'  Set mdl = wbk.Sheets(\"MyModule\")\n'  mdl.InsertFile \"c:\\test.bas\"\n'  Stop\n'End Function\n\n'Das Modul, das Du einfügen willst, legst Du als c:\\test.bas ab und wenn Du\n'dann diese Funktion laufen lässt hat das Workbook ein Modul namens MyModule\n'mit dem Inhalt von c:\\test.bas. Option Explicit wird automatisch eingefügt\n'wenn so eingestellt, muss also nicht im test.bas drin stehen.\n'##############################################################\n\n\n'> Ich brauche eine Aggregatfunktion die Felder\n'> aus verschiedenen Datensätzen in einer Tabelle multipliziert.\n'>\n'> Also anstelle von\n'> SELECT SUM(Feld1) Group By AndresFeld FROM Tabelle\n'>\n'> Möchte Ich gerne\n'> SELECT Multiply(?)(Feld1) Group By AndresFeld FROM Tabelle\n'>\n'> Geht so etwas, und wenn ja wie?\n'\n'Ja, wenn man sich die Tatsache zu Nutze macht,\n'dass x*y = e^(ln x + ln y).\n'Also:\n'SELECT Exp(Sum(Log([EineZahl]))) AS Produkt\n'FROM tblZahlen;\n\n\n\n\n'Anwendungszweck\n'Normalerweise bindet man die Daten in Unterberichten an die des Hauptberichts, sodass der Unterbericht\n'beispielsweise die Projekte zu einem Kunden anzeigt. Manchmal geht dies allerdings nicht, weil die Daten\n'von Haupt- und Unterbericht nicht entsprechend verknüpft sind.\n'\n'Abfrage vorbereiten\n'Als Abfrage kann man eine x-beliebige Abfrage verwenden - hauptsache, sie ist unter dem gewünschten\n'Namen gespeichert und wird nicht für irgendeinen anderen Zweck benötigt. Stellen Sie dann die\n'Eigenschaft Datenherkunft des Unterberichts auf diese Abfrage ein.\n'\n'Datenherkunft Anpassen\n'Das Anpassen der Datenherkunft des Unterformulars findet dann in der Beim Öffnen-Ereignisprozedur\n'des Hauptberichts statt. Dort heißt es dann beispielsweise:\n'\n'Private Sub Report_Open(Cancel As Integer)\n'\n'    Dim db As DAO.Database\n'\n'    Dim strSQL As String\n'\n'    Set db = CurrentDb\n'\n'    strSQL = \"SELECT * FROM Artikel WHERE Artikelname LIKE 'C*'\"\n'\n'    db.QueryDefs(\"qryArtikelDummy\").sql = strSQL\n'\n'End Sub\n'\n'Am Unterberichts selbst ändert diese Routine gar nichts, sondern nur an der zugrunde\n'liegenden Abfrage: Der weist sie den neuen SQL-Ausdruck zu. Nach dem Öffnen zeigt der\n'Unterbericht schließlich die gewünschten Datensätze an.\n'\n'\n\n\nPublic Function c()\n '====================================================================\n ' Name:    GetRefs\n ' Purpose: Get a list of the current database references\n '\n ' Author:  Arvin Meyer\n ' Date:    April 10, 1999\n ' Comment:\n '\n '====================================================================\nOn Error GoTo Err_GetRefs\nDim i As Integer\n\nFor i = 1 To Application.References.Count\n\n    Debug.Print Application.References(i).FullPath\n\nNext i\n\nExit_GetRefs:\n    Exit Function\n\nErr_GetRefs:\n\n    Debug.Print \"Missing Reference\"\n    Resume Next\n\nEnd Function\n\n\n\nPublic Function A2XGetQryType(psQry As String, Optional pdbs As DAO.Database) As String\n  '// =====================================================\n  '// Methode   | Ermittelt den Abfragetypen\n  '// -----------------------------------------------------\n  '// Parameter | psQry - Name der Abfrage\n  '//             Optional  pdbs -Datenbankobjekt (CurrentDb)\n  '// -----------------------------------------------------\n  '// Rückgabe  | String - Bezeichnung des Abfragetyps\n  '// -----------------------------------------------------\n  '// Erstellt  | Manuela Kulpa\n  '//           | EDV Innovation & Consulting - Dormagen\n  '// -----------------------------------------------------\n  '// Beispielaufruf:\n  '// ?A2XGetQryType(CurrentDb,\"qryTest\")\n  '// =====================================================\n \n  Dim qdf As DAO.QueryDef\n  Dim sType As String\n \n  On Error GoTo A2XGetQryType_Error\n \n  If IsMissing(pdbs) Or (pdbs Is Nothing) Then\n    Set pdbs = CurrentDb\n  End If\n \n  Set qdf = pdbs.QueryDefs(psQry)\n \n  Select Case qdf.Type\n    Case dbQSelect: sType = \"Auswahlabfrage\"\n    Case dbQAction: sType = \"Aktionsabfrage\"\n    Case dbQCrosstab: sType = \"Kreuztabellenabfrage\"\n    Case dbQDelete: sType = \"Löschabfrage\"\n    Case dbQUpdate: sType = \"Aktualisierungsabfrage\"\n    Case dbQAppend: sType = \"Anfügeabfrage\"\n    Case dbQMakeTable: sType = \"Tabellenerstellungsabfrage\"\n    Case dbQDDL: sType = \"Datendefinitionsabfrage\"\n    Case dbQSQLPassThrough: sType = \"Pass-through-Abfrage\"\n    Case dbQSetOperation: sType = \"Unionabfrage\"\n  End Select\n \n  A2XGetQryType = sType\n \nA2XGetQryType_Exit:\n  On Error GoTo 0\n  Exit Function\n \nA2XGetQryType_Error:\n  Select Case err.Number\n    Case Else\n      MsgBox \"Fehler \" & err.Number & \": \" & _\n             err.description, vbCritical, _\n             \"modData.A2XGetQryType\"\n  End Select\n  Resume A2XGetQryType_Exit\n \nEnd Function\n\n\n' Sind Tabellen-Daten in Verwendung?\nPublic Function IsTableDataOpen(psTable As String) As Boolean\n  '// -----------------------------------------------------\n  '// Methode   | Überprüft, ob eine Tabelle bereits\n  '               irgendwo in Verwendung ist\n  '// -----------------------------------------------------\n  '// Parameter | psTable - Name der Tabelle, die überprüft\n  '                         werden soll\n  '// -----------------------------------------------------\n  '// Rückgabe  | Boolean - True = Tabelle wird verwendet\n  '// -----------------------------------------------------\n  '// Erstellt  | Manuela Kulpa\n  '//           | EDV Innovation & Consulting - Dormagen\n  '// -----------------------------------------------------\n  '// Beispielaufruf:\n  '   Public Sub TestFormularData()\n  '    If IsTableDataOpen(\"Personal\") = True Then\n  '      MsgBox \"Das Formular kann nicht geöffnet werden!\", _\n  '      vbInformation, \"Hinweis\"\n  '    Else\n  '      DoCmd.OpenForm \"frmPersonal\"\n  '    End If\n  '   End Sub\n  '// -----------------------------------------------------\n \n  Dim rst As DAO.Recordset\n \n  On Error Resume Next\n  '* Über die Option dbDenyWrite wird verhindert,\n  '  dass andere Benutzer Datensätze ändern oder\n  '  hinzufügen können\n  '* Die Option dbDenyRead verhindert, dass andere\n  '  Benutzer Daten in Tabellen lesen können\n  Set rst = CurrentDb.OpenRecordset(psTable, dbOpenDynaset, dbDenyWrite + dbDenyRead)\n  IsTableDataOpen = (err.Number <> 0)\n \nIsTableDataOpen_Exit:\n  On Error GoTo 0\n  If Not rst Is Nothing Then rst.Close: Set rst = Nothing\n  Exit Function\n \nEnd Function\n\n\nPublic Function GetA2XWorkgroupFile() As String\n  '// =====================================================\n  '// Methode   | Ermittelt den Pfad und den Namen der\n  '//           | Sicherheitsinformationsdatei\n  '// -----------------------------------------------------\n  '// Rückgabe  | String - s.o.\n  '// -----------------------------------------------------\n  '// Erstellt  | Manuela Kulpa\n  '//           | EDV Innovation & Consulting - Dormagen\n  '// =====================================================\n \n  GetA2XWorkgroupFile = Application.SysCmd( _\n                            acSysCmdGetWorkgroupFile)\n \nEnd Function\n\nPublic Sub A2XCompiled()\n  '// =====================================================\n  '// Methode   | Kompiliert das aktuelle Visual Basic\n  '//           | Projekt\n  '// -----------------------------------------------------\n  '// Hinweis   | undokumentierte SysCmd-Methode\n  '// -----------------------------------------------------\n  '// Erstellt  | Manuela Kulpa\n  '//           | EDV Innovation & Consulting - Dormagen\n  '// =====================================================\n \n  Call SysCmd(504, 16483)\n \nEnd Sub\n\n\nPublic Function A2XGetCtlType(pctl As control) As String\n \n  '// =====================================================\n  '// Methode   | Ermittelt den Type eines Controls\n  '// -----------------------------------------------------\n  '// Parameter | pctl - Control\n  '// -----------------------------------------------------\n  '// Rückgabe  | String - Controltyp\n  '// -----------------------------------------------------\n  '// Erstellt  | Manuela Kulpa\n  '//           | EDV Innovation & Consulting - Dormagen\n  '// -----------------------------------------------------\n  '// Beispielaufruf:\n  '// ?A2XGetCtlType(Me!txtData)\n  '// =====================================================\n  Dim sType As String\n \n  On Error GoTo A2XGetCtlType_Error\n \n  Select Case pctl.ControlType\n    Case acLabel\n      sType = \"Bezeichnungsfeld\"\n    Case acRectangle\n      sType = \"Rechteck\"\n    Case acLine\n      sType = \"Linie\"\n    Case acImage\n      sType = \"Bild\"\n    Case acCommandButton\n      sType = \"Befehlsschaltfläche\"\n    Case acOptionButton\n      sType = \"Optionsfeld\"\n    Case acCheckBox\n      sType = \"Kontrollkästchen\"\n    Case acOptionGroup\n      sType = \"Optionsgruppe\"\n    Case acBoundObjectFrame\n      sType = \"Gebundenes Objektfeld\"\n    Case acTextBox\n      sType = \"Textfeld\"\n    Case acListBox\n      sType = \"Listenfeld\"\n    Case acComboBox\n      sType = \"Kombinationsfeld\"\n    Case acSubform\n      sType = \"Unterformular / -bericht\"\n    Case acObjectFrame\n      sType = \"Objektfeld oder Diagramm\"\n    Case acPageBreak\n      sType = \"Seitenumbruch\"\n    Case 124\n      sType = \"Seite\"\n    Case 123\n      sType = \"Register\"\n    Case acCustomControl\n      sType = \"ActiveX-Control\"\n    Case acToggleButton\n      sType = \"Umschaltfläche\"\n  End Select\n \n  A2XGetCtlType = sType\n \nA2XGetCtlType_Exit:\n  On Error GoTo 0\n  Exit Function\n \nA2XGetCtlType_Error:\n  Select Case err.Number\n    Case Else\n      MsgBox \"Fehler \" & err.Number & \": \" & _\n             err.description, vbCritical, _\n             \"modFrm.A2XGetCtlType\"\n  End Select\n  Resume A2XGetCtlType_Exit\n \nEnd Function\n\n\n\nPublic Function chgbrightness(ByVal ccolor As Long, ByVal hell As Long) As Long\n'Ändert die Helligkeit der übergebenen Farbe, wobei der Farbton erhalten bleibt\n'Es wird also nie schwarz(RGB(000) bzw weiß RGB(255,255,255) erreicht\n'sondern stattdessen die ürsprüngliche Farbe zurückgeliefert\n\nDim c As Long\n\nDim red As Long\nDim green As Long\nDim blue As Long\n\n'Farbe in rgb aufteilen\nred = ccolor And 255\ngreen = ccolor \\ 256 And 255\nblue = ccolor \\ 256 ^ 2 And 255\n\n'Bereich 0-255 sicherstellen\nIf hell > 0 Then 'Heller machen aber nur bis eine Farbe 255 ist\n    c = maxl(red, maxl(green, blue))\n    hell = minl(hell, 255 - c)\nElseIf hell < 0 Then ' Dunkler macher aber nur bis eine Farbe 0 ist\n    c = minl(red, minl(green, blue))\n    hell = maxl(hell, -c)\nEnd If\n\nIf hell = 0 Then 'Nix ändern\n    chgbrightness = ccolor\nElse\n   'Helligkeit einzeln anpassen\n    red = red + hell\n    green = green + hell\n    blue = blue + hell\n\n    'RGB in Farbwert zurückverwandeln\n    chgbrightness = RGB(red, green, blue)\nEnd If\nEnd Function\n\nFunction minl(ByVal X As Long, ByVal Y As Long) As Long\n10 If X < Y Then\n20     minl = X\n30 Else\n40     minl = Y\n50 End If\nEnd Function\n\nFunction maxl(ByVal X As Long, ByVal Y As Long) As Long\n10 If X > Y Then\n20     maxl = X\n30 Else\n40     maxl = Y\n50 End If\nEnd Function\n\n\nFunction Treeview_Stufe_neu_setzen(Optional ByVal tabname As String = \"tblTreeView\", Optional ByVal ndxStufe As Long = 3, Optional ByVal ndxID = 0, Optional ByVal ndxVater = 10)\n\nDim i As Long\nDim j As Long\nDim k As Long\nDim iStf As Long\n\nDim ArrFill_DAO_OK1 As Boolean, recsetSQL1 As String, iZLMax1 As Long, iColMax1 As Long, DAOARRAY1, DAOARRAY_Name1, iZl As Long, iCol As Long\nrecsetSQL1 = tabname\nArrFill_DAO_OK1 = ArrFill_DAO_Acc(recsetSQL1, iZLMax1, iColMax1, DAOARRAY1)\n''Info:   'AccessArray(iSpalte,iZeile) <0, 0>       'ExcelArray(iZeile, iSpalte) <1, 1>\nIf ArrFill_DAO_OK1 Then\n    Debug.Print \"Anzahl: \" & iZLMax1\n    k = 0\n    For iZl = 0 To iZLMax1\n        i = DAOARRAY1(ndxID, iZl)\n        j = DAOARRAY1(ndxVater, iZl)\n        iStf = 0\n        If j = 0 Then\n            DAOARRAY1(ndxStufe, iZl) = iStf\n        Else\n            Do\n                iStf = iStf + 1\n                j = Init_Stufe_Tree_Rek(DAOARRAY1, iZLMax1, j, iStf, ndxStufe, ndxID, ndxVater)\n            Loop Until j = 0\n        End If\n        DAOARRAY1(ndxStufe, iZl) = iStf\n        DoEvents\n        k = k + 1\n        If k Mod 100 = 0 Then Debug.Print k\n    Next iZl\nEnd If\n\nCurrentDb.Execute (\"DELETE * FROM \" & tabname & \";\")\nDoEvents\nIf Fill_Tbl(tabname, DAOARRAY1) Then\n    MsgBox \"Stufe gefüllt\"\nElse\n    MsgBox \"Fehler\"\nEnd If\n\n\nEnd Function\n\nPrivate Function Init_Stufe_Tree_Rek(ByVal DAOARRAY1, ByVal iZLMax1, ByVal ID As Long, ByVal Stufe As Long, Optional ByVal ndxStufe As Long = 3, Optional ByVal ndxID = 0, Optional ByVal ndxVater = 10) As Long\nDim db As DAO.Database\nDim rstInTree As DAO.Recordset\nDim i As Long\nDim ifind As Long\n\nInit_Stufe_Tree_Rek = 0\nFor i = 0 To iZLMax1\n    If ID = CLng(DAOARRAY1(ndxID, i)) Then\n        Init_Stufe_Tree_Rek = CLng(DAOARRAY1(ndxVater, i))\n        Exit For\n    End If\nNext i\n\nEnd Function\n\n\n'\n'Function TreeVaterFill(Stufenr As Long, VaterNr As Long, IDNr As Long, SortNr As Long)\n'\n''Tabelle Treefill - für Treeview mit Vaterwerten füllen, wenn Stufe korrekt gefüllt ist\n''Erste Zeile muss als Startpunkt gefüllt sein ...\n'\n'Dim TreeZlMax As Long, TreeColMax As Long, TreeArray As Variant\n'\n'Dim HlpStufeVater(10) As Long\n'Dim iVglStufe As Long\n'Dim I As Long\n'Dim J As Long\n'Dim K As Long\n'\n'\n''    Call ArrFill_DAO(\"a0_00_ab4\", iDAOKFZZlMax, iDAOKFZColMax, DAOArrayKFZ)\n'    'Achtung Zeile und Spalte 0-basiert\n'    'RowArray(iFldNr,iRecNr)\n'    'RowArray(iSpalte,iZeile)\n'\n'For I = 0 To 10\n'    HlpStufeVater(I) = 0\n'Next I\n'\n'If ArrFill_DAO(\"SELECT * FROM tblTreefill;\", TreeZlMax, TreeColMax, TreeArray) Then\n'    ' Sich den ersten Vater merken (muss immer gefüllt sein)\n'    HlpStufeVater(TreeArray(Stufenr, 0)) = TreeArray(VaterNr, 0)\n'    HlpStufeVater(TreeArray(Stufenr, 0) + 1) = TreeArray(IDNr, 0)\n'    iVglStufe = TreeArray(Stufenr, 0)\n'    J = 0\n'    For I = 1 To TreeZlMax\n'        If TreeArray(Stufenr, I) <> iVglStufe Then\n'            J = 1\n'        Else\n'            J = J + 1\n'        End If\n'        If TreeArray(Stufenr, I) = iVglStufe + 1 Then\n'            HlpStufeVater(TreeArray(Stufenr, I)) = TreeArray(IDNr, I - 1)\n'            HlpStufeVater(TreeArray(Stufenr, I) + 1) = TreeArray(IDNr, I)\n'        Else\n'            HlpStufeVater(TreeArray(Stufenr, I) + 1) = TreeArray(IDNr, I)\n'        End If\n'        TreeArray(SortNr, I) = J\n'        TreeArray(VaterNr, I) = HlpStufeVater(TreeArray(Stufenr, I))\n'        iVglStufe = TreeArray(Stufenr, I)\n'    Next I\n'\n'    CurrentDb.Execute (\"DELETE * FROM tblTreefill;\")\n'    Call Fill_Tbl(\"SELECT * FROM tblTreefill;\", 1, TreeArray)\n'\n'End If\n'\n'End Function\n\n\nFunction NamConv(strnam As String, VN As Long, Optional sKom As String = \",\")\n'Funktion konvertiert einen String \"NACHNAME, VORNAME\" nach \"Nachname\" bzw \"Vorname\"\n'VN = 1 Nachname (vor dem Komma) VN <> 1 Vorname (nach dem Komma)\n\nDim X As String\nDim i As Long\n\nX = strnam\ni = InStr(1, X, sKom)\nIf i = 0 Then\n    NamConv = StrConv(X, 3)\n    Exit Function\nElse\n    If VN = 1 Then ' Nachname (Vor dem Komma)\n        X = Trim(Left(X, i - 1))\n    Else ' Vorname (nach dem Komma)\n        X = Trim(Mid(X, i + 1))\n    End If\n    X = StrConv(X, 3)\nEnd If\nNamConv = X\n\nEnd Function\n\n\nFunction ExcelTransferspreadsheet(strDateiname As String, strTabname As String, iWahlLinkImport As Long, _\n    Optional IstMitHeader As Boolean = True, Optional IstMitID As Boolean = True, Optional strFromTab As String = \"\", _\n    Optional StrFromCell As String = \"\", Optional StrToCell As String = \"\", Optional XLVersion As Long = 9) As Boolean\n    \n    Dim rng As String\n    Dim iRet As Long\n    \n    Dim strSQL As String\n    Dim strTabnameOrg As String\n    \n    On Error GoTo ExcelTransferspreadsheet_Error\n    \n    ExcelTransferspreadsheet = False\n    \n    If Len(Trim(Nz(strDateiname))) > 0 Then\n    \n    ' TabA!A1:B3\n            \n        rng = \"\"\n        If Len(Trim(Nz(strFromTab))) > 0 And Len(Trim(Nz(StrFromCell))) > 0 And Len(Trim(Nz(StrToCell))) > 0 Then\n            If Right(strFromTab, 1) <> \"!\" Then strFromTab = strFromTab & \"!\"\n            rng = strFromTab & StrFromCell & \":\" & StrToCell\n        Else\n            If Len(Trim(Nz(strFromTab))) > 0 Then\n                If Right(strFromTab, 1) <> \"!\" Then strFromTab = strFromTab & \"!\"\n                rng = strFromTab\n            Else\n                rng = \"\"\n            End If\n            If Len(Trim(Nz(StrFromCell))) > 0 Then\n                rng = rng & StrFromCell\n            End If\n            If Len(Trim(Nz(StrToCell))) > 0 And Len(Trim(Nz(StrFromCell))) > 0 Then\n                rng = rng & \":\" & StrToCell\n            ElseIf Len(Trim(Nz(StrToCell))) > 0 Then\n                rng = rng & \"A1:\" & StrToCell\n            End If\n        End If\n        \n        strTabnameOrg = strTabname\n        \n        If iWahlLinkImport = 0 Then\n            If table_exist(strTabname) Then\n                If vbOK = MsgBox(\"Tabelle existiert, überschreiben?\", vbQuestion + vbOKCancel, strTabname) Then\n                    DoCmd.DeleteObject acTable, strTabname\n                Else\n                    Exit Function\n                End If\n            End If\n            \n            If IstMitID = True Then\n                strTabname = strTabname & \"_Temp\"\n                If table_exist(strTabname) Then DoCmd.DeleteObject acTable, strTabname\n            End If\n            \n        End If\n        \n        If iWahlLinkImport = 1 Then\n            If File_exist(strDateiname) And Get_Priv_Property(\"prp_GL_XL_MehrfachTabs\") = 0 Then\n                iRet = MsgBox(\"Dateiname existiert, überschreiben?\", vbQuestion + vbYesNoCancel, strDateiname)\n                If iRet = vbYes Then\n                    Kill strDateiname\n                ElseIf iRet = vbCancel Then\n                    Exit Function\n                End If\n            End If\n        End If\n        \n        \n'Range:   TabA!A1:B3 ''- nur link und import\n'Range:   A1:A5\n'Range:   B5\n        \n' iWahlLinkImport 0 = Import\n' iWahlLinkImport 1 = Export\n' iWahlLinkImport 2 = Link\n\n'acSpreadsheetTypeExcel8        8   Microsoft Excel 97-Format        XLS\n'acSpreadsheetTypeExcel9        8   Microsoft Excel 2000-Format      XLS\n\n'acSpreadsheetTypeExcel12       9   Microsoft Excel 2010-Format      XLSX  - hier als Default verwendet\n'acSpreadsheetTypeExcel12XML    10  Microsoft Excel 2010-Format      XML\n\n'Ältere und andere Versionen\n'acSpreadsheetTypeLotusWJ2      4   Nur japanische Version\n'acSpreadsheetTypeLotusWK1      2   Lotus 1-2-3 WK1-Format\n'acSpreadsheetTypeLotusWK3      3   Lotus 1-2-3 WK3-Format\n'acSpreadsheetTypeLotusWK4      7   Lotus 1-2-3 WK4-Format\n'acSpreadsheetTypeExcel3        0   Microsoft Excel 3.0-Format\n'acSpreadsheetTypeExcel4        6   Microsoft Excel 4.0-Format\n'acSpreadsheetTypeExcel5        5   Microsoft Excel 5.0-Format\n'acSpreadsheetTypeExcel7        5   Microsoft Excel 95-Format\n\n\nDoCmd.TransferSpreadsheet iWahlLinkImport, XLVersion, strTabname, strDateiname, IstMitHeader, rng\n        \nCall Set_Priv_Property(\"prp_XL_tmpFileName_exp\", strDateiname)\n\n        If iWahlLinkImport = 0 And IstMitID = True Then\n            \n            strSQL = \"SELECT 0 as ID, * INTO \" & strTabnameOrg & \" From \" & strTabname & \" WHERE 0 = 1;\"\n            CurrentDb.Execute (strSQL)\n            \n            strSQL = \"ALTER TABLE \" & strTabnameOrg & \" ALTER COLUMN ID COUNTER PRIMARY KEY;\"\n            CurrentDb.Execute (strSQL)\n            \n            strSQL = \"INSERT INTO \" & strTabnameOrg & \" SELECT * FROM \" & strTabname & \";\"\n            CurrentDb.Execute (strSQL)\n            \n            DoCmd.DeleteObject acTable, strTabname\n            \n        End If\n        \n        ExcelTransferspreadsheet = True\n        \n    Else\n        MsgBox \"No filename selected !\", vbCritical + vbOKOnly, \"Cancel\"\n    End If\n\n    On Error GoTo 0\n    Exit Function\n\nExcelTransferspreadsheet_Error:\n\n    MsgBox \"Error \" & err.Number & \" (\" & err.description & \") in procedure ExcelTransferspreadsheet of Modul mdlSonstiges4\"\n\nEnd Function\n\nFunction fstrTeilen(ByVal xin As String, Optional leftright As Long = 1, Optional Dummy As Variant) As String\n\nDim i As Long\nDim strzw As String\n\nstrzw = xin\nIf leftright = 1 Then 'left\n    i = InStr(1, xin, \" \")\n    If i > 0 Then\n        strzw = Mid(xin, i + 1)\n    End If\nElse\n    i = InStr(1, xin, \" \")\n    If i > 1 Then\n        strzw = Left(xin, i - 1)\n    End If\nEnd If\n\nfstrTeilen = strzw\n\nEnd Function\n\n\n\nFunction Acc_ruecksetz()\n    On Error Resume Next\n\n    ' Access auf normal zurücksetzen\n    DoCmd.Hourglass False\n    Application.Echo True\n    DoCmd.SetWarnings True\n    Application.SetOption \"Built-In Toolbars Available\", True\n'    Me.Repaint\nEnd Function\n\n\nFunction DirTest(strDir As String) As Boolean\n\nDim strxx As String\n\nDirTest = False\nstrxx = \"\"\nOn Error Resume Next\nstrxx = Dir(strDir, 16)\n\nIf Len(strxx) > 0 Then\n    DirTest = True\nEnd If\n\nEnd Function\n\nPublic Function DelTreeVB(ByVal path As String) As Boolean\n' Löscht mit reinen Visual Basic-Methoden einen\n' Verzeichnisbaum (sofern möglich), indem rekursiv mit\n' Dir$, Kill und RmDir gearbeitet wird.\n' Kann der Baum nicht komplett gelöscht werden, wird als\n' Funktionsrückgabewert FALSE verwendet.\n' Hinweis: Die Dateien werden direkt gelöscht, nicht\n' lediglich in den Papierkorb verschoben (VB-Funktion Kill)!\nDim sName As String\n  ' Backslash-Zeichen notwendigenfalls anhängen\n  If Right$(path, 1) <> \"\\\" Then\n path = path & \"\\\"\n  End If\n  ' Ziel: Funktionsrückgabewert TRUE\n  DelTreeVB = True\n  On Error GoTo Error_DelTreeVB\n  ' Das erste Element in Path suchen\n  sName = Dir$(path & \"*.*\", vbHidden + vbDirectory)\n  ' Solange Elemente gefunden werden...\n  While Len(sName)\n ' Pseudo-Verzeichnisse \".\" und \"..\" ignorieren\n If (sName <> \".\") And (sName <> \"..\") Then\n   ' Untersuchen, ob die Fundstelle eine Datei\n   ' oder ein Verzeichnis ist:\n   If (GetAttr(path & sName) Or vbDirectory) = vbDirectory Then\n  ' Es handelt sich um ein Verzeichnis.\n  DelTreeVB = DelTreeVB(path & sName & \"\\\")\n  sName = Dir$(path & \"*.*\", vbHidden + vbDirectory)\n   Else\n  ' Es handelt sich um eine Datei\n  SetAttr path & sName, vbNormal ' Attribute zurücksetzen\n  Kill path & sName  ' Datei löschen\n  sName = Dir$()  ' nächste Datei suchen\n   End If\n Else\n   ' Bei \".\" oder \"..\" nächstes Element suchen\n   sName = Dir$()\n End If\n  Wend\n  ' Unterverzeichnis durchlaufen - keine Dateien oder\n  ' Unterverzeichnisse mehr vorhanden: Das Verzeichnis\n  ' selber kann nun geloescht werden.\n  RmDir path\nExit_DelTreeVB:\n  Exit Function\nError_DelTreeVB:\n  ' Funktiosrückgabewert FALSE\n  DelTreeVB = False\n  Resume Next\n'  ' Optional: Interaktion mit dem Anwender (Beispiel):\n'  Select Case MsgBox(Path & sName & vbNewLine _\n'   & \"konnte nicht gelöscht werden:\" _\n'   & vbNewLine & Err.Description, _\n'   vbAbortRetryIgnore + vbDefaultButton2, _\n'   \"Fehler beim Löschen\")\n' Case vbAbort:  Resume Exit_DelTreeVB\n' Case vbRetry:  Resume 0\n' Case vbIgnore: Resume Next\n'  End Select\nEnd Function\n\n\nFunction DateinameTest(datname As String, Optional backslaskOK As Boolean = False)\n\nDim tstname As String\nDim strChr As String\n\n'In Dateinamen verboten sind:\n'\\  092\n'/  047\n':  058\n'*  042\n'?  063\n'\"  034\n'<  060\n'>  062\n'|  124\n' und werden durch _ ersetzt\n' Leerzeichen wird ebenfalls durch _ ersetzt\n\nDim i As Long, j As Long\ntstname = \"\"\n\nj = Len(datname)\nFor i = 1 To j\n    strChr = Mid(datname, i, 1)\n\n    Select Case strChr\n        \n        Case \"/\", \":\", \"*\", \"?\", Chr$(34), \"<\", \">\", \"|\", \" \"\n           tstname = tstname & \"_\"\n        \n        Case \"\\\"\n            If backslaskOK Then\n                tstname = tstname & \"\\\"\n            Else\n                tstname = tstname & \"_\"\n            End If\n        \n        Case Else\n           tstname = tstname & strChr\n    \n    End Select\nNext i\n\nDateinameTest = tstname\n\nEnd Function\n\n\nFunction ChgColLabelName_general(frmName As String)\n'---------------------------------------------------------------------------------------\n' Procedure : ChgColLabelName_general\n' Author    : Klaus Oberdalhoff\n' Date      : 04.06.2011\n' Purpose   : On a freshly auto-generated form especially for Datasheet forms the label-names are Label1 to nnn\n'           : On Datasheet-Forms the Label-Caption generally is shown as the control-Name\n'           : To simplify the changing of the caption (for showing the control name)\n'           : this function names the labels to \"lbl_\" & caption (which is the control-name)\n'           : and fixes the bug to not stick all labels (the ones in the second row) to the control.\n'---------------------------------------------------------------------------------------\n'\n  Dim frm As Form\n  Dim ctl As control\n  Dim Ctl1 As control\n  Dim ctl1Name As String, ctlname As String\n  Dim XTop As Variant, XLeft As Variant\n  Dim XWidth As Variant, XHeight As Variant\n\n  DoCmd.OpenForm frmName, acDesign\n  Set frm = Forms(frmName)\n \n  For Each ctl In frm\n    If ctl.ControlType = acLabel Then\n        ctlname = ctl.Name\n        ctl1Name = ctl.caption\n        XTop = ctl.Top\n        XLeft = ctl.Left\n        XWidth = ctl.width\n        XHeight = ctl.height\n        DeleteControl frm.Name, ctl.Name\n        Set ctl = CreateControl(frm.Name, acLabel, , ctl1Name, , XLeft, XTop, XWidth, XHeight)\n        ctl.Name = \"lbl_\" & ctl1Name\n        ctl.caption = ctl1Name\n    End If\n  Next ctl\n   \n  DoCmd.Close acForm, frmName, acSaveYes\n  Set frm = Nothing\nEnd Function\n\n'#########################################################################################\n\nPublic Function ChgSaSoCondition(frm As Form, iMon As Variant, iJahr As Variant, Optional dwidth As Variant = 1.5)\n  'Autor Klaus Oberdalhoff\n  ' Bedingung: Form enthält 31 Felder: T01 bis T31 und 31 Labels lbl_T01 bis lbl_T31\n  '\n  ' Wenn eine Datatasheetform die Felder T01, T02  bis T31 sowie die passenden Labels lbl_T01, ... lbl_T31 enthält\n  ' wird die Überschrift auf \"01 Mo\", \"02 Di\" ... geändert sowie die Samstage und Sonntage per Conditional FOrmating rosa ringefärbt\n\n'  Dim frm As Form\n  Dim ctl As control\n\n  Dim i As Long\n  Dim j As Long\n  Dim k As Long\n  Dim L As Long\n  Dim dt1 As Date\n  Dim dt2 As Date\n  Dim dt3 As Date\n  Dim WkTag\n  Dim strTag As String\n  Dim fcd As FormatCondition\n  \n  WkTag = Array(, \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\", \"So\")\n \n  dt1 = DateSerial(iJahr, iMon, 1)\n  dt2 = DateSerial(iJahr, iMon + 1, 0)\n  j = Format(dt2, \"d\", 2, 2)\n \n \n  For i = 1 To 31\n    Set ctl = frm(\"T\" & Right(\"00\" & i, 2))\n\n    ctl.ColumnHidden = False\n    ctl.ColumnWidth = dwidth * 567\n    k = Weekday(DateSerial(iJahr, iMon, i), 2)\n    \n    With ctl.FormatConditions\n        .Delete\n    \n        If k = 6 Then ' Samstag\n           L = 15395583\n            'l = TLookup(\"FarbNrHint\", \"_tblFarben\", \"FarbID = 7\")\n            'bei acExpression wird der 2. Parameter ignoriert\n            'Dummy-Expression um die gesamte Spalte einzufärben\n            Set fcd = .Add(acExpression, acEqual, \"1 = 1\")\n            fcd.backColor = L\n        \n        ElseIf k = 7 Then ' Sonntag\n            L = 14145535\n    'l = TLookup(\"FarbNrHint\", \"_tblFarben\", \"FarbID = 8\")\n            'bei acExpression wird der 2. Parameter ignoriert\n            'Dummy-Expression um die gesamte Spalte einzufärben\n            Set fcd = .Add(acExpression, acEqual, \"1 = 1\")\n            fcd.backColor = L\n        End If\n    \n    End With\n    \n    If i > j Then ' Monat hat weniger als 31 Tage\n        ctl.ColumnHidden = True\n    End If\n'  Next i\n        \n'  For i = 1 To 31\n    'Set Header\n    '#####################################\n    \n    strTag = Right(\"00\" & i, 2)\n    Set ctl = frm(\"lbl_T\" & strTag)\n    strTag = strTag & \" \" & WkTag(Weekday(DateSerial(iJahr, iMon, i), 2))\n    ctl.caption = strTag\n        \n  Next i\n  \nEnd Function\n\n\nFunction OpenPasswordProtectedDB(strDbName As String, strPwd As String)\n'http://entwickler-forum.de/showthread.php?t=53956\n\nStatic acc As Access.Application\nDim db As DAO.Database\n'Dim strDbName As String\n\nstrPwd = \";PWD=\" & strPwd\n\n'strDbName = \"C:\\TEMP\\PDM\\xammunition.mdb\"\nSet acc = New Access.Application\nacc.Visible = True\nSet db = acc.DBEngine.OpenDatabase(strDbName, False, False, strPwd)\nacc.OpenCurrentDatabase strDbName\n'acc.DoCmd.RunMacro \"update PO MONITOR\" ' ein macro in der 2ten MDB\nSet db = Nothing\nEnd Function\n\n'##########################\n\n'' Ab Access 2010\n'Function ConvertLinkedTable2Intern(strTabelle As String)\n'\n'DoCmd.SelectObject acTable, strTabelle, True\n'RunCommand acCmdConvertLinkedTableToLocal\n'\n'End Function\n\n'###########################\n\n''' ## Parameterabfragen\n''' www.donkarl.com - access faq\n\n''Dim db As DAO.Database\n''Dim rs As DAO.Recordset\n''Dim qdf As DAO.QueryDef\n''\n''Set db = CurrentDb\n''Set qdf = db.QueryDefs(\"Meine_Parameter_Abfrage\")\n''qdf.Parameters!MeinParameter1 = \"Wert_für_Parameter1_in_Anführungszeichen_falls_er_ein_Text_ist\"\n''qdf.Parameters!MeinParameter2 = Wert_für_Parameter2\n'''usw.\n''\n''Set rs = qdf.OpenRecordset(dbOpenDynaset)\n'''hier folgt brillanter Code, der mit dem Recordset arbeitet\n'''\n'''am Ende so tun, als wär nix gewesen:\n''qdf.Close: Set qdf = Nothing\n''rs.Close: Set rs = Nothing\n''Set db = Nothing\n''\n''Falls du kein Recordset willst, sondern z.B. bloß eine Aktionsabfrage mit Parametern ausführen, sieht der Code ähnlich aus,\n''nur folgt nach dem Zuweisen der Parameter kein \"Set rs\" usw. sondern ein schlichtes:\n''qdf.Execute\n"}
