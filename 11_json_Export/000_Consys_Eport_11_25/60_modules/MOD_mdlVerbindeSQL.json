{"id":"MOD_mdlVerbindeSQL","name":"mdlVerbindeSQL","kind":"standard","procedures":["Function checkconnectSQL(Optional Verknuepfungstabelle As String = \"Acc_SQL_tblVerknuepfungstabellen\") As Boolean","Function DatenMDBWechselSQL(Optional Verknuepfungstabelle As String = \"Acc_SQL_tblVerknuepfungstabellen\") As Boolean","Public Function switchConnectSQL(Optional Verknuepfungstabelle As String = \"Acc_SQL_tblVerknuepfungstabellen\") As Boolean","Private Function ConnectDB(db As DAO.Database, datapath As String, Optional Verknuepfungstabelle As String = \"Acc_SQL_tblVerknuepfungstabellen\") As Integer","Private Function Verbinde(db As DAO.Database, ByVal ntab As String, ByVal mytab As String, ByVal Connectionstring As String) As Integer","Private Function frmClose(ByVal frmName As String)","Private Function frmOpen(ByVal frmName As String, ByVal Modus)","Private Function TabTempLosesch()","Function pk1()","Function pk2()"],"calls":{"DoCmd.OpenForm":["frmSQLServerLinkNames"],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":["CREATE UNIQUE INDEX PK1 ON qry_Projektkopf (pkoNummer)","CREATE UNIQUE INDEX PK2 ON qryPpoPpu (ppoID)"],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\nOption Base 0\n\nConst OFN_FILEMUSTEXIST = &H1000\nConst OFN_PATHMUSTEXIST = &H800\nConst OFN_HIDEREADONLY = &H4\nConst OFN_READONLY = &H1\nConst OFN_OVERWRITEPROMPT = &H2\n\nDim Servername As String\nDim Instancename As String\nDim SQLDatabasename As String\nDim SQLCheckTabelle As String\n\nDim Connectionstring As String\n\nDim tables As Variant\nDim MAXTABLES As Long\n\n' #############################################################\n'    Description\n' #############################################################\n\n'  Uses mdlPrivPropery                Module\n'       tblProperty Table\n\n'  \"prp_SQLCheckTabelle\"  Within tblProperty Table contains the name of the table which is checked\n'   If this (pre)checked table can be opened, then it is assumed that all connections are OK and no other connections are checked\n\n'     Acc_SQL_tblVerknuepfungstabellen  Table    - contains the names of the tables to be connected\n'       JN = False table will not be connected\n'       tblName = Destination-Name in frontend\n'       tblname_org = Source-name in backend\n'       Indexfkt = If Views are connected as table, you can specify an create Index SQL Command\n'                  like: \"CREATE UNIQUE INDEX PK1 ON qry_Projektkopf (pkoNummer)\"\n'                  which then is executed\n'       IDSort = the connection sequence\n'       Bemerkungen - just remarks\n'       SQLConnectionstring - Form \"_frmHlp_Connectionstring_erzeugen\" helps to create\n\n' Important functions:\n'   checkconnectSQL - Optional different (can be Query) name for Acc_SQL_tblVerknuepfungstabellen, when created via Query - as parameter - same structure\n'   DatenMDBWechselSQL  - \"\n\n' checkconnectSQL = called in Autoexec Macro\n' DatenMDBWechselSQL = Force reconnect (just deletes table-link from \"prp_SQLCheckTabelle\")\n\n' #############################################################\n\n\nFunction checkconnectSQL(Optional Verknuepfungstabelle As String = \"Acc_SQL_tblVerknuepfungstabellen\") As Boolean\n'Überprüft, ob die Datenbank verbunden sind\nDim db As DAO.Database\nDim tbl As DAO.Recordset\nDim nix\n\nDim SQLTrustedConn As String\nDim SQLUser As String\nDim SQLPasswd As String\ncheckconnectSQL = False\n\nOn Error GoTo checkconnectError\n\n' ODBC;Driver={SQL Server Native Client 10.0};\n' Statt\n' ODBC;Driver={SQL Server};\n'\n'DRIVER={SQL Server};SERVER=servername;DATABASE=datenbankname;UID=benutzername;PWD=kennwort\n'\n'ODBC;DRIVER={SQL Server};SERVER=190.190.200.100,1433;DATABASE=RegDB_Data;Trusted_Connection=Yes;\n'ODBC;DRIVER={SQL Server};SERVER=190.190.200.100,1433\\SQLInstanz;DATABASE=RegDB_Data;Trusted_Connection=Yes;\n'ODBC;DRIVER={SQL Server};SERVER=190.190.200.100,1433\\SQLInstanz;DATABASE=RegDB_Data;Trusted_Connection=No;UID=KobdTest;PWD=EinPw0rt;\"\n'\n''Die Parameter Uid und Pwd können bei der NT-Authentifizierung entfallen und müssen durch Trusted_Connection=Yes ersetzt werden\n\n'Connectionstring = \"ODBC;DRIVER={SQL Server};SERVER=\" & Servername & Instancename & \";DATABASE=\" & SQLDatabasename & \";Trusted_Connection=No;UID=KobdTest;PWD=EinPw0rt;\"\n\n'Trusted Connection\n'Connectionstring = \"ODBC;DRIVER={SQL Server};SERVER=\" & Servername & Instancename & \";DATABASE=\" & SQLDatabasename & \";Trusted_Connection=Yes\"\n'sa ohne passwort\n'Connectionstring = \"ODBC;DRIVER={SQL Server};SERVER=\" & Servername & Instancename & \";DATABASE=\" & SQLDatabasename & \";Trusted_Connection=No;UID=sa;PWD=;\"\n'User mit Passwort\n'Connectionstring = \"ODBC;DRIVER={SQL Server};SERVER=\" & Servername & Instancename & \";DATABASE=\" & SQLDatabasename & \";Trusted_Connection=No;UID=KobdTest;PWD=EinPw0rt;\"\n\n'Connectionstring = \"ODBC;DRIVER={SQL Server};SERVER=\" & Servername & Instancename & \";DATABASE=\" & SQLDatabasename & \";Trusted_Connection=\" & SQLTrustedConn & \";\"\n'Connectionstring = \"ODBC;Driver={SQL Server Native Client 10.0};SERVER=\" & Servername & Instancename & \";DATABASE=\" & SQLDatabasename & \";Trusted_Connection=\" & SQLTrustedConn & \";\"\n\n'Set db = DBEngine.Workspaces(0).Databases(0)\nSet db = CurrentDb\n\nSQLCheckTabelle = Get_Priv_Property(\"prp_SQLCheckTabelle\")\nIf Len(Trim(Nz(SQLCheckTabelle))) = 0 Then\n    MsgBox \"prp_SQLCheckTabelle nicht gefunden bzw leer\"\n    Exit Function\nEnd If\n\n' Hier einen existierenden Tabellennamen eingeben\n' Es wird davon ausgegangen, daß wenn diese Tabelle nicht korrekt connected ist,\n' die anderen Tabellen auch nicht korrekt connected sind.\n\nSet tbl = db.OpenRecordset(SQLCheckTabelle, dbOpenDynaset, dbSeeChanges)\nDoEvents\n'Call Set_Priv_Property(\"prp_AllIsOK\", -1)\n\ncheckconnectSQL = True\nExit Function\n\ncheckconnectError:\n    'Verbindung aufbauen\n    checkconnectSQL = switchConnectSQL(Verknuepfungstabelle)\n    Exit Function\n\nEnd Function\n\n'Connectionstring = \"ODBC;Driver={SQL Server Native Client 10.0};SERVER=\" & [SQLServername] & [SQLInstancename] & \";DATABASE=\" & [SQLDatabasename] & \";Trusted_Connection=\" & [SQLTrustedConn] & \";\"\n\n\nFunction DatenMDBWechselSQL(Optional Verknuepfungstabelle As String = \"Acc_SQL_tblVerknuepfungstabellen\") As Boolean\n'Man kann die Funktion verwenden, wenn man mehrere Daten-Datenbanken hat, um\n'zwischen diesen wechseln zu können, oder als Testfunktion des Moduls ...\n    \n    SQLCheckTabelle = Get_Priv_Property(\"prp_SQLCheckTabelle\")\n    If Len(Trim(Nz(SQLCheckTabelle))) = 0 Then\n        MsgBox \"prp_SQLCheckTabelle nicht gefunden bzw leer\"\n        Exit Function\n    End If\n  \n    DatenMDBWechselSQL = False\n    On Error Resume Next\n    DoCmd.DeleteObject acTable, SQLCheckTabelle\n    On Error GoTo DatenMDBWechsel_Err\n    DatenMDBWechselSQL = checkconnectSQL(Verknuepfungstabelle)\nDatenMDBWechsel_Exit:\n    Exit Function\nDatenMDBWechsel_Err:\n    DatenMDBWechselSQL = False\n    MsgBox Error$\n    Resume DatenMDBWechsel_Exit\nEnd Function\n\nPublic Function switchConnectSQL(Optional Verknuepfungstabelle As String = \"Acc_SQL_tblVerknuepfungstabellen\") As Boolean\n\nDim db As DAO.Database\nDim newdb As String\nDim nix As Integer\nDim i As Integer, countfrm As Integer\nDim frm As Form\n'Dim fd As New FileDialog\nDim startdir As String\nDim StBeschriftung As String\nDim X As String\n\nswitchConnectSQL = False\nOn Error GoTo Error_switchConnectSQL\n             \nnewdb = \"xx\"\n        \nIf Len(newdb) > 0 Then\n    ' Wenn Datenbank verbunden\n    'Alle Formulare aktualisieren\n    'Dazu alle Formulare merken und schliessen\n    countfrm = Forms.Count\n    If countfrm > 0 Then\n        ReDim merkform(countfrm) As String\n        For i = 0 To countfrm - 1\n            Set frm = Forms(i)\n            merkform(i) = frm.Name\n        Next i\n        For i = 0 To countfrm - 1\n            nix = frmClose(merkform(i))\n        Next i\n    End If\n\n    'Datenbank neu verbinden\n'    Set db = DBEngine.Workspaces(0).Databases(0) 'Für eigene Datenbank\n    Set db = CurrentDb\n    If Not ConnectDB(db, newdb, Verknuepfungstabelle) Then\n        nix = MsgBox(\"Tabellen konnten nicht ordungsgemäß verbunden werden \", vbCritical, \"Fehler beim Verbinden\")\n'        DoCmd.OpenForm \"frmSQLServerLinkNames\", acNormal, , , , acDialog\n        Exit Function\n    End If\n\n    'Alle Formulare wieder öffnen\n    For i = 0 To countfrm - 1\n        nix = frmOpen(merkform(i), vbNormal)\n    Next i\n    \n    switchConnectSQL = True\n'Else\n    ' Fehler\nEnd If\n\nExit Function\n\nError_switchConnectSQL:\n   switchConnectSQL = False\n   MsgBox Error$, , \"Error_btnSuchen_Clickd Sub\"\n   Resume switchConnectSQL_Exit\n   \nswitchConnectSQL_Exit:\nEnd Function\n\nPrivate Function ConnectDB(db As DAO.Database, datapath As String, Optional Verknuepfungstabelle As String = \"Acc_SQL_tblVerknuepfungstabellen\") As Integer\n'Verbindet alle Datendatenbank in der Datenbank db neu\n'datapath: Datenbank mit der Verbindung hergestellt werden soll\n'Rückgabe: TRUE, erfolgreich verbunden\n'          FALSE, Verbindungen konnten nicht hergestellt werden\n\nConst TEMPTBL = \"~temp\"\n\nDim i As Integer\n\n'Die Verknüpfungstabellen werden aus der Tabelle Acc_Acc_tblVerknuepfungstabellen gelesen\n'18.03.2008\n    \n' Besonders einfach in Zusammenhang mit qrymdbTable zu verwenden\n    \n' qrymdbTable:\n'SELECT MSysObjects.Name\n'FROM MSysObjects\n'WHERE (((MSysObjects.Type) = 1) And ((MSysObjects.Flags) = 0) And ((LCase(Left([Name], 4))) <> \"usys\")) Or (((MSysObjects.ForeignName) Is Not Null))\n'ORDER BY MSysObjects.Name;\n\n'und dann\n\n' \"SELECT qrymdbTable.Name AS tblName, True AS jn INTO Acc_Acc_tblVerknuepfungstabellen FROM qrymdbTable;\"\n    \n'Dim DB1 As dao.Database\nDim rst As DAO.Recordset\n    \nDim iFldNr As Long\nDim iRecNr As Long\n\nDim iFldNrMax As Long\nDim iRecNrMax As Long\n\nDim strpk As String\n\n'Set db1 = CurrentDb\nSet rst = db.OpenRecordset(\"SELECT tblname, tblname_org, Indexfkt, SQLConnectionstring FROM \" & Verknuepfungstabelle & \" WHERE jn = True ORDER BY IDSort;\", dbOpenDynaset, dbSeeChanges)\nrst.MoveLast\ni = rst.RecordCount\nrst.MoveFirst\ntables = rst.GetRows(i)\nrst.Close\nSet rst = Nothing\n\n'Achtung immer Nullbasiert\n'Tables(iFldNr,iRecNr)\n'Tables(iSpalte,iZeile)\n\niFldNrMax = UBound(tables, 1)\niRecNrMax = UBound(tables, 2)\n\nMAXTABLES = iRecNrMax\n    \nOn Error GoTo ConnectDBError\n\n'Prüfen, ob alle Verbindungen hergestellt werden können\nFor i = 0 To MAXTABLES\n    If Len(Nz(tables(0, i))) > 0 Then\n        If Not Verbinde(db, TEMPTBL, tables(1, i), (CStr(tables(3, i)))) Then\n            On Error Resume Next\n            DoCmd.DeleteObject acTable, TEMPTBL\n            ConnectDB = False\n            Exit Function\n        End If\n    End If\nNext i\n\n'Temp. Tabelle löschen\nDoCmd.DeleteObject acTable, TEMPTBL\n\n'---Connect\nFor i = 0 To MAXTABLES\n    If Len(Nz(tables(0, i))) > 0 Then\n        If Not Verbinde(db, tables(0, i), tables(1, i), (CStr(tables(3, i)))) Then\n            ConnectDB = False\n            Exit Function\n        Else\n            DoEvents\n            strpk = Nz(tables(2, i))\n            If Len(strpk) > 0 Then\n                CurrentDb.Execute (strpk)\n            End If\n        End If\n    End If\nNext i\n\nConnectDB = True\nExit Function\n\nConnectDBError:\n    On Error Resume Next\n    ConnectDB = False\n    Exit Function\nEnd Function\n\n\n\n'*****************************************************************************\n' Function Verbinde()\n'\n'   Verbindet die Tabelle mytab in der Datenbank db unter den Namen ntab mit der Datenbank strdb\n'Rückgabe: TRUE, Verbindung erfolgreich hergestellt\n'          FALSE, Verbindung konnte nicht hergestellt werden\n'*****************************************************************************\nPrivate Function Verbinde(db As DAO.Database, ByVal ntab As String, ByVal mytab As String, ByVal Connectionstring As String) As Integer\n\nDim mytable As TableDef\n'----------------------------------------\n On Error Resume Next\n 'Bestehende Verbindung löschen\n DoCmd.DeleteObject acTable, ntab\n On Error GoTo 0\n\n'On Error GoTo VerbindeError1\n 'Wenn hier Fehler auftritt ist Tabelle noch nicht eingebunden\n 'Set mytable = db.TableDefs(mytab)\n 'Jetzt wird bestehende Verbindung aktualisiert\n 'mytable.SourcetableName = mytab\n 'mytable.connect = \";DATABASE=\" & strdb\n 'mytable.RefreshLink\n'Verbinde = True\n'Exit Function\n'VerbindeError1:\n\nOn Error GoTo VerbindeError\n'Tabelle neu einbinden\nSet mytable = db.CreateTableDef(ntab)\n\nmytable.SourceTableName = mytab\n\n'hier könnte man auch ein einfaches Daten-Datenbank-Passwort (hier:\"Hugo\") speichern ...\n'mytable.Connect = \"MS ACCESS;PWD=Hugo;DATABASE=\"\n\n'Die Tabellen des SQL Servers sollen zu Access verknüpft werden. Es soll jedoch keine DSN erstellt werden.\n'Wie lautet die Syntax für einen DSN-Less Connectstring?\n'\n'Lösung:\n'DRIVER={SQL Server};SERVER=servername;DATABASE=datenbankname;UID=benutzername;PWD=kennwort\n'\n''Die Parameter Uid und Pwd können bei der NT-Authentifizierung entfallen und müssen durch Trusted_Connection=Yes ersetzt werden\n\n\nmytable.connect = Connectionstring\ndb.TableDefs.append mytable\nVerbinde = True\nExit Function\n\nVerbindeError:\n\nVerbinde = False\nExit Function\n\nEnd Function\n\nPrivate Function frmClose(ByVal frmName As String)\n'Schließt das Formular frmname\n\nDoCmd.Close acForm, frmName\n\nEnd Function\n\nPrivate Function frmOpen(ByVal frmName As String, ByVal Modus)\n'Öffnet das Formular frnname\n'modus wie in ACCESS: acNORMAL, acHIDDEN, acICON, AcDIALOG\n\nDoCmd.OpenForm frmName, , , , , Modus\n\nEnd Function\n\nPrivate Function TabTempLosesch()\n\n    On Error Resume Next\n    \n    DoCmd.SetWarnings False\n    DoCmd.DeleteObject acTable, \"tblBeispiel\"\n    DoCmd.DeleteObject acTable, \"tblTest1\"\n    DoCmd.DeleteObject acTable, \"tblTest2\"\n    DoCmd.SetWarnings True\n\nEnd Function\n\n\nFunction pk1()\nCurrentDb.Execute \"CREATE UNIQUE INDEX PK1 ON qry_Projektkopf (pkoNummer)\"\nEnd Function\nFunction pk2()\nCurrentDb.Execute \"CREATE UNIQUE INDEX PK2 ON qryPpoPpu (ppoID)\"\nEnd Function"}
