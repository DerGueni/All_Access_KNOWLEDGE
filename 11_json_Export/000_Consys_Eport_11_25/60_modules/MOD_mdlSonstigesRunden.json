{"id":"MOD_mdlSonstigesRunden","name":"mdlSonstigesRunden","kind":"standard","procedures":["Function AufXStellenRunden(varZahl As Variant, intStellen As Integer) As Double","Public Function LIB_WaehrungRunden(varZahl As Variant) As Double","Public Function FA_Runden(Wert As Variant, Optional Rundungszahl As Double = 0.01) As Variant","Function Runden(Zahl As Variant, Optional AnzahlStellen As Integer = 2) As Double","Function fctround(varNr As Variant, Optional varPl As Integer = 2) As Double","Function fctRappenRunden(varBetrag As Variant) As Variant","Function Abrunden(a, b)","Function Aufrunden(a, b)","Function Testtage(a As Date, b As Date)","Sub Sieb_Des_Eratosthenes(ByVal WieWeitWillstDuEsDenn As Long)","Function PrimeStatus(TestVal As Long) As Boolean","Function Phyt()","Function PI() As Double","Function Rad(ByVal Grad As Double) As Double","Private Function CMYK2RGB&(ByVal c!, ByVal m!, ByVal Y!, ByVal k!)","Public Function PrueffzifferModulo10(strPruefling) As String","Function stabw(W1, W2, W3, W4) As Double 'event. auch mit dem \"container\"-Objekt arbeiten","Public Function FeldFuellFix(InputFeld As Variant, ByVal InpFeldLen As Integer, Optional IsZahl As Boolean = False, Optional FeldFormat As Integer = 0, Optional Dummy As Variant) As String","Function fftest()","Function Zufallszahl(Untergrenze, Obergrenze) As Long","Public Function GetRange(iRow As Long, iCol As Long, IRowEnd As Long, IColEnd As Long)","Function Kommasuch(ByVal X As Variant) As String"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\n'#########################################################################################################\n\n'   AufXStellenRunden  - Runden (MSKB)\n'   LIB_WaehrungRunden - Auf 2 Nachkommastellen runden\n'   FA_Runden          - Runden mit Fehlerkorrektur von www.Fullaccess.de\n'   fctRound           - Runden aus FAQ\n'   runden             - Und noch eine Rundungsfunktion\n'   fctRappenRunden    - Runding auf 0,05 (für die Schweizer)\n'   Abrunden           - Abrunden mittels Excel\n'   Aufrunden          - Aufrunden mittels Excel\n'   Testtage           - 360 Tage Berechnung (Bankzinsen) mittels Excel\n'   Sieb_Des_Eratosthenes - Primzahlen errechnen\n'   PrimStatus         - Ist eine Zahl eine Primzahl ?\n'   Phyt               - Ausgabe aller Zahlen (bis 80), bei denen c lt. Phytagoras (a^2 + b^2 = c^2) ein Integerwert ist\n'   Zufallszahl        - Ausgabe einer Zufallszahl (Ganzzahl)\n'#########################################################################################################\n\nFunction AufXStellenRunden(varZahl As Variant, intStellen As Integer) As Double\n\n'Mit Hilfe dieser Funktion können Sie eine Zahl auf eine beliebige Stelle\n'runden. Maximal können 15 Ziffern (Ziffern vor dem Komma + Ziffern nach dem\n'Komma <= 15 Ziffern) dargestellt werden.\n'Der Übergabeparameter \"varZahl\" stellt die zu rundende Zahl dar.\n'Die Variable \"intStellen\" gibt an, auf wieviel Stellen nach (positive Zahl)\n'bzw. vor (negative Zahl) dem Komma gerundet werden soll.\n'Aus der deutschen MSKB\n\nDim X As Double\nDim dblErgebnis As Double\nDim Zahlzwi As Double\nDim Neg As Boolean\n\nOn Error GoTo Error_Handler\n\nIf varZahl < 0 Then\n    Zahlzwi = varZahl * -1\n    Neg = True\nElse\n    Zahlzwi = varZahl\n    Neg = False\nEnd If\n\nIf IsNull(Zahlzwi) Then\n    dblErgebnis = 0\nElse\n' wenn negative Zahl, dann muß der absolute Wert genommen werden\n    If intStellen < 0 Then\n        X = 10 ^ (Abs(intStellen))\n        dblErgebnis = Int(Zahlzwi / X + 0.5) * X\n    Else\n        X = 10 ^ intStellen\n        dblErgebnis = Int(Zahlzwi * X + 0.5) / X\n    End If\n\nEnd If\n\nIf Neg Then\n    dblErgebnis = dblErgebnis * -1\nEnd If\n\nAufXStellenRunden = dblErgebnis\n\nExit_AufXStellenRunden:\nExit Function\n\nError_Handler:\n\nMsgBox \"Der Fehler '\" & Error(err) & \"' trat beim Runden auf.\"\nAufXStellenRunden = varZahl\n\nResume Exit_AufXStellenRunden\n\nEnd Function\n\n\nPublic Function LIB_WaehrungRunden(varZahl As Variant) As Double\n'Diese Funktion soll LIB_AufXStellenRunden ersetzen.\n'Die Funktion rundet für zwei Nachkommastellen korrekt.\n'von H.Langer\n\nDim X As Double\nDim dblErgebnis As Double\nDim hcur As Double\nDim hint As Integer\n\nOn Error GoTo LIB_WaehrungRunden_Error_handler\n\nIf IsNull(varZahl) Then\ndblErgebnis = 0\nElse\n    hcur = varZahl - Int(varZahl)\n    hcur = hcur * 1000\n    hint = hcur Mod 10\n    If hint = 5 Then\n        If varZahl < 0 Then\n            varZahl = varZahl - 0.001\n          Else\n            varZahl = varZahl + 0.001\n        End If\n    End If\n\ndblErgebnis = Int(varZahl * 100 + 0.5) / 100\nEnd If\n\nLIB_WaehrungRunden = dblErgebnis\n\nExit_LIB_WaehrungRunden:\nExit Function\n\nLIB_WaehrungRunden_Error_handler:\nMsgBox \"Der Fehler '\" & Error(err) & \"' trat beim Runden auf.\"\nLIB_WaehrungRunden = varZahl\nResume Exit_LIB_WaehrungRunden\n\nEnd Function\n\n\nPublic Function FA_Runden(Wert As Variant, Optional Rundungszahl As Double = 0.01) As Variant\n' Von www.fullaccess.de\n'Mit dem ersten Funktionsparameter übergeben Sie der Funktion den Wert, der\n'gerundet werden soll. Der Parameter Rundungszahl bestimmt die Kommastelle,\n'auf die gerundet wird. Die Funktion gibt die gerundete Zahl zurück.\n'Wenn Sie eine Zahl auf die zweite Nachkommastelle runden möchten geben Sie als\n'Rundungszahl 0,01 ein.\n    \nDim res As Variant\nDim dberg As Double\n\n    FA_Runden = Null\n    If IsNull(Wert) Then Exit Function\n        \n    res = (Wert / Rundungszahl)\n\n     dberg = CLng(res + IIf(Wert > 0, 0.000000000001, -0.000000000001)) * Rundungszahl\n     If dberg <> 0 Then\n        FA_Runden = dberg\n     End If\n\nEnd Function\n\nFunction Runden(Zahl As Variant, Optional AnzahlStellen As Integer = 2) As Double\n'Autor: jörg stephan\n'syskoplan GmbH\n'Ahrensburger Str. 5, D-30659 Hannover\n'tel.     +49 (511) 902 91-0\n'fax    +49 (511) 902 91-99\n'mailto: joerg.stephan@ syskoplan.de\n'http://www.syskoplan.de\n\n  Dim temp As Double, Zehnerpotenz As Long\n  temp = CDbl(Zahl)\n  Zehnerpotenz = 10 ^ AnzahlStellen\n  Runden = (Fix((temp + 0.5 / Zehnerpotenz) * Zehnerpotenz)) / Zehnerpotenz\nEnd Function\n\n\nFunction fctround(varNr As Variant, Optional varPl As Integer = 2) As Double\n 'by Konrad Marfurt + (\"\" by) Luke Chung + Karl Donaubauer\n    'raus hier bei nicht-nummerischem Argument\n    If Not IsNumeric(varNr) Then Exit Function\n    fctround = Fix(\"\" & varNr * (10 ^ varPl) + Sgn(varNr) * 0.5) / (10 ^ varPl)\nEnd Function\n\nFunction fctRappenRunden(varBetrag As Variant) As Variant\n' verwendet fctRound\nfctRappenRunden = fctround((varBetrag * 20), 0) / 20\nEnd Function\n\n'Günther Ritter (www.ostfrieslandweb.de) meinte einst in einer FAQ zu Excel:\n'Auf- oder abrunden in ACCESS97 mit EXCEL\n'\n'Nun, eigentlich ganz einfach. Nur bisher wenig bekannt: In A97 stehen auch die Funktionen von EXCEL zur\n'Verfügung. Und nicht nur in A97, es funktioniert auch in A95.\n'Damit es funktioniert, ist es erforderlich im Modul unter Extras/Verweise den Verweis auf die\n'EXCEL 8.0 Object Library anzukreuzen. Das ist übrigens die EXCEL8.OLB! Und wie gesagt, ein Verweis\n'darauf wird auch von A95 akzeptiert!\n'a=Wert, b=Anzahl Stellen\n\nFunction Abrunden(a, b)\n'a=Wert, b=Anzahl Stellen\n'Abrunden = Excel.WorksheetFunction.RoundDown(A, B)\nEnd Function\n\nFunction Aufrunden(a, b)\n'a=Wert, b=Anzahl Stellen\n'Aufrunden = Excel.WorksheetFunction.RoundUp(A, B)\nEnd Function\n\nFunction Testtage(a As Date, b As Date)\n'A = Von Datum  B = Bis Datum\n'Testtage = Excel.WorksheetFunction.Days360(A, B, True)\nEnd Function\n\n\n'Gepostet von Guido Ledermann (gledermann@bgt-bretten.de)\n'hier eine Routine zum Sieb. Sie ist nicht schön, nicht schnell, aber sie ist\n'genau der Algorithmus, wie er von dem Griechen (war er das???) beschrieben wurde.\n\nSub Sieb_Des_Eratosthenes(ByVal WieWeitWillstDuEsDenn As Long)\n    ReDim sand(WieWeitWillstDuEsDenn) As Long\n    Dim n As Long\n    Dim m As Long\n\n    'Zahlensand erstellen\n    For n = 1 To WieWeitWillstDuEsDenn\n        sand(n) = n\n    Next\n    ' Dann alle die durch 2 teilbar sind rauswerfen\n    For n = 1 To WieWeitWillstDuEsDenn\n        If sand(n) Mod 2 = 0 Then\n            Debug.Print sand(n) & \" fliegt raus\"\n            sand(n) = 0\n        End If\n    Next\n\n    ' nun kommt der iterative teil\n    n = 2\n    ' die nächste primzahl suchen\n    Do\n        n = n + 1\n        ' wenn wir die primzahl haben, die größer ist als die quadratwurzel der größten zahl\n        ' die wir untersuchen können wir aufhören\n        If n > Sqr(WieWeitWillstDuEsDenn) Then Exit Do\n        If sand(n) <> 0 Then\n            Debug.Print \"alle durch \" & sand(n) & \" teilbaren zahlen fliegen jetzt raus\"\n    ' alle größeren zahlen nun prüfen, ob sie durch diese primzahl teilbar sind\n            m = n + 1\n            Do\n    ' wenn sie teilbar ist, dann aussieben...\n                If m > WieWeitWillstDuEsDenn Then Exit Do\n                If sand(m) Mod sand(n) = 0 And sand(m) <> 0 Then\n                    'Debug.Print sand(m) & \" fliegt raus\"\n                    DoEvents\n                    sand(m) = 0\n                End If\n                m = m + 1\n            Loop\n        End If\n    Loop\n\n    For n = 1 To WieWeitWillstDuEsDenn\n        If sand(n) <> 0 Then Debug.Print \"primzahl=\" & sand(n)\n    Next\nEnd Sub\n\nFunction PrimeStatus(TestVal As Long) As Boolean\n' Ist eine Zahl eine Primzahl ?\n    Dim i As Long\n    Dim Lim As Long 'Integer\n    If TestVal < 5 Then Exit Function\n    PrimeStatus = True\n    Lim = Sqr(TestVal)\n    For i = 3 To Lim Step 2\n       If TestVal Mod i = 0 Then\n          PrimeStatus = False\n          Exit For\n       End If\n       If i Mod 201 = 0 Then DoEvents\n    Next i\n\nEnd Function\n\n\n\nFunction Phyt()\n'Ausgabe aller Zahlen (bis 80), bei denen c lt. Phytagoras (a^2 + b^2 = c^2) ein Integerwert ist.\nDim a As Integer, b As Integer, c As Double\n\nFor a = 1 To 60\n  For b = 1 To 80\n    c = Sqr(a ^ 2 + b ^ 2)\n      If c = Int(c) Then\n        Debug.Print str(a) & \"^2 +\" & str(b) & \"^2 =\" & str(c) & \"^2\"\n      End If\n  Next b\nNext a\n\nEnd Function\n\n 'Kreiszahl Pi als Konstante definieren:\n' Const Pi As Double = 3.14159265358979\n\n 'ODER: Pi berechnen lassen:\n Function PI() As Double\n   PI = Atn(1) * 4#\n End Function\n\n 'Umrechnung Grad in Bogenmaß:\n' Autor: Jost Schwider\n Function Rad(ByVal Grad As Double) As Double\n   '2 Pi entsprechen 360 Grad:\n   Rad = PI * Grad / 180\n End Function\n\n' Dann kannst Du in Deinen Berechnungen mit Grad arbeiten:\n'   Print Sin(Rad(90))\n'   '--> ergibt 1!\n'\n' Oder Du definierst Dir eine Konstante \"Rad\", die direkt\n' den Umrechnungsfaktor angibt:\n'   Const Rad As Double = 1.74532925199433E-02\n' Dann kannst Du z.B. schreiben:\n'   Print Sin(90 * Rad)\n'   '--> ergibt immer noch 1!   ;-)\n\n\nPrivate Function CMYK2RGB&(ByVal c!, ByVal m!, ByVal Y!, ByVal k!)\n'Autor: Newsgroup Olaf Schmidt\n'ich suche eine Möglichkeit, CYMK-Farbwerte in RGB umzurechnen, da in VB\n'ja nur RGB-Farbwerte verwendet werden können. Gibt es dafür eine API-\n'Funktion (eine interne habe ich in VB5 nicht gefunden).\nDim r%, G%, b%\n  If (c + k) < 255 Then r = 255 - (c + k)\n  If (m + k) < 255 Then G = 255 - (m + k)\n  If (Y + k) < 255 Then b = 255 - (Y + k)\n  CMYK2RGB = RGB(r, G, b)\nEnd Function\n\n\n'*******************************************************************************\n' Methode:      PrueffzifferModulo10()\n' Autor:        André Hürst 25.09.1997\n' Parameter:    strPruefling: zu prüfende Zeichen als Zeichenkette.\n' Verwendung:   Ermittelt die Prüfziffer anhand einer Zeichenkette. Die\n'               Prüfziffer wird mittels Modulo 10 rekursiv bestimmt.\n'*******************************************************************************\nPublic Function PrueffzifferModulo10(strPruefling) As String\n    Dim X As Integer\n    Dim intUebertrag As Integer\n    Const strVektor = \"0946827135\"\n\n    On Error Resume Next\n\n    intUebertrag = 0\n    For X = 1 To Len(strPruefling)\n        intUebertrag = CInt(Mid(strVektor, (CInt(Mid(strPruefling, X, 1)) _\n            + intUebertrag) Mod 10 + 1, 1))\n    Next X\n    If intUebertrag = 0 Then\n        PrueffzifferModulo10 = CStr(intUebertrag)\n    Else\n        PrueffzifferModulo10 = CStr(10 - intUebertrag)\n    End If\nEnd Function\n\n\nFunction stabw(W1, W2, W3, W4) As Double 'event. auch mit dem \"container\"-Objekt arbeiten\n'Autor: Sönke Peterson\n    Dim drs As Double 'durchschnitt\n    drs = (W1 + W2 + W3 + W4) / 4\n    stabw = ((drs - W1) + (drs - W2) + (drs - W3) + (drs - W4)) / 4\nEnd Function\n\nPublic Function FeldFuellFix(InputFeld As Variant, ByVal InpFeldLen As Integer, Optional IsZahl As Boolean = False, Optional FeldFormat As Integer = 0, Optional Dummy As Variant) As String\n' Autor: Klaus Oberdalhoff - 3.12.1999\n' Ver: 1.0\n' Diese Funktion gibt einen String fixer Länge (abhängig von der InpFeldLen) zurück\n' Diese Funktion ist speziell für den Export von ASCII-Daten fester Länge gedacht\n'\n' Übergabefelder: InputFeld - das zu \"richtende\" Feld.\n'                 InpFeldLen - gewünschte Feldlänge\n'                 IsZahl\n'                 FeldFormat\n'                 Dummy\n'\n' Das optionale Feld IsZahl entscheidet darüber, ob mit Nullen oder mit Blanks aufgefüllt wird\n' True formatiert mit führenden Nullen, False mit führenden Blanks\n' Der Standardwert ist False\n'\n' Das optionale Feld FeldFormat dient dazu, eine Zahl oder ein Datum \"vorzuformatieren\"\n' Es kann nach eigenem Gusto ausgebaut werden\n' FeldFormat = 0 - nix besonderes\n'            = 1 - Zahl  fix mit 2 Nachkommastellen: 123456,78  - Feldlänge mindestens 4\n'            = 2 - Datum in der Form #yyyy-mm-dd# (ISO-Norm Datum) - Feldlänge = 12\n'            = 3 - Datum in der Form #yyyy-mm-dd hh:mm:ss AM/PM# - Feldlänge = 24\n'            = 4 - Datum in der Form yyyymmdd - Feldlänge = 8\n'            = 5 - Datum in der Form yyyymmddhhmmss - Feldlänge 14\n' Feldformat 2 - 5 nur, wenn InputFeld nicht leer ...\n' Der Standardwert ist 0\n'\n' !!!!!!!!!!!!!!!!!!!!!!!!!!!\n' Bei Verwendung von Feldformaten werden die Feldlängen überschrieben (Feldformat 2 - 5)\n' bzw. auf die erforderliche Mindestlänge von 4 gesetzt wenn kleiner (Feldformat 1)\n' !!!!!!!!!!!!!!!!!!!!!!!!!!!\n'\n' Das Feld optionale Dummy ist gedacht, um diese Funktion auch in Abfragen verwenden zu können,\n' damit kann man den Access-intern immer aktiven \"Query-Optimizer\" austricksen.\n' Wenn man an dieses Dummy-Feld den Primary-Key übergibt, dann führt der Optimizer\n' diese Funktion bei jedem Durchlauf aus, ansonsten könnte es passieren, daß der\n' Optimizer diese Funktion \"wegoptimiert\" und nicht jedesmal aufruft\n\nDim tmpOut As String\nDim Null80 As String\n\n'Zum Nullenfüllen - Eine Zahl wird wohl kaum mehr als 80 Stellen lang sein, oder ?\nNull80 = \"00000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n\n'Abbruch bei falscher Feldlänge und keinem Format\nIf FeldFormat < 1 And InpFeldLen < 1 Then\n    FeldFuellFix = \"\"\n    Exit Function\nEnd If\n\n'Input umwandeln in String\nIf Len(Nz(InputFeld)) = 0 Then\n    If FeldFormat = 1 Then\n        tmpOut = Format(0, \"0.00\")\n        If InpFeldLen < 4 Then InpFeldLen = 4\n    Else\n        tmpOut = \"\"\n    End If\nElse\n'    FeldFormate 2 - 5 greifen nur, wenn InputFeld nicht leer\n    tmpOut = CStr(InputFeld)\n    If FeldFormat > 0 Then\n        Select Case FeldFormat\n            Case 1\n                If IsNumeric(InputFeld) Then\n                    tmpOut = Format(InputFeld, \"0.00\")\n                    If InpFeldLen < 4 Then InpFeldLen = 4\n                End If\n            Case 2\n                If IsDate(InputFeld) Then\n                    tmpOut = Format(CDate(InputFeld), \"\\#yyyy\\-mm\\-dd\\#\", vbMonday, vbFirstFourDays)\n                    InpFeldLen = 12\n                End If\n            Case 3\n                If IsDate(InputFeld) Then\n                    tmpOut = Format(CDate(InputFeld), \"\\#yyyy\\-mm\\-dd hh:nn:ss AM/PM\\#\", vbMonday, vbFirstFourDays)\n                    InpFeldLen = 24\n                End If\n            Case 4\n                If IsDate(InputFeld) Then\n                    tmpOut = Format(CDate(InputFeld), \"yyyymmdd\", vbMonday, vbFirstFourDays)\n                    InpFeldLen = 8\n                End If\n            Case 5\n                If IsDate(InputFeld) Then\n                    tmpOut = Format(CDate(InputFeld), \"yyyymmddhhnnss\", vbMonday, vbFirstFourDays)\n                    InpFeldLen = 14\n                End If\n            Case Else\n        End Select\n    End If\n\nEnd If\n\n'Was tun, wenn Input bereits größer als gewünschte Outputlänge ???????????????\nIf Len(tmpOut) >= InpFeldLen Then\n    FeldFuellFix = Left(tmpOut, InpFeldLen)\n    Exit Function\nEnd If\n\n' Eigentlicher Auffüllvorgang\nIf IsZahl Then  ' mit Nullen füllen\n        FeldFuellFix = Right(Null80 & tmpOut, InpFeldLen)\nElse    ' mit Space füllen\n        FeldFuellFix = Right(Space(InpFeldLen) & tmpOut, InpFeldLen)\nEnd If\n\nEnd Function\n\nFunction fftest()\nDim ss As Double\nDim str As String\nDim dd As Date\nDim ii As Integer\nDim xx As Currency\n\nss = 123.456\nDebug.Print FeldFuellFix(ss, 9, True)\nDebug.Print FeldFuellFix(ss, 9, True, 1)\ndd = #12/31/1999 2:22:33 PM#\nDebug.Print FeldFuellFix(dd, 15, True)\nDebug.Print FeldFuellFix(dd, 0, True, 2)\nDebug.Print FeldFuellFix(dd, 0, True, 3)\nDebug.Print FeldFuellFix(dd, 0, True, 4)\nDebug.Print FeldFuellFix(dd, 0, True, 5)\nii = 123\nDebug.Print FeldFuellFix(ii, 9, True)\nDebug.Print FeldFuellFix(ii, 9, True, 1)\nstr = \"Hugo ist doof\"\nDebug.Print FeldFuellFix(str, 19)\nDebug.Print FeldFuellFix(str, 19, True)\nxx = ss + 0.02\nDebug.Print FeldFuellFix(xx, 9, True)\nDebug.Print FeldFuellFix(xx, 9, True, 1)\n\nEnd Function\n\nFunction Zufallszahl(Untergrenze, Obergrenze) As Long\n' Aus der Online-Hilfe\n' Verwenden Sie die folgende Formel, um ganzzahlige Zufallszahlen innerhalb\n' eines bestimmten Bereichs zu erzeugen:\n' Wert1 = Int((Obergrenze - Untergrenze + 1) * Rnd + Untergrenze)\n' Obergrenze steht hier für die größte Zahl des Bereichs und Untergrenze für\n' die kleinste Zahl des Bereichs.\nRandomize\nZufallszahl = Int((Obergrenze - Untergrenze + 1) * Rnd + Untergrenze)\nEnd Function\n\nPublic Function GetRange(iRow As Long, iCol As Long, IRowEnd As Long, IColEnd As Long)\nIf iCol > 26 Then\n    GetRange = Chr$(64 + (iCol \\ 26)) & Chr$(64 + (iCol Mod 26)) & CStr(iRow)\nElse\n    GetRange = Chr$(64 + iCol) & CStr(iRow)\nEnd If\nGetRange = GetRange & \":\"\nIf IColEnd > 26 Then\n    GetRange = GetRange & Chr$(64 + (IColEnd \\ 26)) & Chr$(64 + (IColEnd Mod 26)) & CStr(IRowEnd)\nElse\n    GetRange = GetRange & Chr$(64 + IColEnd) & CStr(IRowEnd)\nEnd If\nEnd Function\n\n\nFunction Kommasuch(ByVal X As Variant) As String\nDim il As Long\nKommasuch = \"\"\nX = Trim(Nz(X))\nil = Len(X)\nIf il = 0 Then\n    Exit Function\nEnd If\nIf Not IsNumeric(X) Then\n    Kommasuch = X\n    Exit Function\nElse\n    Kommasuch = Format(X, \"0.00\")\nEnd If\n\nEnd Function\n"}
