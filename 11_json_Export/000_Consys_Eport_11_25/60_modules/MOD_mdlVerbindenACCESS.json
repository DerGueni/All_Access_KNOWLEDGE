{"id":"MOD_mdlVerbindenACCESS","name":"mdlVerbindenACCESS","kind":"standard","procedures":["Function checkconnectAcc()","Function DatenMDBWechselAcc()","Function switchConnectAcc(Optional Backend As String)","Function ConnectDBAcc(db As DAO.Database, datapath As String, Optional Errdb As String) As Integer","Public Function VerbindeAcc(db As DAO.Database, ByVal ntab As String, ByVal mytab As String, ByVal strDB As String) As Integer","Function frmClose(ByVal frmName As String)","Function frmOpen(ByVal frmName As String, ByVal Modus)","Function TabTempLosesch()","Function CopyUsr_verb(ByVal xtbl As String, ByVal xdb As String, Optional XPasswd As String = \"\", Optional ByVal NeuTabNam As String) As Boolean"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\nOption Base 0\n\nConst OFN_FILEMUSTEXIST = &H1000\nConst OFN_PATHMUSTEXIST = &H800\nConst OFN_HIDEREADONLY = &H4\nConst OFN_READONLY = &H1\nConst OFN_OVERWRITEPROMPT = &H2\n\nDim tables As Variant\nDim MAXTABLES As Long\n\nDim AccCheckTabelle As String\n\n\n' #############################################################\n'    Description\n' #############################################################\n\n'  Uses mdlPrivPropery                Module\n'       tblProperty Table\n\n'       FileDialog                    Classmodule   - for helping to search the linked mdb\n\n'  \"prp_AccCheckTabelle\"  Within tblProperty Table contains the name of the table which is checked\n'   If this (pre)checked table can be opened, then it is assumed that all connections are OK and no other connections are checked\n\n'     Acc_Acc_tblVerknuepfungstabellen  Table    - contains the names of the tables to be connected\n'       JN = False table will not be connected\n'       tblName = Source and Destination tablen\n\n' Important functions:\n'   checkconnectSQL - Optional different (can be Query) name for Acc_SQL_tblVerknuepfungstabellen, when created via Query - as parameter - same structure\n'   DatenMDBWechselSQL  - \"\n\n' checkconnectAcc = called in Autoexec Macro\n' DatenMDBWechselAcc = Force reconnect (just deletes table-link from \"prp_AccCheckTabelle\")\n\n' #############################################################\n\n\n\n\n'\n'=======================================================================\n\nFunction checkconnectAcc()\n'Überprüft, ob die Datenbank verbunden sind\nDim db As DAO.Database\nDim tbl As DAO.Recordset\nDim nix\nDim fail As Boolean\nDim AccCheckTabelle As String\n\n\nOn Error GoTo checkconnectError\nSet db = DBEngine.Workspaces(0).Databases(0)\n\nAccCheckTabelle = Get_Priv_Property(\"prp_AccCheckTabelle\")\nIf Len(Trim(Nz(AccCheckTabelle))) = 0 Then\n    MsgBox \"prp_AccCheckTabelle nicht gefunden bzw leer\"\n    Exit Function\nEnd If\n\n' Hier einen existierenden Tabellennamen eingeben\n' Es wird davon ausgegangen, daß wenn diese Tabelle nicht korrekt connected ist,\n' die anderen Tabellen auch nicht korrekt connected sind.\n\nSet tbl = db.OpenRecordset(AccCheckTabelle, dbOpenDynaset, dbSeeChanges)\n\nExit Function\n\ncheckconnectError:\n    'Backend auswählen\n    Call switchConnectAcc\n    Exit Function\n\nEnd Function\n\nFunction DatenMDBWechselAcc()\n'Man kann die Funktion verwenden, wenn man mehrere Daten-Datenbanken hat, um\n'zwischen diesen wechseln zu können, oder als Testfunktion des Moduls ...\n    \nAccCheckTabelle = Get_Priv_Property(\"prp_AccCheckTabelle\")\nAccCheckTabelle = Get_Priv_Property(\"prp_AccCheckTabelle\")\nIf Len(Trim(Nz(AccCheckTabelle))) = 0 Then\n    MsgBox \"prp_AccCheckTabelle nicht gefunden bzw leer\"\n    Exit Function\nEnd If\n   \n    On Error Resume Next\n    DoCmd.DeleteObject acTable, AccCheckTabelle\n    On Error GoTo DatenMDBWechsel_Err\n    checkconnectAcc\nDatenMDBWechsel_Exit:\n    Exit Function\nDatenMDBWechsel_Err:\n    MsgBox Error$\n    Resume DatenMDBWechsel_Exit\nEnd Function\n\nFunction switchConnectAcc(Optional Backend As String)\n\n'switchConnect: a) Vorgeschlagen wird immer das Directory, in dem sich die Programm-Datenbank befindet\n'               b) Auskommentiertes Beispiel, wie man immer automatisch mit einer \"festen\" Daten-Datenbank\n'                   anstelle des Dialoges verbinden kann\n\n'Stellt Dialog zur Auswahl einer neuen Datenbank dar\n'Nach Auswahl einer neuen adrdata.mdb werden die benötigten Tabellen aus dieser\n'verbunden\nDim db As DAO.Database\nDim newdb As String\nDim nix As Integer\nDim i As Integer\nDim frm As Form, countfrm As Integer\nDim fd As New FileDialog\nDim startdir As String\nDim StBeschriftung As String\nDim X As String\n\nOn Error GoTo Error_switchConnect\n      \n' Start-Directory und Beschriftung festlegen.\n' Hier das Start-Directory eingeben, in dem die Dateisuche anfangen soll\n' Neu: Es wird immer das aktuelle Directory der \"Haupt-MDB\" angezeigt\n   startdir = Left(CurrentDb.Name, Len(CurrentDb.Name) - Len(Dir(CurrentDb.Name)))\n   If Right(startdir, 1) <> \"\\\" Then startdir = startdir & \"\\\"\n   \n''''''''''' Neu in Vers. 3.0:\n''''''''''' Wenn im aktuellen Directory die Datei \"DeineDaten.mdb\" vorhanden ist, wird mit dieser\n''''''''''' verbunden, ansonsten wird nach der Datenbank gefragt ...\n'''''''''''\n    \n'''''' Kommentarzeichen weg ...''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n\n'    If Len(Trim(Nz(Dir(startdir & \"DeineDaten.MDB\")))) > 0 Then\n'            newdb = startdir & \"DeineDaten.mdb\"\n'    Else\n    If Backend <> \"\" Then\n            newdb = Backend\n    Else\n\n'''''' Kommentarzeichen weg ...''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n\n' weiter unten beim End If muß ggf. noch das Kommentarzeichen weg\n           \n           \n        ' Hier die Beschriftung für den Dialog der Dateisuche eingeben\n           StBeschriftung = \"Daten-Datenbank suchen\"\n                \n        'Wenn alles OK, Dateiname entfernen und nur Directorypath übrig lassen\n            If Len(startdir) > 0 Then\n                Do\n                    X = Right(startdir, 1)\n                    If X = \"\\\" Or Len(startdir) = 0 Then\n                        Exit Do\n                    End If\n                    startdir = Left(startdir, Len(startdir) - 1)\n                Loop\n            Else\n        ' Notfall Directory, wenn das Start-Directory nicht gültig ist.\n                startdir = \"C:\\\"\n            End If\n                  \n           With fd  ' CommonDialog aufrufen\n            ' Erläuterungen im Code des KlassenModuls FileDialog\n              \n              .DialogTitle = StBeschriftung\n              .InitDir = startdir\n              \n        '      .DefaultExt = \"TXT\"             'Standard-Endung wenn vom Benutzer nix anderes angegeben\n        '                                      ' Ansonsten wird Filter1 verwendet\n        '      .Flags = OFN_FILEMUSTEXIST Or OFN_PATHMUSTEXIST Or OFN_READONLY\n              .Flags = OFN_FILEMUSTEXIST Or OFN_PATHMUSTEXIST\n                              \n        ' Hier können bis max. 5 Filter für Datei-Endungen definiert werden\n              \n              .Filter1Text = \"ACCDB-Dateien (*.accdb)\"\n              .Filter1Suffix = \"*.accdb\"\n              .Filter2Text = \"MDB-Dateien (*.mdb)\"\n              .Filter2Suffix = \"*.mdb\"\n              .Filter3Text = \"MD?-Dateien (*.md?)\"\n              .Filter3Suffix = \"*.md?\"\n              .Filter4Text = \"Alle Dateien (*.*)\"\n              .Filter4Suffix = \"*.*\"\n        '      .Filter5Text = \"DOC-Dateien (*.doc)\"\n        '      .Filter5Suffix = \"*.doc\"\n        \n        '      ... bis max. Filter5Text/Suffix ...\n        '\n              .ShowOpen                          ' oder .ShowSave\n           End With\n           \n        newdb = fd.fileName\n        \n'''''' Kommentarzeichen weg ...''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n\n   End If\n\n'''''' Kommentarzeichen weg ...''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n        \nIf Len(newdb) > 0 Then\n    ' Wenn Datenbank verbunden\n    'Alle Formulare aktualisieren\n    'Dazu alle Formulare merken und schliessen\n    'Dim frm As Form, countfrm As Integer\n    countfrm = Forms.Count\n    If countfrm > 0 Then\n        ReDim merkform(countfrm) As String\n        For i = 0 To countfrm - 1\n            Set frm = Forms(i)\n            merkform(i) = frm.Name\n        Next i\n        For i = 0 To countfrm - 1\n            nix = frmClose(merkform(i))\n        Next i\n    End If\n\n    'Datenbank neu verbinden\n    Set db = DBEngine.Workspaces(0).Databases(0) 'Für eigene Datenbank\n    If Not ConnectDBAcc(db, newdb) Then\n        nix = MsgBox(\"Tabellen konnten nicht ordungsgemäß verbunden werden \", vbCritical, \"Fehler beim Verbinden\")\n        Exit Function\n    End If\n\n    'Alle Formulare wieder öffnen\n    For i = 0 To countfrm - 1\n        nix = frmOpen(merkform(i), vbNormal)\n    Next i\n'Else\n    ' Fehler\nEnd If\n\nExit Function\n\nError_switchConnect:\n   MsgBox Error$, , \"Error_btnSuchen_Clickd Sub\"\n   Resume switchConnect_Exit\n   \nswitchConnect_Exit:\nEnd Function\n\nFunction ConnectDBAcc(db As DAO.Database, datapath As String, Optional Errdb As String) As Integer\n'Verbindet alle Datendatenbank in der Datenbank db neu\n'datapath: Datenbank mit der Verbindung hergestellt werden soll\n'Rückgabe: TRUE, erfolgreich verbunden\n'          FALSE, Verbindungen konnten nicht hergestellt werden\n\nConst TEMPTBL = \"~temp\"\n\nDim i As Integer\n\n' Hier müssen die gewünschten Tabellen \"hardcoded\" eingegeben werden.\n' Dies hat den Vorteil gegenüber einer Prozedur \"alle Einbinden\", daß man\n' selektiv Tabellen auswählen kann, die eingebunden werden sollen.\n\n'Die Verknüpfungstabellen werden aus der Tabelle Acc_Acc_tblVerknuepfungstabellen gelesen\n'18.03.2008\n    \n' Besonders einfach in Zusammenhang mit qrymdbTable zu verwenden\n    \n' qrymdbTable:\n'SELECT MSysObjects.Name\n'FROM MSysObjects\n'WHERE (((MSysObjects.Type) = 1) And ((MSysObjects.Flags) = 0) And ((LCase(Left([Name], 4))) <> \"usys\")) Or (((MSysObjects.ForeignName) Is Not Null))\n'ORDER BY MSysObjects.Name;\n\n'und dann\n\n' \"SELECT qrymdbTable.Name AS tblName, True AS jn INTO Acc_Acc_tblVerknuepfungstabellen FROM qrymdbTable;\"\n    \nDim DB1 As DAO.Database\nDim rst As DAO.Recordset\n    \nDim iFldNr As Long\nDim iRecNr As Long\n\nDim iFldNrMax As Long\nDim iRecNrMax As Long\n\nSet DB1 = CurrentDb\nSet rst = DB1.OpenRecordset(\"SELECT tblName FROM Acc_Acc_tblVerknuepfungstabellen WHERE jn = True ORDER BY ID;\", dbOpenDynaset, dbSeeChanges)\nrst.MoveLast\ni = rst.RecordCount\nrst.MoveFirst\ntables = rst.GetRows(i)\nrst.Close\nSet rst = Nothing\n\n'Achtung immer Nullbasiert\n'Tables(iFldNr,iRecNr)\n'Tables(iSpalte,iZeile)\n\niFldNrMax = UBound(tables, 1)\niRecNrMax = UBound(tables, 2)\n\nMAXTABLES = iRecNrMax\n    \nOn Error GoTo ConnectDBError\n\n'Prüfen, ob alle Verbindungen hergestellt werden können\nFor i = 0 To MAXTABLES\n    If Len(Nz(tables(0, i))) > 0 Then\n        If Not VerbindeAcc(db, TEMPTBL, tables(0, i), datapath) Then\n            Debug.Print tables(0, i)\n            On Error Resume Next\n            DoCmd.DeleteObject acTable, TEMPTBL\n            ConnectDBAcc = False\n            Exit Function\n        End If\n    End If\nNext i\n\n'Temp. Tabelle löschen\nDoCmd.DeleteObject acTable, TEMPTBL\n\n'---Connect\nFor i = 0 To MAXTABLES\n    If Len(Nz(tables(0, i))) > 0 Then\n        If Not VerbindeAcc(db, tables(0, i), tables(0, i), datapath) Then\n            ConnectDBAcc = False\n            Exit Function\n        End If\n    End If\nNext i\n\nConnectDBAcc = True\nExit Function\n\nConnectDBError:\n    On Error Resume Next\n    ConnectDBAcc = False\n    Exit Function\nEnd Function\n\n\n'*****************************************************************************\n' Function Verbinde()\n'\n'   Verbindet die Tabelle mytab in meiner Datenbank db unter den Namen ntab mit der fremden Datenbank strdb\n'Rückgabe: TRUE, Verbindung erfolgreich hergestellt\n'          FALSE, Verbindung konnte nicht hergestellt werden\n'*****************************************************************************\nPublic Function VerbindeAcc(db As DAO.Database, ByVal ntab As String, ByVal mytab As String, ByVal strDB As String) As Integer\n\nDim mytable As TableDef\n'----------------------------------------\n On Error Resume Next\n 'Bestehende Verbindung löschen\n DoCmd.DeleteObject acTable, ntab\n On Error GoTo 0\n\n'On Error GoTo VerbindeError1\n 'Wenn hier Fehler auftritt ist Tabelle noch nicht eingebunden\n 'Set mytable = db.TableDefs(mytab)\n 'Jetzt wird bestehende Verbindung aktualisiert\n 'mytable.SourcetableName = mytab\n 'mytable.connect = \";DATABASE=\" & strdb\n 'mytable.RefreshLink\n'Verbinde = True\n'Exit Function\n'VerbindeError1:\n\nOn Error GoTo VerbindeError\n\n\n'Tabelle neu einbinden\nSet mytable = db.CreateTableDef(ntab)\n\nmytable.SourceTableName = mytab\n\n'hier könnte man auch ein einfaches Daten-Datenbank-Passwort (hier:\"Hugo\") speichern ...\n'mytable.Connect = \"MS ACCESS;PWD=Hugo;DATABASE=\"\n\n'mytable.Connect = \"MS ACCESS;DATABASE=\" & strDb & \";PWD=\" & XPasswd & \";\"\nmytable.connect = \"MS ACCESS;DATABASE=\" & strDB\ndb.TableDefs.append mytable\n    \nVerbindeAcc = True\nExit Function\n\nVerbindeError:\n\nVerbindeAcc = False\nExit Function\n\nEnd Function\n\n\nFunction frmClose(ByVal frmName As String)\n'Schließt das Formular frmname\n\nDoCmd.Close acForm, frmName\n\nEnd Function\n\nFunction frmOpen(ByVal frmName As String, ByVal Modus)\n'Öffnet das Formular frnname\n'modus wie in ACCESS: acNORMAL, acHIDDEN, acICON, AcDIALOG\n\nDoCmd.OpenForm frmName, , , , , Modus\n\nEnd Function\n\nFunction TabTempLosesch()\n\n    On Error Resume Next\n    \n    DoCmd.SetWarnings False\n    DoCmd.DeleteObject acTable, \"tblBeispiel\"\n    DoCmd.DeleteObject acTable, \"tblTest1\"\n    DoCmd.DeleteObject acTable, \"tblTest2\"\n    DoCmd.SetWarnings True\n\nEnd Function\n\n\n'''''''''''''''''''''''''''''''''\n'Separate Funktion, um eine einzelne Tabelle von einer MDB sicher einzubinden\n'''''''''''''''''''''''''''''''''\nFunction CopyUsr_verb(ByVal xtbl As String, ByVal xdb As String, Optional XPasswd As String = \"\", Optional ByVal NeuTabNam As String) As Boolean\n'\n' Parameter: xtbl = Einzubindende Tabelle\n'            xdb = Fremde mdb\n'            XPasswd = Datenbankpasswort\n'            NeuTabNam = abweichender neuer Tabellenname\n'\n' Wenn kein \"\\\" in xdb vorhanden ist, muss die xdb im gleichen Directory wie die \"current\" mdb stehen\n' Optional kann ein Passwort mitgegeben werden sowie ein neuer Name für die Tabelle\n'\n' Beispiele:\n' CopyUsr_verb(\"tblBearbeiter\",\"Hugo.mdb\")\n' CopyUsr_verb(\"tblBearbeiter\",\"C:\\Hugo\\Hugo.mdb\")\n' CopyUsr_verb(\"tblBearbeiter\",\"Hugo.mdb\",\"Hugo\")\n' CopyUsr_verb(\"tblBearbeiter\",\"C:\\Hugo\\Hugo.mdb\",\"Hugo\",\"tblHugo\") 'Als Tabelle mit Namen tblHugo\n'\nDim db As DAO.Database\nDim Daten As String\nDim i As Integer\n\nDim mytable As TableDef\n'----------------------------------------\nCopyUsr_verb = False\n\nOn Error Resume Next\n'Wenn kein anderer Name gewünscht, den gleichen Namen verwenden\nIf Len(Trim(Nz(NeuTabNam))) = 0 Then\n    NeuTabNam = xtbl\nEnd If\n\n'Bestehende Verbindung löschen\nDoCmd.DeleteObject acTable, NeuTabNam\n\nOn Error GoTo FehlerMeldung\n      \nSet db = CurrentDb()\nSet mytable = db.CreateTableDef(NeuTabNam)\n\nmytable.SourceTableName = xtbl\n\nIf InStr(1, xdb, \"\\\", vbBinaryCompare) > 0 Then\n    Daten = xdb\nElse\n    Daten = Left(db.Name, Len(db.Name) - Len(Dir(db.Name))) & xdb\nEnd If\n\nIf Len(Trim(Nz(XPasswd))) > 0 Then\n    mytable.connect = \";PWD=\" & XPasswd & \";\" & \";DATABASE=\" & Daten\nElse\n    mytable.connect = \";DATABASE=\" & Daten\nEnd If\n\ndb.TableDefs.append mytable\n\nSet db = Nothing\nCopyUsr_verb = True\n\nExit Function\nFehlerMeldung:\nCopyUsr_verb = False\nMsgBox \"Bei der Einbindung von \" & xtbl & \" ist ein Fehler aufgetreten. \", 16, xdb & \" - Fehler\"\nEnd Function"}
