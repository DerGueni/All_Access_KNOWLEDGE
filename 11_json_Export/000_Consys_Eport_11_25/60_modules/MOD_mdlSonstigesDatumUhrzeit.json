{"id":"MOD_mdlSonstigesDatumUhrzeit","name":"mdlSonstigesDatumUhrzeit","kind":"standard","procedures":["Function WieAlt(Geburtsdatum As Date) As Variant","Function istSchaltjahr(iJahr As Long) As Boolean","Function DateTest(XDatum As Date) As Double","Function CDateTime(ByVal XDatStr As String) As Date","Function ErsterDesMonats(Optional ByVal XDatum) As Date","Function LetzterDesMonats(Optional ByVal XDatum) As Date","Function XTage(Datum As Date, TAG As Byte)","Public Function fctKWMonJJJJWW(JJKW As Long) As Date","Public Function fctKWMon(ArgKW As Long, Optional ArgJahr) As Date","Function NextDay(ZDay As Integer, Optional ByVal XDatum) As Date","Function PreviousDay(ZDay As Integer, Optional ByVal XDatum) As Date","Function MaxWeekNo(XYear As Variant)","Function WeekFmt(Optional ByVal XDatum) As String","Function SQLDatum(Datumx) As String","Function DateTimeForSQL(dteDate) As String","Function SQLDatum_TSQL(Datumx) As String","Function DateTimeForSQL_TSQL(Datumx) As String","Function SQLDatum_Long(Datumx) As Long","Function datumText(XDatum, XText As String) As String","Function DatumPrf(ByVal GebDat As Variant, Optional OhneJahr As _","Function WochentagImMonat(Optional ByVal XDatum, Optional ByVal WelchMontag As Integer = 1, Optional ByVal WelchWochentag As Integer = 1) As Date","Function Julian2Date(JulianDate As String) As Date","Function Date2Julian(Datum As Date) As String","Function Zeitquarter(TTime As Date) As Date","Public Function Zeitrunden(Zeit As Variant, fzf As Byte)","Public Function StundenAusgabe(Datum As Double) As String","Function TierKZ(XDatum As Date) As String","Function jahreszeit(dtm_tag As Date) As String","Function DateDiffW(ByVal BegDate As Date, EndDate As Date)","Function AnzWochenTage(ByVal datBeginn As Date, ByVal datEnde As Date) As Long","Function fktIstWochenende(XDatum As Date) As Boolean","Function Werktag7h(Start As Date, Dauer As Date) As Date","Function Test_Werktag7h() As Date","Private Function GetBitValue(nIndex As Long, BitArray As Long) As Boolean","Function create_Default_AlleTage(strBundesland As String)","Function fktAnzWerktageVariabel(DatumVon As Date, DatumBis As Date, Bundesland As String, WerktageNr As Long) As Long","Function fktAnzWerktage(DatumVon As Date, DatumBis As Date, Bundesland As String) As Long","Function fktAnzFeiertage(DatumVon As Date, DatumBis As Date, Bundesland As String) As Long","Function fktIstWerktag(XDatum As Date, Bundesland As String) As Boolean","Function fktWelcherFeiertag(XDatum As Date, Bundesland As String) As String","Function Bundeslandtest(ByVal BundeslandID As String) As Boolean","Function BundeslandName(ByVal BundeslandID As String) As String","Function CreateTblWerktag(VonJahr As Integer, BisJahr As Integer, Bundesland As String, Optional WerkNrx As String = \"Std\", Optional tblLoesch As Boolean = True) As Boolean","Function OsterSonntagDatum(Jahr) As Date","Function VierterAdvent(Jahr As Variant) As Date","Function BusstagDatum(Jahr As Variant) As Date","Function dblZt(sWert As String) As Date","Function ZeitNachDouble(Sek1 As Double, Min As Long, std As Long, TAG As Long) As Double","Function DoubleNachZeit(Art, WertSekunden As Double, Restsekunden As Double, Minuten As Long, stunden As Long, Tage As Long) As Boolean","Function ZeitTest()","Public Function LongZuZeit(z As Long) As Date","Function Datumsetzen1(X As control, ByVal Y)","Function Datumsetzen2(X As control, ByVal Y)","Function Datum_Neuaufbau(xFrm As Form, XAktDat As Date)","Function FeiertageimMonat(XDatum As Date, XBund As String, Feianz As Integer, xdat() As Date, XDatNam() As String)","Function Mondphase_Prom(Optional ByVal XDatum As Date) As Integer","Function Mondphase(Optional ByVal XDatum As Date, Optional AlsZahl As Boolean = True) As Variant","Function Mp_Tst1(Optional ByVal XDatum As Date, Optional j As Integer = 99)","Function Mp_Tst2(Optional ByVal XDatum As Date, Optional ByVal j As Integer = 99)","Function Tage360(ByVal StartDatum As Date, ByVal EndDatum As Date) As Long","Function RandomDatum(Optional ByVal JahrVon As Long = 1900, Optional ByVal Jahrbis As Long = 2010, Optional ByVal MonVon = 1, Optional ByVal MonBis = 12, Optional ByVal NurWerktage As Boolean = False) As Date","Function fWeekNos(Optional StartDate, Optional lng_MaxWeek As Long = 217)","Function fYrweekNo(ByVal X As Date, Optional ByVal Y As Long = 0) As Long","Function TestAufMontag()","Function TestAufSonntag()","Function TestWochenAnfangEnde(ByVal WochentagsNr As Long)","Function TestWochenAnfangEndeDate(ByVal X As Date, Optional ByVal WochentagsNr As Long = 0) As Date","Function WochenMo(X As Variant) As Date","Function WochenMo4(X As Variant) As Date","Function WochenMo4X(X As Variant) As Date","Function KWDiffber0(StartKW As Long, EndKW As Long) As Long","Function KWDiffber1(StartKW As Long, EndKW As Long, GesAnzKW As Long) As Long","Function fYrweekNoPretty(X As Date) As Variant","Function HW_GibNr(JJJJKW As Long) As Long","Function HWDat_GibNr(X As Date) As Long","Function HW_GibKW(LfdNr As Long) As Long","Function HW_GibJJ(LfdNr As Long) As Long","Function HW_GibDat(LfdNr As Long) As Date","Function IsLeapYear(dt As Date) As Boolean","Function HWL_GibXlNr(JJJJKW As Long) As Long","Function HWLDat_GibXLNr(X As Date) As Long","Public Function LaufMon2DateMon(iMon As Long, Optional istartJahr As Long = 0, Optional istartMon As Long = 0) As Date","Public Function DateMon2LaufMon(iMon As Long, Optional istartJahr As Long = 0, Optional istartMon As Long = 0) As Date","Public Function btn2Date(btnName As String, Optional istartJahr As Long = 0, Optional istartMon As Long = 0) As Date","Public Function Date2btn(btnDatum As Date, Optional istartJahr As Long = 0, Optional istartMon As Long = 0) As String","Function StdZeitraum_Von_Bis(Zeitraum As Long, Me_vonDat As Date, Me_bisDat As Date)"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\n'#######################################################################################\n' ALLE Datumsfunktionen vereinheitlicht, so daß bei Bedarf der Wochentag einheitlich den\n' Wert von Tag 1 = Montag, 2 = Dienstag, ... 7 = Sonntag\n' repräsentiert!!!!!!\n'#######################################################################################\n\n'   fctKWMon            - Mo der Kalenderwoche input: WW, JJJJJ\n'   fctKWMonJJJJWW      - Mo der Kalenderwoche Input: JJJJWW\n'   WieAlt              - Anzahl Jahre seit Geburt\n'   IstSchaltjahr       - Schaltjahr ja/Nein\n'   DateTest            - Datum als Double ausgeben\n'   CDateTime           - macht aus dem String # 11-Apr-1999 19:42 AM # einen Datumswert\n'   ErsterDesMonats     - Erster Tag des Monats eines Datums\n'   LetzterDesMonats    - Letzten Tag des Monats eines Datums\n'   XTage               - liefert die Anzahl eines Wochentages im Monat des beliebigen Datums\n'   fctKWMon            - gibt den Montag der übergebenen KW zurück - nur europäisches Datum\n'   NextDay             - Ausgabe des nächsten Wochentages ZDay, ausgehend von XDatum\n'   PreviousDay         - Ausgabe des vorherigen Wochentages ZDay, ausgehend von XDatum\n'   MaxWeekNo           - Die Anzahl Wochen des Jahres bzw. die höchste Wochennummer des Jahres\n'   WeekFmt             - Rückgabe eines Datums im Format ww/jjjj\n'   SQLDatum            - Macht aus irgendeinem gültigen Datum einen String #yyyy-mm-dd# (ISO-Norm Datum)\n'   SQLDatum_Long       - Macht aus irgendeinem gültigen Datum einen Long-Wert YYYYMMDD )für AlleTageTabelle)\n'   SQLDatum_TSQL       - Macht aus irgendeinem gültigen Datum einen String 'yyyymmdd' (ISO-Norm Datum mit Hochkomma)\n'   DateTimeForSQL_TSQL - Macht aus irgendeinem gültigen Datum einen String 'yyyymmdd hh:nn:ss' (ISO-Norm Datum Uhrzeit mit Hochkomma)\n'   DateTimeForSQL      - Macht aus irgendeinem gültigen Datum einen String #yyyy-mm-dd hh:mm:ss AM/PM#\n'   Datumtext           - Funktion gibt bei gültigem Datum das Datum ansonsten einen Text zurück\n'   DatumPrf            - Prüft, ob ein Datum zwischen zwei Datumswerten liegt\n'   WochentagImMonat    - Gibt den 1. 2. 3. 4. letzten (5) Wochentag eines Datums zurück\n'   Julian2Date         - Umrechnung eines Strings in der Form JJttt oder JJJJttt in ein Datum\n'   Date2Julian         - Umrechnung eines Datums zu einem String in der Form JJttt\n'   Zeitquarter         - Wie kann ich in einem Feld die nächste Viertelstunde berechnen lassen?\n'   Zeitrunden          - Runden einer Zeit\n'   StundenAusgabe      - Ausgabe Anzahl Stunden > 24 als Stunden (ohne Umrechnung in Tage)\n'   TierKZ              - Das TierKreiszeichen eines bestimmten Datums\n'   Jahreszeit          - Gibt die Jahreszeit eines Datums zurück\n'   DateDiffW           - Anzahl der Werktage ohne Samstag und ohne Sonntag (OHNE Feiertagsberücksichtigung) - 1\n'   AnzWochenTage       - Anzahl der Werktage ohne Samstag und ohne Sonntag (OHNE Feiertagsberücksichtigung)\n'   fktIstWochenende    - Ist Wochenende ?\n'   Werktag7h           - Wie lange dauert ein Auftrag, wenn die Arbeitszeit 7 h beträgt ?\n'   Test_Werktag7h      - Test der Funktion\n'   fktAnzWerktage      - Anzahl Werktage (MIT Feiertagsberücksichtigung - Bundeslandabhängig)\n'   fktAnzFeiertage     - Die Funktion ermittelt die Anzahl der Feiertage (Mo - Fr - Bundeslandabhängig)\n'   fktIstWerktag       - Ist Datum ein Werktag (MIT Feiertagsberücksichtigung - Bundeslandabhängig)\n'   fktWelcherFeiertag  - Ausgabe des Feiertagsnamens (oder \"\") - Bundeslandabhängig - auch bei Wochenenden\n'   CreateTblWerktag    - Tabelle mit Werktagen erzeugen\n'   OsterSonntagDatum   - Ermittelt den Ostersonntag für ein bestimmtes Jahr\n'   VierterAdvent       - Ermittelt den 4. Advent für ein bestimmtes Jahr\n'   BusstagDatum        - Ermittelt den Buß- und Bettag für ein bestimmtes Jahr\n'   ZeitNachDouble      - etwas komplizierte Zeitrechnung ohne Datumsfunktionen (Zehntelsekunden)\n'   DoubleNachZeit      - etwas komplizierte Zeitrechnung ohne Datumsfunktionen (Zehntelsekunden)\n'   LongZuZeit          - Sekunden as Long in Zeit umrechnen ...\n'   ZeitTest            - Test dieser Funktionen (war früher mdlDatumZeit)\n'   IsDateBetween2Dates - Siehe Modul SonstigesJaNein - Ist Datum innerhalb des Zeitraums\n'########### Kalenderfunktionen speziell für frmKalender (verwenden viele Standard-Datumsfunktionen)\n'   create_Default_AlleTage(strBundesland As String)  - Abfrage \"qryAlleTage_Default\" mit ausgewähltem Bundesland\n'   Datumsetzen1\n'   Datum_Neuaufbau\n'   Datumsetzen2\n'   FeiertageimMonat\n'########### Mondphasenberechnung\n'   Mondphase_Prom      - Mondphase als 1000-er Zahl (Promille) 0 = Vollmond, 500 = Neumond, 1000 = Vollmond\n'   Mondphase           - Mondphase als Text oder Zahl zwischen 1 und 8 (für Bilder in frmKalender)\n\n'   Tage360             - 360-Tageberechnung nach Bankregel\n\n'   fYrweekNo           - Gibt JJJJWW zurück (immer 6-stellig)\n'#######################################################################################\n\nPublic Global_AufrufCtrl As control\nPublic Global_PrevCtrl As control\n\nPublic Global_iMinute As Long\nPublic Global_iStunde As Long\n\nPublic allWeekNo()\nPublic allMonNo()\nPublic allJahrNo()\nPublic allJahrWeekNo()\n\n\n'Global_PrevCtrl wird anstelle von PreviousControl verwendet, da PreviousControl hier nicht klappt\n'warum weiss ich nicht\n'Es wird für den frmKalender benötigt\n'Global_AufrufCtrl wird für den frmKalender benötigt\n'damit man einfach auch in Unterformularen den Kalender aufrufen kann\n\nFunction WieAlt(Geburtsdatum As Date) As Variant\n'Dev Ahish\nWieAlt = DateDiff(\"yyyy\", Geburtsdatum, Date) + (Format(Date, \"mmdd\") < Format(Geburtsdatum, \"mmdd\"))\nEnd Function\n\n\nFunction istSchaltjahr(iJahr As Long) As Boolean\nIf iJahr < 1900 Then iJahr = year(Date)\nistSchaltjahr = 365 - Format(DateSerial(iJahr, 12, 31), \"y\", 2, 2)\nEnd Function\n\n\nFunction DateTest(XDatum As Date) As Double\nDateTest = XDatum\nEnd Function\n\nFunction CDateTime(ByVal XDatStr As String) As Date\n'Macht aus einem String der Art #27-Mai-1999 4:29:54 AM # einen Datumswert\nDim xx\nxx = XDatStr\nIf Left(xx, 1) = \"#\" Then xx = Right(xx, Len(xx) - 1)\nIf Right(xx, 1) = \"#\" Then xx = Left(xx, Len(xx) - 1)\nCDateTime = CDate(xx)\nEnd Function\n\nFunction ErsterDesMonats(Optional ByVal XDatum) As Date\n'Gibt den ersten Tag des Monats des übergebenen Datums zurück\n'Wenn kein oder ein ungültiges Datum übergeben wurde, dann der Erste des aktuellen Monats\n'Autor: Klaus Oberdalhoff  Kobd@gmx.de\n\nIf IsMissing(XDatum) Then\n    XDatum = Date\nEnd If\n\nIf Not IsDate(XDatum) Then\n    XDatum = Date\nEnd If\n\nErsterDesMonats = DateSerial(year(XDatum), Month(XDatum), 1)\n\nEnd Function\n\nFunction LetzterDesMonats(Optional ByVal XDatum) As Date\n'Gibt den letzten Tag des Monats des übergebenen Datums zurück\n'Wenn kein oder ein ungültiges Datum übergeben wurde, dann der Letzte des aktuellen Monats\n'Autor: Klaus Oberdalhoff  Kobd@gmx.de\n\nIf IsMissing(XDatum) Then\n    XDatum = Date\nEnd If\n\nIf Not IsDate(XDatum) Then\n    XDatum = Date\nEnd If\n\nLetzterDesMonats = DateSerial(year(XDatum), Month(XDatum) + 1, 0)\n\nEnd Function\n\nFunction XTage(Datum As Date, TAG As Byte)\n'liefert die Anzahl eines Wochentages im Monat des beliebigen Datums\n'Wert von Tag 1 = Montag, 2 = Dienstag, ... 7 = Sonntag\n'von Günther Ritter gritter@gmx.de\nDim Tage As Byte, i As Byte\nTage = Day(DateAdd(\"m\", 1, Datum - Day(Datum) + 1) - 1)\nFor i = 0 To Tage - 1\n    If Weekday(DateAdd(\"d\", i, Datum - Day(Datum) + 1), vbMonday) = TAG Then\n        XTage = XTage + 1\n    End If\nNext\nEnd Function\n\nPublic Function fctKWMonJJJJWW(JJKW As Long) As Date\nDim i As Long\nDim j As Long\ni = Left(JJKW, 4)\nj = Right(JJKW, 2)\nfctKWMonJJJJWW = fctKWMon(j, i)\nEnd Function\n\nPublic Function fctKWMon(ArgKW As Long, Optional ArgJahr) As Date\n  'gibt den Montag der übergebenen Kalenderwoche zurück\n  'verwendet die in Europa übliche Einstellung: KW 1 = die erste mit 4 Tagen\n  'von Karl Donaubauer www.donkarl.com\n\n    Dim m As Date\n    If IsMissing(ArgJahr) Then ArgJahr = year(Date)\n    m = DateSerial(ArgJahr, 1, 1) + (ArgKW - 1) * 7\n    m = m + 1 - Weekday(m, vbMonday)\n    If Format(m, \"ww\", vbMonday, vbFirstFourDays) <> ArgKW Then m = m + 7\n    If (ArgKW = 1 Or ArgKW = 53) And Day(m) > 4 And Day(m) < 8 Then m = m - 7\n    fctKWMon = m\n\nEnd Function\n\n\nFunction NextDay(ZDay As Integer, Optional ByVal XDatum) As Date\n'von Jörg Ackermann  A-Soft.Ackermann@t-online.de\n'Ausgabe des nächsten Wochentages ZDay, ausgehend von XDatum wobei\n'Wert von Tag 1 = Montag, 2 = Dienstag, ... 7 = Sonntag\n'Debug.Print NextDay(3) liefert den nächsten Mittwoch von XDatum ausgehend\n'Wenn kein gültiges XDatum, dann XDatum = Heute\n'Wenn z.B. nach nächstem Mittwoch gesucht wird, und heute ist Mittwoch,\n'dann wird \"heute\" zurückgegeben\nDim i%, td\n\nIf IsMissing(XDatum) Then XDatum = Date\nIf Not IsDate(XDatum) Then XDatum = Date\n\nIf Weekday(XDatum, vbMonday) <> ZDay Then\n    For i = 1 To 7 Step 1\n         td = XDatum + i\n         If Weekday(td, vbMonday) = ZDay Then\n             NextDay = td\n             Exit For\n         End If\n    Next i\nElse\n    NextDay = XDatum\nEnd If\n\nEnd Function\n\nFunction PreviousDay(ZDay As Integer, Optional ByVal XDatum) As Date\n'von Jörg Ackermann  A-Soft.Ackermann@t-online.de ' angepaßt von K.Obd\n'Ausgabe des vorherigen Wochentages ZDay, ausgehend von XDatum wobei\n'Wert von Tag 1 = Montag, 2 = Dienstag, ... 7 = Sonntag\n'Debug.Print PreviousDay(3) liefert den letzten Mittwoch von XDatum ausgehend\n'Wenn kein gültiges XDatum, dann XDatum = Heute\n'Wenn z.B. nach letztem Mittwoch gesucht wird, und heute ist Mittwoch,\n'dann wird \"heute\" zurückgegeben\nDim i%, td\n      \nIf IsMissing(XDatum) Then XDatum = Date\nIf Not IsDate(XDatum) Then XDatum = Date\n\nIf Weekday(XDatum, vbMonday) <> ZDay Then\n    For i = -1 To -7 Step -1\n         td = XDatum + i\n         If Weekday(td, vbMonday) = ZDay Then\n             PreviousDay = td\n             Exit For\n         End If\n    Next i\nElse\n    PreviousDay = XDatum\nEnd If\n\nEnd Function\n\n\nFunction MaxWeekNo(XYear As Variant)\n'Die Anzahl Wochen des Jahres bzw. die höchste Wochennummer des Jahres\n'K.Obd\nMaxWeekNo = Format(DateSerial(XYear, 12, 28), \"ww\", vbMonday, vbFirstFourDays)\nEnd Function\n\nFunction WeekFmt(Optional ByVal XDatum) As String\n'Gibt Ein Datum als \"ww\\jjjj\" String zurück\n'Wenn eine Wochennummer in ein unterschiedliches Jahr fällt, so wird dies berücksichtigt\n'd.h. 31.12.2002 = 01\\2003 bzw. 1.1.1999 = 53\\1998\nDim X, Y, z\nWeekFmt = \"\"\nIf Not IsDate(XDatum) Then XDatum = Date\nXDatum = CDate(XDatum)\nX = year(XDatum)\nY = Month(XDatum)\nz = Format(XDatum, \"ww\", vbMonday, vbFirstFourDays)\nIf Y = 12 And z < 40 Then X = X + 1\nIf Y = 1 And z > 10 Then X = X - 1\nWeekFmt = Right(\"00\" & z, 2) & \"\\\" & Right(\"0000\" & X, 4)\nEnd Function\n\n\nFunction SQLDatum(Datumx) As String\n'Macht aus irgendeinem gültigen Datum einen String #yyyy-mm-dd# (ISO-Norm Datum)\nIf IsDate(Datumx) Then\n    SQLDatum = Format(CDate(Datumx), \"\\#yyyy\\-mm\\-dd\\#\", vbMonday, vbFirstFourDays)\nElse\n    SQLDatum = \"\"\nEnd If\nEnd Function\n\n\nFunction DateTimeForSQL(dteDate) As String\n'Datum incl. Uhrzeit für SQL und INI-Files als String\n  \n'  DateTimeForSQL = Format(CDate(dteDate), \"\\#yyyy\\-mm\\-dd h:nn:ss AM/PM \\#\", vbMonday, vbFirstFourDays)\n  DateTimeForSQL = Format(CDate(dteDate), \"\\#yyyy\\-mm\\-dd hh:nn:ss\\#\", vbMonday, vbFirstFourDays)\n\nEnd Function\n\nFunction SQLDatum_TSQL(Datumx) As String\n'   SQLDatum_TSQL       - Macht aus irgendeinem gültigen Datum einen String 'yyyymmdd' (ISO-Norm Datum mit Hochkomma)\nIf IsDate(Datumx) Then\n    SQLDatum_TSQL = \"'\" & year(Datumx) & Right(\"00\" & Month(Datumx), 2) & Right(\"00\" & Day(Datumx), 2) & \"'\"\nElse\n    SQLDatum_TSQL = \"\"\nEnd If\nEnd Function\n\nFunction DateTimeForSQL_TSQL(Datumx) As String\n'   DateTimeForSQL_TSQL - Macht aus irgendeinem gültigen Datum einen String 'yyyymmdd hh:nn:ss' (ISO-Norm Datum Uhrzeit mit Hochkomma)\nIf IsDate(Datumx) Then\n    DateTimeForSQL_TSQL = \"'\" & year(Datumx) & Right(\"00\" & Month(Datumx), 2) & Right(\"00\" & Day(Datumx), 2) & \" \" & Right(\"00\" & Hour(Datumx), 2) & \":\" & Right(\"00\" & minute(Datumx), 2) & \":\" & Right(\"00\" & Second(Datumx), 2) & \"'\"\nElse\n    DateTimeForSQL_TSQL = \"\"\nEnd If\nEnd Function\n\n\nFunction SQLDatum_Long(Datumx) As Long\n'Macht aus irgendeinem gültigen Datum einen Long-Wert YYYYMMDD\nIf IsDate(Datumx) Then\n    SQLDatum_Long = (year(Datumx) * 10000) + (Month(Datumx) * 100) + Day(Datumx)\nElse\n    SQLDatum_Long = 0\nEnd If\nEnd Function\n\n\nFunction datumText(XDatum, XText As String) As String\n'Funktion gibt bei gültigem Datum das Datum ansonsten einen Text zurück\n'Autor: Klaus Oberdalhoff\nIf Len(Trim(Nz(XDatum))) = 0 Or Not IsDate(XDatum) Then\n    datumText = XText\nElse\n    datumText = CStr(Format(CDate(XDatum), \"dd.mm.yyyy\", vbMonday, vbFirstFourDays))\nEnd If\n\nEnd Function\n\nFunction DatumPrf(ByVal GebDat As Variant, Optional OhneJahr As _\n         Boolean = True, Optional ByVal HeutDat As Date, Optional _\n         ByVal MinusX As Integer = 7, Optional ByVal PlusX As _\n         Integer = 15) As Boolean\nOn Error GoTo Err_DatumPrf\n    \n'Autor: Kurt Grof, nach einer Idee von KObd ...\n'Prüft, ob das Datum zwischen zwei Datumswerten liegt, gedacht um das lästige Geburtstagsprüfumgsproblem\n'zu beseitigen.\n\n'=========\n\n'Es wird nur geprüft ob der Vergleichswert (GebDat)\n'sich in einem Zeitkorridor zwischen\n'HeutDat - MinuxX(tage)\n'    UND\n'HeutDat + PlusX(tage)\n'\n'befindet. Wenn ja, True, sonst False\n\n'Angenommener Fall 1: Datum im Datenfeld GebDat ist der 19.1\n'\n'Dann wäre\n'\n'HeutDat + 15 der 3.2 (sowas in der Art)\n'UND\n'HeutDat-7 der 10.1.\n'\n'Ist GebDat >= 10.1. Und GebDat <= 3.2\n'\n'GebDat ist größer als der 10.1 und kleiner als der 3.2\n'ALso --> True\n'\n'Angenommener Fall 2: Datum im Datenfeld GebDat ist der 19.3\n'\n'Dann wäre\n'\n'HeutDat + 15 der 3.2 (sowas in der Art)\n'UND\n'HeutDat-7 der 10.1.\n'\n'Ist GebDat >= 10.1. Und GebDat <= 3.2\n'\n'GebDat ist größer als der 10.1 und größer als der 3.2\n'Also --> False\n\n'===========\n\n'GebDat ist so definiert, um bei Übergabe eines leeren Datums an eine Abfrage die Rückgabe \"#Fehler\" zu vermeiden sondern 0 zurückzugeben.\n\n'Eingabe für Geburtstagsvergleich (ohne Jahresvergleich): Wenn die 7 Tage zurück und die 15 Tage vor OK sind:\n'HatGeburtstag = DatumPrf(Gebdatum)\n\n'Eingabe für Wiedervorlage (mit Jahresvergleich): Wenn die 7 Tage zurück und die 15 Tage vor OK sind:\n'IstWV = DatumPrf(WVDat, False)\n\n'Optional kann man auch die Anzahl Tage MinusX und PlusX verändern. Es werden immer die Absolutwerte verwendet.\n'IstWV = DatumPrf(WVDat, False, Date(), 10, 22)\n'HatGeburtstag = DatumPrf(Gebdatum, True, , 0, 30)\n\n'Rückgabe True, das Datum liegt in dem zu prüfenden Zeitraum\n'Rückgabe False, wenn nicht\n    \n    Dim vonDat As Date, bisDat As Date\n    DatumPrf = False\n    \n    If IsDate(GebDat) Then\n        If GebDat = 0 Then\n            GoTo Err_DatumPrf\n        Else\n            GebDat = CDate(GebDat)\n        End If\n    Else\n        GoTo Err_DatumPrf\n    End If\n\n    If IsDate(HeutDat) Then\n        If HeutDat = 0 Then\n            HeutDat = Date\n        Else\n            HeutDat = CDate(HeutDat)\n        End If\n    Else\n        GoTo Err_DatumPrf\n    End If\n\n    MinusX = -Abs(MinusX)\n    PlusX = Abs(PlusX)\n    \n    vonDat = DateAdd(\"d\", MinusX, HeutDat)\n    bisDat = DateAdd(\"d\", PlusX, HeutDat)\n    \n    If OhneJahr Then\n        GebDat = DateSerial(year(vonDat), Month(GebDat), Day(GebDat))\n        If GebDat >= vonDat And GebDat <= bisDat Then\n            DatumPrf = True\n        Else\n            GebDat = DateSerial(year(bisDat), Month(GebDat), Day(GebDat))\n            DatumPrf = (GebDat >= vonDat And GebDat <= bisDat)\n        End If\n    Else\n         DatumPrf = (GebDat >= vonDat And GebDat <= bisDat)\n    End If\n\nExit_DatumPrf:\n    Exit Function\n    \nErr_DatumPrf:\n'    MsgBox \"Datumsprüfung - Fehler\" & Str$(err.Number) & \": \" & err.Description\n    DatumPrf = False\n    Resume Exit_DatumPrf\n    \nEnd Function\n\nFunction WochentagImMonat(Optional ByVal XDatum, Optional ByVal WelchMontag As Integer = 1, Optional ByVal WelchWochentag As Integer = 1) As Date\n\n'Gibt den ersten, zweiten, dritten, vierten, oder letzten (Parameter WelchMontag)\n'Wochentag (Parameter WelchWochentag) eines Datums(Parameter XDatum) zurück\n'Für englische Feiertagsberechnung (erster / letzter Montag im Monat) ...\n'Oder für Kalenderfunktionen (Besprechung immer am 3. Dienstag im Monat)\n\n'WelchWochentag 1 = Montag, ... 7 = Sonntag\n'Welchmontag 1 bis 4, dann 1.2.3.4 Tag im Monat\n'WelchMontag > 4 dann letzter Montag im Monat\n\n'Benötigt die Functions: PreviousDay, Nextday, ErsterDesMonats, LetzterDesMonats\n\nDim i As Integer\n\nIf IsMissing(XDatum) Then XDatum = Date\nIf Not IsDate(XDatum) Then XDatum = Date\n\nIf WelchWochentag < 1 Or WelchWochentag > 7 Then\n    WelchWochentag = 1 'Bei Fehler = Montag\nEnd If\n\nIf WelchMontag > 4 Then\n    WochentagImMonat = PreviousDay(WelchWochentag, LetzterDesMonats(XDatum))\nElse\n    WochentagImMonat = ErsterDesMonats(XDatum) - 1\n    For i = 1 To WelchMontag\n        WochentagImMonat = NextDay(WelchWochentag, (WochentagImMonat + 1))\n    Next i\nEnd If\n\nEnd Function\n\n\nFunction Julian2Date(JulianDate As String) As Date\n'Umrechnung eines Strings in der Form JJttt oder JJJJttt in ein Datum\n   Dim X As Integer, Y1\n   If Len(JulianDate) = 7 Then\n       Y1 = Left(JulianDate, 4)         ' Jahreszahl 4-stellig\n   Else\n       Y1 = Left(JulianDate, 2)                 ' Jahreszahl 2-stellig\n   End If\n   X = Format(\"1. Januar \" & Y1, \"yyyy\")    ' Access bestimmt das Jahrtausend\n   X = (X \\ 100) * 100\n   Julian2Date = DateSerial(X + Int(JulianDate / 1000), 1, JulianDate Mod 1000)\nEnd Function\n\nFunction Date2Julian(Datum As Date) As String\n'Umrechnung eines Datums zu einem String in der Form JJttt\nDim tmp\ntmp = Format(Datum, \"y\")\ntmp = Right(\"000\" & tmp, 3)\n    Date2Julian = Format(Datum, \"yy\") & tmp\nEnd Function\n\nFunction Zeitquarter(TTime As Date) As Date\n\n'Autor: Oliver Weitmann\n'Wie kann ich in einem Feld die nächste Viertelstunde berechnen lassen? Wenn\n'z.B. in einem anderen Feld 07:16 steht, soll in dem berechneten Feld 07:30\n'stehen.\n'\nDim t As Date\nt = TTime\nZeitquarter = CDate(TimeSerial(Hour(t), ((minute(t) \\ 15) + 1) * 15, Second(t)))\n\n'Hier wird die Systemzeit in t abgelegt, du kannst hier deine eigene\n'Zeitinformation ablegen. Wenn du immer nur 0 Sekunden haben möchtest,\n'gebe bitte beim 3 Parameter von TimeSerial anstatt Second(t) einfach 0\n'an.\n'\nEnd Function\n\n\nPublic Function Zeitrunden(Zeit As Variant, fzf As Byte)\n'Autor: Sönke Petersen\n'Fortuna.pes@t-online.de\n    \n'Wie kann ich eine Zeit auf / 10 Min / eine Viertelstunde / runden ?\n    \n'Zeit im Format hh:mm:ss\n'fzf = 5, 10, 15 oder 30\n    \n    Dim h, i, j As Integer\n    Dim d As Variant\n    i = Mid(Zeit, 4, 2)\n    i = i / 1\n    j = i Mod fzf\n    h = Mid(Zeit, 1, 2)\n    h = h / 1\n    If (j / fzf) < 0.5 Then\n        d = Mid(str(i - j), 2, 2)\n        If Len(d) = 1 Then\n            d = \"0\" + d\n        End If\n        If d = \"60\" Then\n            d = \"00\"\n            h = h + 1\n        End If\n        Zeitrunden = str(h) + \":\" + d + (Mid(Zeit, 6, 3))\n    End If\n    If (j / fzf) >= 0.5 Then\n        d = Mid(str(i + (fzf - j)), 2, 2)\n        If Len(d) = 1 Then\n            d = \"0\" + d\n        End If\n        If d = \"60\" Then\n            d = \"00\"\n            h = h + 1\n        End If\n        Zeitrunden = str(h) + \":\" + d + Mid(Zeit, 6, 3)\n    End If\nEnd Function\n\n    \nPublic Function StundenAusgabe(Datum As Double) As String\n'Von: Roland Sommer <r.sommer@gmx.de> Ausgabe Anzahl Stunden > 24\n'In deinem Bericht muß jetzt diese Funktion rein, z.b. =Stundenausgabe([Datum]) oder =Stundenausgabe([Enddatum] - [Anfangsdatum])\n'Siehe Beispiel frmStandzeiten\nStundenAusgabe = Format$(Sgn(Datum) * Int(Abs(Datum * 24)), \"0\") & \":\" & Format$(Datum, \"nn\")\nEnd Function\n\n\nFunction TierKZ(XDatum As Date) As String\n'von Manfred Wesemann@MAUS-OL\n    '----Name        Lateinisch     von    bis\n    '-------------------------------------------\n    '--- Widder     (Aries)         21.03.-20.04.\n    '--- Stier      (Taurus)        21.04.-20.05.\n    '--- Zwillinge  (Gemini)        21.05.-21.06.\n    '--- Krebs      (Cancer)        22.06.-22.07.\n    '--- Löwe       (Leo)           23.07.-23.08.\n    '--- Jungfrau   (Virgo)         24.08.-23.09.\n    '--- Waage      (Libra)         24.09.-23.10.\n    '--- Skorpion   (Skorpius)      24.10.-22.11.\n    '--- Schütze    (Sagittarius)   23.11.-22.12.\n    '--- Steinbock  (Capricornus)   23.12.-20.01.\n    '--- Wassermann (Aquarius)      21.01.-19.02.\n    '--- Fische     (Pisces)        20.02.-20.03.\n'Hier eine Prozedur zur Berechnung des Tierkreiszeichen (TierKZ)\n'Leicht abgeändert zur leichteren Benutzung KObd\nDim X\nDim Y\n\nIf (Not IsDate(XDatum)) Or (XDatum = 0) Then  'Wenn falsches Datum dann Heute\n    X = Day(Date)\n    Y = Month(Date)\nElse\n    X = Day(XDatum)\n    Y = Month(XDatum)\nEnd If\n\nIf (X > 20 And Y = 3) Or (X < 21 And Y = 4) Then\nTierKZ = \"Widder\"\nElseIf (X > 20 And Y = 4) Or (X < 21 And Y = 5) Then\nTierKZ = \"Stier\"\nElseIf (X > 20 And Y = 5) Or (X < 22 And Y = 6) Then\nTierKZ = \"Zwilling\"\nElseIf (X > 21 And Y = 6) Or (X < 23 And Y = 7) Then\nTierKZ = \"Krebs\"\nElseIf (X > 22 And Y = 7) Or (X < 24 And Y = 8) Then\nTierKZ = \"Löwe\"\nElseIf (X > 23 And Y = 8) Or (X < 24 And Y = 9) Then\nTierKZ = \"Jungfrau\"\nElseIf (X > 23 And Y = 9) Or (X < 24 And Y = 10) Then\nTierKZ = \"Waage\"\nElseIf (X > 23 And Y = 10) Or (X < 23 And Y = 11) Then\nTierKZ = \"Skorpion\"\nElseIf (X > 22 And Y = 11) Or (X < 22 And Y = 12) Then\nTierKZ = \"Schütze\"\nElseIf (X > 21 And Y = 12) Or (X < 21 And Y = 1) Then\nTierKZ = \"Steinbock\"\nElseIf (X > 20 And Y = 1) Or (X < 20 And Y = 2) Then\nTierKZ = \"Wassermann\"\nElseIf (X > 19 And Y = 2) Or (X < 21 And Y = 3) Then\nTierKZ = \"Fische\"\nEnd If\n\nEnd Function\n\nFunction jahreszeit(dtm_tag As Date) As String\n\n    '-------------------------------------------------------------------\n    '--- modul for MS-Access97 and MS-Access2000: version 1998/12/22\n    '--- Josef Syrovatka\n    '-------------------------------------------------------------------\n\n    '--- Errechnet aus einem Datum die zugehörige Jahreszeit\n    Dim lng_monat As Long, lng_tag As Long\n\n    jahreszeit = \"?\"\n\n    lng_monat = Month(dtm_tag)\n    lng_tag = Day(dtm_tag)\n\n    '--- Frühling 21.03.-20.06.\n    '--- Sommer   21.06.-22.09.\n    '--- Herbst   23.09.-21.12.\n    '--- Winter   22.12.-20.03.\n\n    If lng_monat = 0 Or IsNull(lng_monat) Then Exit Function\n    If lng_tag = 0 Or IsNull(lng_tag) Then Exit Function\n\n    Select Case lng_monat\n        Case 1, 2: jahreszeit = \"Winter\"\n        Case 3: If lng_tag <= 20 Then jahreszeit = \"Winter\" Else jahreszeit = \"Frühling\"\n        Case 4, 5: jahreszeit = \"Frühling\"\n        Case 6: If lng_tag <= 20 Then jahreszeit = \"Frühling\" Else jahreszeit = \"Sommer\"\n        Case 7, 8: jahreszeit = \"Sommer\"\n        Case 9: If lng_tag <= 22 Then jahreszeit = \"Sommer\" Else jahreszeit = \"Herbst\"\n        Case 10, 11: jahreszeit = \"Herbst\"\n        Case 12: If lng_tag <= 21 Then jahreszeit = \"Herbst\" Else jahreszeit = \"Winter\"\n    End Select\n\nEnd Function\n\n\n Function DateDiffW(ByVal BegDate As Date, EndDate As Date)\n'War vorher im Modul mdlDateDiffW\n'PSS ID Number: Q95977\n'Article last modified on 08-29-1997\n'The following code provides a function, DateDiffW(), that calculates\n'the number of work days between two dates:\n'\n'How to Use the DateDiffW() Function\n'-----------------------------------\n'\n'Use the DateDiffW() function wherever you would use DateDiff(). Instead of\n'\n'   DateDiff(\"W\",[StartDate],[EndDate])\n'\n'use the following:\n'\n'   DateDiffW([StartDate],[EndDate])\n'\n'NOTE: This function returns the days UP TO the ending date, not UP TO and\n'INCLUDING the ending date.\n'One less than AnzWochenTage\n\n'   Anzahl Werktage (ohne Feiertage) zwischen zwei Tagen\n      Const SUNDAY = 1\n      Const SATURDAY = 7\n      Dim NumWeeks As Integer\n \n      If BegDate > EndDate Then\n         DateDiffW = 0\n      Else\n         Select Case Weekday(BegDate)\n            Case SUNDAY: BegDate = BegDate + 1\n            Case SATURDAY: BegDate = BegDate + 2\n         End Select\n         Select Case Weekday(EndDate)\n            Case SUNDAY: EndDate = EndDate - 2\n            Case SATURDAY: EndDate = EndDate - 1\n         End Select\n         NumWeeks = DateDiff(\"ww\", BegDate, EndDate)\n         DateDiffW = NumWeeks * 5 + Weekday(EndDate) - Weekday(BegDate)\n      End If\n   End Function\n \n\nFunction AnzWochenTage(ByVal datBeginn As Date, ByVal datEnde As Date) As Long\n'von Urs Villiger\n'Anzahl der Werktage ohne Samstag und ohne Sonntag (ohne Feiertagsberücksichtigung)\n  AnzWochenTage = DateDiff(\"d\", datBeginn, datEnde) - DateDiff(\"ww\", datBeginn, datEnde) _\n  * 2 + 1 + (Weekday(datBeginn) = 1) + (Weekday(datEnde) = 7)\nEnd Function\n\n\nFunction fktIstWochenende(XDatum As Date) As Boolean\nIf Weekday(XDatum, vbMonday) > 5 Then\n    fktIstWochenende = True\nElse\n    fktIstWochenende = False\nEnd If\nEnd Function\n\nFunction Werktag7h(Start As Date, Dauer As Date) As Date\n'Autor: Wolfgang Flamme\n'wflamme@mainz-online.de\n\n'Aufgabe:\n'innerhalb einer Abfrage stehen mir folgende Daten zur Verfügung\n'\n'Auftrag                   Dauer (hh:nn)\n'A                           05:50\n'B                           01:50\n'C                           35:00\n'D                           16:00\n'E                            08:00  etc.\n'\n'Ich möchte nun die Aufträge so darstellen, daß jedem Tag 7 Stunden zur\n'Verfügung stehen (d.h. ein Auftrag muß auch getrennt werden können), zudem\n'sollen\n'alle Sa+So+Feiertage ausgespart werden.\n'\n'Gewünschtes Ergebnis:\n'\n'Auftrag            Zeit            AnfagsDatum        Enddatum\n'A                    05:50          Do. 26.08.99        Do. 26.08.99\n'B                    01:50          Do. 26.08.99        Do. 26.08.99\n'C                    35:00          Fr.  27.08.99        Do. 02.09.99\n'D                    16:00          Fr.  03.09.99        Di.  07.09.99\n'E                     08:00         Di.  07.09.99 ....................\n'\n'Funktionsbeschreibung:\n'Diese Funktion berechnet, ausgehend vom Startdatum und der Dauer in Stunden, das Enddatum\n'unter Berücksichtigung der \"normalen\" Werktage (excl. Samstag und Sonntag) aber OHNE\n'Berücksichtigung der Feiertage\n\nDim EW, d, w, t\nEW = Dauer * 24 / 7 'Eure Werktage\nd = Int(EW) + (EW - Int(EW)) * 7 / 24 'Korrigierte Dauer\nw = Int(d / 7) 'ganze Wochen\nt = d - w * 7 'Resttage\nWerktag7h = Start + d + 2 * w + IIf(Weekday(Start, vbSunday) _\n+ t >= 7, 1, 0) + IIf(Weekday(Start, vbMonday) + t >= 7, 1, _\n0) - 1 / 86400\n'Start+Dauer+Samstage+Sonntage im Zeitraum-1sec\nEnd Function\n\nFunction Test_Werktag7h() As Date\nDim da As Date\nda = TimeSerial(55, 0, 0)\nTest_Werktag7h = Werktag7h(\"1.1.1999 13:22\", da)\nEnd Function\n\n\n'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n''Feiertage\n'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n\n'Meine \"Feiertage\" bestehen eigentlich aus 4 Tabellen:\n'\n'a) tblFeierStd    -    Aufbau des Feiertages (genereller Feiertagswert ohne Jahr) und Zuordnung zu einem\n'Bundesland\n'\n'b) _tblAlleFeiertage    -    Sekundärtabelle, generiert aus tblFeierStd, enthält den Namen,\n'das \"echte\" Datum (incl. Jahr) und die dazugehörige Wochentagsnummer (1 = Montag ... 7 = Sonntag)\n'\n'c) _tblBundesLand    - enthält die Zuordnung zu den Klarnamen der Bundesländer, da bei den Abfragen\n'etc. nur der Feldname (B1 ... B16, C1, D1) verwendet wird ...\n'\n'd) _tblAlleTage    - Tertiärtabelle, generiert aus _tblAlleFeiertage, die alle Tage eines Jahres enthält ...\n'Sie wird durch das Formular frmFeiertagErstellen automatisch gefüllt.\n'Idee: Kalender aller Tage mir allen wichtigen Infos zu Wochentag bis Feiertag\n'\n'Die Abfrage qryHlp_Feiertag verknüpft die beiden Tabellen tblFeierStd und _tblAlleFeiertage und ist die\n'Grundlage aller Feiertagsfunktionen in diesem Modul  ... Achtung: die Verknüpfung ist der\n'Feiertagsnamen selbst ... Die andern Feiertags-Abfragen sind nur Beispiele ...\n'\n' Eigene Feiertage:\n'\n'Öffne das Formular frmFeiertagErstellen.\n'\n'Passe dann  die Tabelle tblFeierStd deinen Wünschen entsprechend an. Die Tabelle enthält für ein Jahr\n'alle Feiertage sowie eine Möglichkeit, diese Feiertage einem Bundesland zuzuordnen. Sie enthält,\n'(bis auf Fehler?) bereits alle offiziellen Feiertage der Bundesländer von D sowie Österreich und\n'England. Wenn du die Bundesländer erweiterst, vergiß nicht auch die Tabelle _tblBundesLand zu erweitern.\n'\n'Wenn du \"private\" Feiertage hast, trage diese in die Tabelle tblFeierStd ein.\n'Dazu gibt es das Formular frmJahrEigeneFeiertage, die erledigt das für dich\n'\n'Das Einzige, was derzeit nicht berücksichtigt wird, sind \"halbe\" Feiertage, wie der 24.12 oder 31.12.\n'das müßte man bei Bedarf ergänzen ..\n'\n'Das Formular \"frmTestKalender\" und \"frmKalender\" sind mein eigener PopupKalender (man kann ihn aber auch\n'\"so\" aufrufen) und ein Testformular um den PopupAufruf zu zeigen...\n\n'########################## Schweizer Feiertage zur Info von Urs ######################################\n'Habe diese Feiertage (ALLE außer den Eidgenössischen Bettag) auch in die Tabelle eingebaut.\n\n'In der Schweiz ist es wie üblich von Kanton zu Kanton verschieden.\n'\n'Nationale Feiertage:\n'1.1. Neujahr + 2.1. (Berchtholdstag)\n'KEIN Dreikönig\n'Palmsonntag\n'Karfreitag\n'Ostern Ostermontag\n'Auffahrt ?? = Christi Himmelfahrt\n'Pfingsten Pfingstmontag\n'1.8. Bundesfeiertag\n'19.9.1999 (17.9.2000) Eidgenössischer Bettag (immer Sonntags) 'ignoriert, da immer Sonntags\n'25.12. Weihnachten\n'26.12. Stefanstag\n'\n'katholische Gebiete (Zentralschweiz, Ostschweiz, Freiburg, Tessin uam., die\n'Feiern einfach lieber!)\n'Fronleichnam (40 Tage nach Ostern)\n'15.8. Mariä Himmelfahrt\n'1.11. Allerheiligen\n'8.12. Mariä Empfängnis\n'\n'reformierte/städtische Gebiete (Zürich, Bern, Basel, Genf uam. + Tessin)\n'1.5. Tag der Arbeit\n'\n'die Grenzen verlaufen z.T. auch innerhalb von Kantonen.\n'daneben sehr viele lokale oder kantonale Feiertage\n'Gruss Urs Villiger.\n'###############################################################################################\n\nPrivate Function GetBitValue(nIndex As Long, BitArray As Long) As Boolean\n    Dim nBit As Long\n\n    nBit = 2 ^ (nIndex Mod 16)\n    If nBit = &H8000& Then  'Prevent overflow on high bit\n        GetBitValue = BitArray And &H8000\n    Else\n        GetBitValue = BitArray And nBit\n    End If\nEnd Function\n\n\nFunction create_Default_AlleTage(strBundesland As String)\n\nDim strSQL As String\n\nstrSQL = \"\"\nstrSQL = strSQL & \"SELECT JJJJMMTT, Werkname, dtDatum, IstFeiertag, Feiertagsname, JahrNr, Quartal, MonatNr, TagNr, Wochentag,\"\nstrSQL = strSQL & \" KW_D, JJJJMM, JJJJKW, JJJJQrt, KW_US, WN_KalMon, WN_KalTag, Arbeitszeit, LfdTagNrAcc,\"\nstrSQL = strSQL & \" B\" & strBundesland & \" As Landesfeiertag, F\" & strBundesland & \" As Landesferien\"\nstrSQL = strSQL & \" FROM _tblAlleTage;\"\n\nCall CreateQuery(strSQL, \"qryAlleTage_Default\")\n\nEnd Function\n\nFunction fktAnzWerktageVariabel(DatumVon As Date, DatumBis As Date, Bundesland As String, WerktageNr As Long) As Long\n\n'Die Funktion ermittelt die Anzahl der Werktage (abhängig von WerktageNr) zwischen Datumvon und Datumbis\n'unter Berücksichtigung der Feiertage eines Bundeslandes (siehe Tabelle)\n'es muß das Bundesland als Kürzel (B1 bis D1) mit übergeben werden\n'Es benötigt Function AnzWochenTage und fktAnzFeiertage und Bundeslandtest\n'sowie (in fktAnzFeiertage) qryHlp_Feiertag und daher tblFeierStd und _tblAlleFeiertage\n'Die \"Standard\"-Feiertage in _tblAlleFeiertage sind vom 1.1.1995 bis 31.12.2035 erstellt,\n'können aber jederzeit erweitert werden. (Siehe \"frm _tblAlleFeiertage Erstellen\")\n\n'WerktageNr 1 = 1 Montag\n'WerktageNr 2 = 2 Dienstag\n'WerktageNr 3 = 4 Mittwoch\n'WerktageNr 4 = 8 Donnerstag\n'WerktageNr 5 = 16 Freitag\n'WerktageNr 6 = 32 Samstag\n'WerktageNr 7 = 64 Sonntag\n\n' Bzw die Summe der Tage\n' Montag bis Freitag = 1 + 2 + 4 + 8 + 16 = 31\n\nDim IstWerktag(6) As Boolean\nDim X, Krit\nDim i As Long\nDim nBit As Long\nDim datumzwi As Date\n\nfktAnzWerktageVariabel = 0\n\nIf Not IsDate(DatumVon) Then Exit Function\nIf Not IsDate(DatumBis) Then Exit Function\nIf DatumVon > DatumBis Then Exit Function\n\n\nFor i = 0 To 6\n    nBit = 2 ^ i\n    IstWerktag(i) = WerktageNr And nBit\nNext i\n\ndatumzwi = DatumVon\n\nDo\n    If IstWerktag(Weekday(datumzwi, vbMonday) - 1) Then\n        Krit = \"qryHlp_Feiertag.\" & Bundesland & \" = True AND qryHlp_Feiertag.Feiertagsdat = \"\n        Krit = Krit & SQLDatum(datumzwi)\n        X = Nz(TLookup(Bundesland, \"qryHlp_Feiertag\", Krit))\n        If Not X Then\n            fktAnzWerktageVariabel = fktAnzWerktageVariabel + 1\n        End If\n    End If\n    datumzwi = datumzwi + 1\nLoop Until datumzwi > DatumBis\n\nEnd Function\n\n\nFunction fktAnzWerktage(DatumVon As Date, DatumBis As Date, Bundesland As String) As Long\n\n'Die Funktion ermittelt die Anzahl der Werktage (Mo - Fr) zwischen Datumvon und Datumbis\n'unter Berücksichtigung der Feiertage eines Bundeslandes (siehe Tabelle)\n'es muß das Bundesland als Kürzel (B1 bis D1) mit übergeben werden\n'Es benötigt Function AnzWochenTage und fktAnzFeiertage und Bundeslandtest\n'sowie (in fktAnzFeiertage) qryHlp_Feiertag und daher tblFeierStd und _tblAlleFeiertage\n'Die \"Standard\"-Feiertage in _tblAlleFeiertage sind vom 1.1.1995 bis 31.12.2035 erstellt,\n'können aber jederzeit erweitert werden. (Siehe \"frm _tblAlleFeiertage Erstellen\")\n\n'BundeslandID BundeslandName\n'BB Brandenburg\n'BE Berlin\n'BW Baden - Württemberg\n'BY Bayern\n'HB Bremen\n'HE Hessen\n'HH Hamburg\n'MV Mecklenburg - Vorpommern\n'NI Niedersachsen\n'NW Nordrhein - Westfalen\n'RP Rheinland - Pfalz\n'SH Schleswig - Holstein\n'SL Saarland\n'SN Sachsen\n'ST Sachsen - Anhalt\n'TH Thüringen\n\nOn Error Resume Next\nfktAnzWerktage = -1\nIf Not Bundeslandtest(Bundesland) Then Exit Function\n    \n'Anzahl Werktage = Anzahl Wochentage Minus Anzahl der Feiertage die nicht auf ein Wochenende fallen\nfktAnzWerktage = AnzWochenTage(DatumVon, DatumBis) - fktAnzFeiertage(DatumVon, DatumBis, Bundesland)\nEnd Function\n\nFunction fktAnzFeiertage(DatumVon As Date, DatumBis As Date, Bundesland As String) As Long\n\n'Die Funktion ermittelt die Anzahl der Feiertage (nur Mo - Fr) zwischen Datumvon und Datumbis\n'unter Berücksichtigung eines Bundeslandes (siehe Tabelle)\n'es muß das Bundesland als Kürzel (B1 bis D1) mit übergeben werden\n'Es benötigt qryHlp_Feiertag und daher tblFeierStd und _tblAlleFeiertage\n'Die \"Standard\"-Feiertage in _tblAlleFeiertage sind vom 1.1.1995 bis 31.12.2035 erstellt,\n'können aber jederzeit erweitert werden.\n\n'_tblBundesLand enthält die folgende Tabelle (zur Vereinfachung):\n\n'BundeslandID BundeslandName\n'BB Brandenburg\n'BE Berlin\n'BW Baden - Württemberg\n'BY Bayern\n'HB Bremen\n'HE Hessen\n'HH Hamburg\n'MV Mecklenburg - Vorpommern\n'NI Niedersachsen\n'NW Nordrhein - Westfalen\n'RP Rheinland - Pfalz\n'SH Schleswig - Holstein\n'SL Saarland\n'SN Sachsen\n'ST Sachsen - Anhalt\n'TH Thüringen\n\nOn Error Resume Next\nDim Krit As String\n    \nfktAnzFeiertage = 0\nIf Not Bundeslandtest(Bundesland) Then Exit Function\n\nKrit = \"qryHlp_Feiertag.\" & Bundesland & \" = True AND qryHlp_Feiertag.Wochentagnr<6 AND qryHlp_Feiertag.Feiertagsdat >= \"\nKrit = Krit & SQLDatum(DatumVon) & \" AND qryHlp_Feiertag.Feiertagsdat <= \" & SQLDatum(DatumBis)\nfktAnzFeiertage = TCount(\"Feiertagsdat\", \"qryHlp_Feiertag\", Krit)\nEnd Function\n\nFunction fktIstWerktag(XDatum As Date, Bundesland As String) As Boolean\n'Die Funktion ermittelt, on ein Datum ein Werktag ist oder nicht (Mo - Fr)\n'unter Berücksichtigung der Feiertage eines Bundeslandes (siehe Tabelle)\n'es muß das Bundesland als Kürzel (B1 bis D1) mit übergeben werden (siehe fktAnzWerktage)\n'Es benötigt qryHlp_Feiertag und daher tblFeierStd und _tblAlleFeiertage\n'Die \"Standard\"-Feiertage in _tblAlleFeiertage sind vom 1.1.1995 bis 31.12.2035 erstellt,\n'können aber jederzeit erweitert werden.\nOn Error Resume Next\nDim X, Krit\n\nfktIstWerktag = False\nIf Not Bundeslandtest(Bundesland) Then Exit Function\n\nfktIstWerktag = True\nIf Weekday(XDatum, vbMonday) < 6 Then\n    Krit = \"qryHlp_Feiertag.\" & Bundesland & \" = True AND qryHlp_Feiertag.Feiertagsdat = \"\n    Krit = Krit & SQLDatum(XDatum)\n    X = Nz(TLookup(Bundesland, \"qryHlp_Feiertag\", Krit))\n    If X Then fktIstWerktag = False\nElse\n    fktIstWerktag = False\nEnd If\nEnd Function\n\n\nFunction fktWelcherFeiertag(XDatum As Date, Bundesland As String) As String\n'Die Funktion ermittelt den Feiertagsnamen, wenn es denn ein Feiertag ist\n'unter Berücksichtigung der Feiertage eines Bundeslandes (siehe Tabelle)\n'unabhängig davon, ob dieser Tag ein Werk- oder Sonntag ist\n'Wenn kein Feiertag, wird ein Leerstring \"\" zurückgegeben\n'es muß das Bundesland als Kürzel (B1 bis D1) mit übergeben werden (siehe fktAnzWerktage)\n'Es benötigt qryHlp_Feiertag und daher tblFeierStd und _tblAlleFeiertage\n'Die \"Standard\"-Feiertage in _tblAlleFeiertage sind vom 1.1.1995 bis 31.12.2035 erstellt,\n'können aber jederzeit erweitert werden.\nOn Error Resume Next\nDim Krit\nfktWelcherFeiertag = \"\"\nIf Not Bundeslandtest(Bundesland) Then Exit Function\n\nKrit = \"qryHlp_Feiertag.\" & Bundesland & \" = True AND qryHlp_Feiertag.Feiertagsdat = \"\nKrit = Krit & SQLDatum(XDatum)\n    \nfktWelcherFeiertag = Nz(TLookup(\"Feiertagsname\", \"qryHlp_Feiertag\", Krit))\n\nEnd Function\n\nFunction Bundeslandtest(ByVal BundeslandID As String) As Boolean\nDim i As Integer\nDim X As String\nOn Error Resume Next\n\nBundeslandID = UCase(BundeslandID)\nBundeslandtest = False\n\nX = UCase(Nz(TLookup(\"BundeslandID\", \"_tblBundesLand\", \"BundeslandID = '\" & BundeslandID & \"'\")))\n\nIf X = BundeslandID Then\n    Bundeslandtest = True\nEnd If\n\nEnd Function\nFunction BundeslandName(ByVal BundeslandID As String) As String\nDim i As Integer\nDim X As String\nOn Error Resume Next\n\nBundeslandID = UCase(BundeslandID)\nBundeslandName = Nz(TLookup(\"Bundeslandname\", \"_tblBundesLand\", \"BundeslandID = '\" & BundeslandID & \"'\"))\n\nEnd Function\n\nFunction CreateTblWerktag(VonJahr As Integer, BisJahr As Integer, Bundesland As String, Optional WerkNrx As String = \"Std\", Optional tblLoesch As Boolean = True) As Boolean\n'Vonjahr und BisJahr immer als 4-stellige Jahresnummer eingeben\n'Für Bundesland immer das Kürzel B1 bis B16, C1 oder D1 angeben\n'Hier kann eine Weksnummer eingegeben werden, Std = \"Std\"\n'Wenn tblLoesch = True, wird der Werkstagskalender vorher gelöscht\nDim db As DAO.Database\nDim rst\nDim Krit As String\nDim i As Integer, j As Integer, k As Integer, L As Integer, tmpdat As Date\n    \nOn Error GoTo CreateTblWerktag_err\nCreateTblWerktag = True\n\n'Alte Tabelleninhalte löschen\n'DELETE tblWerktag.* FROM tblWerktag;\nSet db = CurrentDb\n\nIf tblLoesch Then\n    Krit = \"DELETE tblWerktag.* FROM tblWerktag;\"\n    Set rst = db.CreateQueryDef(\"\", Krit)\n    rst.Execute\nEnd If\n\nSet rst = Nothing\nSet rst = db.OpenRecordset(\"SELECT * FROM tblWerktag;\", dbOpenDynaset)\n           \nFor i = VonJahr To BisJahr  'Schleife über alle Jahre\n    k = Format(DateSerial(i, 12, 31), \"y\", vbMonday, vbFirstFourDays) 'Anzahl Tage pro Jahr (Schaltjahr) ?\n    For j = 1 To k  'Schleife über alle Tage des Jahres\n        tmpdat = DateSerial(i, 1, j)\n        L = Weekday(tmpdat, vbMonday)\n        If fktIstWerktag(tmpdat, Bundesland) Then   ' werktag ?\n            rst.AddNew\n            rst.fields(\"WerkNummer\") = WerkNrx\n            rst.fields(\"Werktag\") = tmpdat\n            rst.fields(\"WochentagNr\") = L\n            rst.update\n        End If\n    Next j\nNext i\n\nrst.Close\nSet rst = Nothing\nSet db = Nothing\n\nExit Function\n\nCreateTblWerktag_err:\n\nIf err.Number = 3022 Then Resume Next  'Datum exitiert bereits in der Tabelle\n\nrst.Close\nSet rst = Nothing\nSet db = Nothing\nCreateTblWerktag = False\nMsgBox \"Fehler \" & err.Number & \" \" & err.description, , \"Werktage erzeugen Fehler\"\n\nEnd Function\n \nFunction OsterSonntagDatum(Jahr) As Date\n''Wolfgang weidner\n''w.weidner@t-online.de\n'' Geändert von KObd (Ostersonntagsberechnung separiert)\nOn Error Resume Next\n\nDim Monat As Integer, TAG As Integer, s As Long\nDim m As Integer, n As Integer, i As Integer, j As Integer, t As Integer\nDim a As Integer, b As Integer, c As Integer, d As Integer, E As Integer\n'************ Feiertagsberechnung *****************\n\nIf Jahr < 1582 Or Jahr > 2199 Then\n    MsgBox \"Falsche Jahreszahl\"\n    Exit Function\nEnd If\n\n    Select Case Jahr\n        Case 1582 To 1699\n            m = 22\n            n = 2\n        Case 1700 To 1799\n            m = 23\n            n = 3\n        Case 1800 To 1899\n            m = 23\n            n = 4\n        Case 1900 To 2099\n            m = 24\n            n = 5\n        Case 2100 To 2199\n            m = 24\n            n = 6\n    End Select\n\n    j = Jahr\n    a = j Mod 19\n    b = j Mod 4\n    c = j Mod 7\n    d = (19 * a + m) Mod 30\n    E = (2 * b + 4 * c + 6 * d + n) Mod 7\n    If (d + E) <= 9 Then\n        OsterSonntagDatum = DateSerial(Jahr, 3, 22 + d + E)\n    Else\n        OsterSonntagDatum = DateSerial(Jahr, 4, d + E - 9)\n    End If\n    If Month(OsterSonntagDatum) = 4 Then\n        If (d = 28) And (a > 10) Then\n            If Day(OsterSonntagDatum) = 25 Then\n                OsterSonntagDatum = DateSerial(Jahr, 4, 18)\n            End If\n            If Day(OsterSonntagDatum) = 26 Then\n                OsterSonntagDatum = DateSerial(Jahr, 4, 19)\n            End If\n        End If\n    End If\n\nEnd Function\n\n\nFunction VierterAdvent(Jahr As Variant) As Date\n\nDim dat As Date\n    \n    dat = DateSerial(Jahr, 12, 24)\n\n    Do While Not Weekday(dat, vbMonday) = vbSunday\n        dat = dat - 1\n    Loop\n    VierterAdvent = dat\n\nEnd Function\n\n\nFunction BusstagDatum(Jahr As Variant) As Date\nDim t As Integer\n\n'Buß- und Bettag ist der Tag, der 32 Tage vor dem 4. Adventsonntag liegt\nBusstagDatum = VierterAdvent(Jahr) - 32\n\n'Buß- und Bettag ist immer der Mittwoch, der zwischen dem 16. und 22. November liegt.\n'w.weidner@t-online.de\n'Buß- und Bettag ist immer der Mittwoch, der zwischen dem 16. und 22. November liegt.\n'    For T = 16 To 22\n'        If Weekday(DateSerial(intJahr, 11, T), vbMonday) = 3 Then\n'            BusstagDatum = DateSerial(intJahr, 11, T)\n'        End If\n'    Next T\n\nEnd Function\n\n\nFunction dblZt(sWert As String) As Date\nOn Error Resume Next\nDim sw1 As Double\nDim sw2 As Date\n'sw1 = CDbl(Replace(swert, \",\", \".\"))\nsw1 = CDbl(sWert)\nsw2 = sw1\ndblZt = sw2\nEnd Function\n\n\n''''''''''''''''''''''''''''''''\n''''''''''''''''''''''''''''''''\n''''''''''''''''''''''''''''''''\n\nFunction ZeitNachDouble(Sek1 As Double, Min As Long, std As Long, TAG As Long) As Double\n' *******************\n' Umrechnung der Zeit in Tagen, Stunden, Minuten und Sekunden nach Sekunden.\n' Gedacht, um Wettkampfzeiten ganz exakt als Double abspeichern zu können\n' 1 Min =    60 Sekunden (60 Sek)\n' 1 Std =  3600 Sekunden (60 Sek * 60 Min)\n' 1 Tag = 86400 Sekunden (60 Sek * 60 Min * 24 Std)\n' *******************\n\n    ZeitNachDouble = (TAG * 86400) + (std * 3600) + (Min * 60) + Sek1\n\nEnd Function\n\nFunction DoubleNachZeit(Art, WertSekunden As Double, Restsekunden As Double, Minuten As Long, stunden As Long, Tage As Long) As Boolean\n' *********************************************************************************\n' Die Funktion DoubleNachZeit wandelt eine Zahl / Zeit (im Format Double)\n' in Sekunden, Minuten, Stunden und Tage um\n'\n' Funktion ist ausschließlich gedacht, um Wettkampfzeiten, die nur in Sekunden und Bruchteilen\n' erfaßt wurden in ein \"echtes\" Zeitformat umzuwandeln\n'\n'   Parameter: Art = Beliebig, dann Rückgabe in Tagen, Std, Minuten und Restsekunden\n'              Art = \"M\" oder \"m\" - nur Minuten + Sec (Std und Tage immer = 0) Min dann ggf. > 60\n'              Art = \"S\" oder \"s\" - nur Std, Min + Sec (Tage immer = 0) Std dann ggf. > 24\n'              WertSekunden - Übergabewert an die Funktion Sekunden und Millisekunden\n'\n'              Restsekunden - Rückgabewert in Sekunden und Millisekunden\n'              Minuten      - Rückgabewert\n'              Stunden      - Rückgabewert\n'              Tage         - Rückgabewert\n'\n'   Sofern DoubleNachZeit ein gültiger Zahlenwert ist, gibt die Funktion Wahr zurück\n'                       ansonsten False\n'\n' Da die Funktion selbstständig ermittelt, ob ein \".\" oder \",\" als Nachkommatrenner\n' verwendet wird, sollte sie sprachunabhängig funktionieren\n'\n' Public domain - Benutzung auf eigene Gefahr\n'\n' Kommentare und Verbesserungsvorschläge an:\n'\n'   Klaus Oberdalhoff   - KObd@gmx.de\n'\n' *********************************************************************************\n\nDim NachkommaSec As Double, VorkommaSec As Long, tmp1, tmp2, tmp3, tmp4, Sepa\n\n    Restsekunden = 0\n    Minuten = 0\n    stunden = 0\n    Tage = 0\n    DoubleNachZeit = True\n\nIf Len(Trim(Nz(WertSekunden))) = 0 Then\n    DoubleNachZeit = False\n    Exit Function\nEnd If\n\nIf Not IsNumeric(WertSekunden) Then\n    DoubleNachZeit = False\n    Exit Function\nEnd If\n\n' < 1 Minute - dann Keine Berechnung notwendig\nIf Abs(WertSekunden) < 60 Then\n    Restsekunden = WertSekunden\n    Exit Function\nEnd If\n\n' Ermitteln, ob \",\" oder \".\" die Nachkommastelle ist ...\n' aus mdlLocaleInfo\n'Sepa = GetDecimalSep()   ' entweder \".\" oder \",\"\nSepa = Mid(Format(1.5, \"#.#\"), 2, 1)\n\n' Zahl in String umwandeln, Wert nach der Kommastelle abschneiden und zwischen speichern\n' Die Nachkommastellen rechnerisch zu bearbeiten, war zu ungenau !!!\ntmp1 = Format(Abs(WertSekunden))\ntmp2 = InStr(1, tmp1, Sepa, vbTextCompare)\ntmp3 = \"\"\n' Wenn Tmp2 ein Komma enthält: Nachkommastellen als String sichern\nIf tmp2 > 0 Then\n    tmp3 = Mid(tmp1, tmp2 + 1)\nEnd If\n\n' Tmp3 = Nachkomma\nVorkommaSec = Fix(WertSekunden)\n\n' Minuten berechnen\nMinuten = VorkommaSec \\ 60\n' Das hatte ich zuerst, ist aber zu ungenau\n' Restsekunden = Fix(VorkommaSec Mod 60) + NachkommaSec\ntmp4 = Fix(VorkommaSec Mod 60)\nIf Len(tmp3) > 0 Then\n    Restsekunden = CDbl(tmp4 & Sepa & tmp3)\nElse\n    Restsekunden = CDbl(tmp4)\nEnd If\n\n' Stunden berechnen, wenn nötig\nIf Abs(Minuten) < 60 Or UCase(Art) = \"M\" Then\n    Exit Function\nEnd If\n\nstunden = Minuten \\ 60\nMinuten = Minuten Mod 60\n\n' Tage berechnen, wenn nötig\nIf Abs(stunden) < 24 Or UCase(Art) = \"S\" Then\n    Exit Function\nEnd If\n\nTage = stunden \\ 24\nstunden = stunden Mod 24\n\nEnd Function\n\n' Test the function:\n\nFunction ZeitTest()\nDim Mldg, titel, Voreinstellung, Wert1 As Double\nDim Sec1 As Double, Min1 As Long, Std1 As Long, Tag1 As Long, tmp1\n\nMldg = \"Sekunden (incl. Nachkommastellen) eingeben: \"  ' Aufforderung festlegen.\ntitel = \"Abfrage Sekundenwert\" ' Titel festlegen.\nVoreinstellung = \"1\"    ' Voreinstellung festlegen.\n' Meldung, Titel und Standardwert anzeigen.\nWert1 = InputBox(Mldg, titel, Voreinstellung)\n\nIf Not DoubleNachZeit(\"X\", Wert1, Sec1, Min1, Std1, Tag1) Then\n    MsgBox (\"Falsche Eingabe ! Wert war \" & Wert1)\n    Exit Function\nEnd If\n\ntmp1 = \"Eingabewert: \" & Wert1 & vbCrLf & \"Sekunden: \" & Sec1\ntmp1 = tmp1 & vbCrLf & \"Minuten: \" & Min1 & vbCrLf & \"Stunden: \" & Std1\ntmp1 = tmp1 & vbCrLf & \"Tage: \" & Tag1\n\n    MsgBox (tmp1)\n\n'Debug.Print \"Eingabewert: \" & Wert1\n'Debug.Print \"Sekunden: \" & Sec1\n'Debug.Print \"Minuten: \" & Min1\n'Debug.Print \"Stunden: \" & Std1\n'Debug.Print \"Tage: \" & Tag1\n\nEnd Function\n\nPublic Function LongZuZeit(z As Long) As Date\n'In einem Feld (Typ Long Integer) ist eine Zeit in\n'Sekunden gespeichert. In einem Bericht möchte ich\n'diese Zeit in der Form hh:mm:ss ausgeben.\n'\n'Wie kann ich den Feldinhalt für die Ausgabe\n'umrechnen?\n'Autor K.Prucha\n  LongZuZeit = TimeSerial(((z \\ 3600) Mod 60), ((z \\ 60) Mod 60), (z Mod 60))\nEnd Function\n\n\n''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n'''''''' Kalenderfunktionen ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n'Global Global_PrevCtrl As Control wird benötigt\n\nFunction Datumsetzen1(X As control, ByVal Y)\n\nDim xFrm As Form, XT1, XM1, XY1, Moonx As String, i As Integer\n\nDim iStunde As Long\nDim iMin As Long\n\n'Für den Fall das PrevCtrl nicht gesetzt wäre\nOn Error GoTo Datumsetzen1_we\n\nIf Global_PrevCtrl.backColor <> 14024702 Then  'Wenn kein Feiertag\n    Global_PrevCtrl.BackStyle = 0\nEnd If\nGlobal_PrevCtrl.SpecialEffect = 0\n\nX.SetFocus\n\nDatumsetzen1_we:\n\nerr.clear\nDoEvents\nerr.clear\nOn Error GoTo Datumsetzen1_err\n\nSet xFrm = X.Parent\n\nX.BackStyle = 1\nX.SpecialEffect = 2\n\nXT1 = X.caption 'Tagesnummer, wenn richtig gesetzt\nXM1 = Format(CDate(xFrm(\"Mon\" & Y).Value), \"m\", vbMonday, vbFirstFourDays) 'Monat\nXY1 = Format(CDate(xFrm(\"Mon\" & Y).Value), \"yyyy\", vbMonday, vbFirstFourDays) 'Jahr\n\nxFrm!AktDat = DateSerial(XY1, XM1, XT1) + TimeSerial(Global_iStunde, Global_iMinute, 0)\n\nSet Global_PrevCtrl = X\n\n''Eines der kleinen 8 übernanderliegenden Mondphasenbilder sichtbar setzen\nFor i = 1 To 8\n    xFrm(\"Moon\" & i).Visible = False\nNext i\n\nMoonx = \"Moon\" & Mondphase(xFrm!AktDat)\nxFrm(Moonx).Visible = True\n\nExit Function\nDatumsetzen1_err:\nMsgBox \"Datumsetzen1 \" & err.Number & \" \" & err.description\nEnd Function\n\nFunction Datumsetzen2(X As control, ByVal Y)\nDim nix, z As String\nnix = Datumsetzen1(X, Y)\nIf Len(Trim(Nz(X.Parent.OpenArgs))) > 0 Then\n    DoCmd.Close acForm, X.Parent.Name, acSaveNo\nEnd If\nEnd Function\n\nFunction Datum_Neuaufbau(xFrm As Form, XAktDat As Date)\nDim tmpMon(1 To 3) As Integer\nDim tmpyr(1 To 3) As Integer\nDim tmpdy As Integer\nDim XFeiDat() As Date\nDim XFeiDatNam() As String\nDim i As Integer\nDim j As Integer\nDim k As Integer\nDim L As Integer\nDim m As Integer\nDim n As Integer\nDim p As Integer\nDim tmpdt As Date\nDim xstr1 As String\nDim Feianza As Integer\nDim Moonx As String\n\ntmpdy = Format(XAktDat, \"d\", vbMonday, vbFirstFourDays) 'Die Nummer des Tages\ntmpMon(2) = Format(XAktDat, \"m\", vbMonday, vbFirstFourDays)\ntmpyr(2) = Format(XAktDat, \"yyyy\", vbMonday, vbFirstFourDays)\ntmpMon(1) = Format(DateAdd(\"m\", -1, XAktDat), \"m\", vbMonday, vbFirstFourDays)\ntmpyr(1) = Format(DateAdd(\"m\", -1, XAktDat), \"yyyy\", vbMonday, vbFirstFourDays)\ntmpMon(3) = Format(DateAdd(\"m\", 1, XAktDat), \"m\", vbMonday, vbFirstFourDays)\ntmpyr(3) = Format(DateAdd(\"m\", 1, XAktDat), \"yyyy\", vbMonday, vbFirstFourDays)\n\nFor i = 1 To 3  '3 Monate zur Ansicht\n'Setzten bei Monateswechsel\n    xFrm(\"Fei\" & i) = FeiertageimMonat(DateSerial(tmpyr(i), tmpMon(i), 1), xFrm!cmbBundesland.Value, Feianza, XFeiDat(), XFeiDatNam()) 'Feiertage suchen\n    xFrm(\"Mon\" & i) = DateSerial(tmpyr(i), tmpMon(i), 1) 'die 3 Monate setzen\n    L = 0  'Laufvariable TagesNr\n    m = Weekday(DateSerial(tmpyr(i), tmpMon(i), 1), vbMonday) ' Wochentag des \"1.\" bestimmen\n    n = Format(LetzterDesMonats(DateSerial(tmpyr(i), tmpMon(i), 1)), \"d\", vbMonday, vbFirstFourDays) 'Anzahl der Tage im Monat\n    \n    For j = 1 To 6 ' Wochenloop\n        xFrm(\"w\" & i & \"w\" & j).caption = \"\"\n        \n        For k = 1 To 7 ' Tagesloop\n            xFrm(\"btn\" & i & \"Tg\" & j & k).BackStyle = 0 'Zurücksetzen\n            xFrm(\"btn\" & i & \"Tg\" & j & k).SpecialEffect = 0\n            xFrm(\"btn\" & i & \"Tg\" & j & k).backColor = -2147483633\n            If L = 0 And k < m Then 'Überzählige Buttons deaktivieren (die vor dem ersten)\n                xFrm(\"btn\" & i & \"Tg\" & j & k).Visible = False\n                xFrm(\"btn\" & i & \"Tg\" & j & k).caption = \"\"\n            Else\n                If L >= n Then 'Überzählige Buttons deaktivieren (die nach dem letzten)\n                    xFrm(\"btn\" & i & \"Tg\" & j & k).Visible = False\n                    xFrm(\"btn\" & i & \"Tg\" & j & k).caption = \"\"\n                Else    'Ahh die eigentlichen Monatstage\n                    L = L + 1 ' lfd. Nummer des Tages\n                    tmpdt = DateSerial(tmpyr(i), tmpMon(i), L)\n                    xFrm(\"btn\" & i & \"Tg\" & j & k).Visible = True\n                    xFrm(\"btn\" & i & \"Tg\" & j & k).caption = L\n                    xFrm(\"w\" & i & \"w\" & j).caption = Format(tmpdt, \"ww\", vbMonday, vbFirstFourDays)\n                    If Feianza > 0 Then 'wenn Feiertag, dann Background setzen\n                        For p = 1 To Feianza\n                            If tmpdt = XFeiDat(p) Then\n                                xFrm(\"btn\" & i & \"Tg\" & j & k).BackStyle = 1\n                                xFrm(\"btn\" & i & \"Tg\" & j & k).backColor = 8972484\n                            End If\n                        Next p\n                    End If\n                    If i = 2 And L = tmpdy Then 'Den bisher aktuell gewählten Tag markieren\n                        xFrm(\"btn\" & i & \"Tg\" & j & k).BackStyle = 1\n                        xFrm(\"btn\" & i & \"Tg\" & j & k).SpecialEffect = 2\n                        Set Global_PrevCtrl = xFrm(\"btn\" & i & \"Tg\" & j & k)\n                    End If\n                End If\n            End If\n        Next k\n    Next j\nNext i\n\nxFrm!AktDat = XAktDat   'DAS Bezugsfeld\nxFrm!txtMonth = Format(XAktDat, \"mmmm\", vbMonday, vbFirstFourDays)  'Anzeige des Monats in der Mitte (der 3 Monate)\nxFrm!YearNr = Format(XAktDat, \"yyyy\", vbMonday, vbFirstFourDays)      'Anzeige des aktuellen Jahres in der Mitte\n\n''Eines der kleinen 8 übernanderliegenden Mondphasenbilder sichtbar setzen\nFor i = 1 To 8\n    xFrm(\"Moon\" & i).Visible = False\nNext i\n\nMoonx = \"Moon\" & Mondphase(XAktDat)\nxFrm(Moonx).Visible = True\n\nEnd Function\n\nFunction FeiertageimMonat(XDatum As Date, XBund As String, Feianz As Integer, xdat() As Date, XDatNam() As String)\nDim db As DAO.Database\nDim rst As DAO.Recordset\nDim Krit As String\nDim i As Integer\nReDim xdat(1 To 31)\nReDim XDatNam(1 To 31)\nFeiertageimMonat = \"\"\nKrit = \"SELECT qryHlp_Feiertag.Feiertagsdat, qryHlp_Feiertag.Feiertagsname FROM qryHlp_Feiertag \"\nKrit = Krit & \"WHERE qryHlp_Feiertag.Feiertagsdat >= \" & SQLDatum(ErsterDesMonats(XDatum))\nKrit = Krit & \" AND qryHlp_Feiertag.Feiertagsdat <= \" & SQLDatum(LetzterDesMonats(XDatum)) & \" AND qryHlp_Feiertag.\" & XBund & \"=True ;\"\nSet db = CurrentDb\nSet rst = db.OpenRecordset(Krit, dbOpenDynaset)\ni = 1\nDo While Not rst.EOF\n                \n    rst.Edit\n    \n    FeiertageimMonat = FeiertageimMonat & Format(rst.fields(0), \"dd.mm\", vbMonday, vbFirstFourDays)\n    FeiertageimMonat = FeiertageimMonat & \" \" & rst.fields(1) & vbCrLf\n    \n    xdat(i) = rst.fields(0)\n    XDatNam(i) = rst.fields(1)\n    rst.MoveNext\n    i = i + 1\nLoop\nFeianz = i - 1\nrst.Close\nSet rst = Nothing\nSet db = Nothing\n\nEnd Function\n\n\n\n'#################################################################################################\n'''''''''''' Mondphasenberechnung\n'#################################################################################################\n\nFunction Mondphase_Prom(Optional ByVal XDatum As Date) As Integer\n\n'Rückgabe: Mondphase in Promille (als Teil einer kompletten Mondphase zwischen Vollmond und Vollmond)\n\n'   0 o/oo = Vollmond\n' 250 o/oo = Halbmond abnehmend\n' 500 o/oo = Neumond\n' 750 o/oo = Halbmond zunehmend\n'1000 o/oo = Vollmond\n\n'Achtung: Berechnung kann um einen Tag + / - differieren ...\n\n'Beispiel: Der Wert für den 29.4.1999 ist 977\n'          Der Wert für den 30.4.1999 ist 011\n\n'D.h. am 29.4.1999 um 0:00 Uhr fehlen noch ca. 23 tausendstel (einer Mondphase) bis zum Vollmond, wärend\n'am 30.4.1999 um 0:00 Uhr bereits 11 tausendstel (einer Mondphase) schon wieder vorbei sind.\n\n'Die Frage: Wann exakt ist Vollmond ? bleibt also bestehen.\n\n'Ich habe in der Funktion Mondphase (willkürlich) folgende vier \"Stichtage\" festgelegt:\n'Wenn die Intervalle geändert werden, erhält man manchmal mehr als einen Tag pro Phase,\n'und das wollte ich vermeiden\n'Wenn der Mondphasenwert >= 982 oder <=  15 (Moon5) ist, dann ist Vollmond.\n'Wenn der Mondphasenwert >= 482 oder <= 515 (Moon1) ist, dann ist Neumond.\n'Wenn der Mondphasenwert >= 232 oder <= 265 (Moon7) ist, dann ist Halbmond (abnehmend).\n'Wenn der Mondphasenwert >= 732 oder <= 765 (Moon3) ist, dann ist Halbmond (zunehmend).\n'ansonsten sind es einfach \"zunehmende\" oder \"abnehmende\" Mondphasen mit jeweils mehreren Tagen\n\n'frmKalender enthält 8 Mondphasenbilder (ico), von denen immer nur eines sichtbar ist.\n'Die zurückgegebenen Nummern 1 - 8 entsprechen dem Bildnamen ...\n'Die Namen sind Moon1 bis Moon8\n\n'Mondphasenberechnung: (Info aus einer Newsgroup)\n'Well, you can calculate this fairly easily by knowing the length of the\n'lunar cycle (29.5302 days), a known full moon in the past (Nov. 11, 1753\n'is a good one since it is after the Gregorian reformation and the full\n'moon was at almost exactly 0:00 GMT), and a formula for calculating the\n'number of days between two dates (these are readily available).\n'\n'For example:  I was born Aug. 11, 1964.  I need to calculate the number\n'of days since Nov. 11, 1753.\n'Number of days (VBA: datediff)\n    '1964-1753 = 211 years\n    '211*365 = 77015 days.\n    '211/4 = 52.75 = 53 leap days\n    '1800, and 1900 were not leap years so 51 leap days\n    '77015+51 = 77066\n    'subtract 30 days for Sep, and 31 days for Oct, (31-11) for Aug, and 11\n    'days for Nov\n    '77066-30-31-20-11 = 76974 days (a good Julian date calculator would make\n    'this much easier.)\n'Divide this (number of days) by the lunar cycle of 29.5302 days:\n'76974/29.5302 = 2606.62\n'So the moon is 62% into the cycle where 50% would be a new moon and 100% (or\n'0%) would be full moon.\n\nConst vglDat As Date = #11/11/1753#\nConst Mooncyc As Double = 29.5302\n\nDim xdat As Double\n\nOn Error Resume Next\n\nIf (Not IsDate(XDatum)) Or (IsMissing(XDatum) Or (XDatum = 0)) Then XDatum = Date\n\nxdat = Abs(DateDiff(\"d\", vglDat, XDatum, vbMonday, vbFirstFourDays))\nxdat = xdat / Mooncyc\nMondphase_Prom = CInt((xdat - Int(xdat)) * 1000)\nEnd Function\n\nFunction Mondphase(Optional ByVal XDatum As Date, Optional AlsZahl As Boolean = True) As Variant\nDim XTm As Integer\n\nIf (Not IsDate(XDatum)) Or (IsMissing(XDatum) Or (XDatum = 0)) Then XDatum = Date\n\nXTm = Mondphase_Prom(XDatum)\n\nIf XTm >= 982 Or XTm <= 15 Then\n    If AlsZahl = False Then\n        Mondphase = \"Vollmond\"\n    Else\n        Mondphase = 5\n    End If\n    Exit Function\nEnd If\n\nIf XTm >= 482 And XTm <= 515 Then\n    If AlsZahl = False Then\n        Mondphase = \"Neumond\"\n    Else\n        Mondphase = 1\n    End If\n    Exit Function\nEnd If\n\nIf (XTm >= 232 And XTm <= 265) Then\n    If AlsZahl = False Then\n        Mondphase = \"Halbmond (abnehmend)\"\n    Else\n        Mondphase = 7\n    End If\n    Exit Function\nEnd If\n\nIf (XTm >= 732 And XTm <= 765) Then\n    If AlsZahl = False Then\n        Mondphase = \"Halbmond (zunehmend)\"\n    Else\n        Mondphase = 3\n    End If\n    Exit Function\nEnd If\n'\n'Nur, wenn nicht bereits direkt Neu- Voll- oder Halbmond angezeigt wurde\nIf XTm >= 0 And XTm <= 250 Then\n    If AlsZahl = False Then\n        Mondphase = \"Abnehmender Mond (Vollmond -> Halbmond) - \" & XTm & \" o/oo\"\n    Else\n        Mondphase = 6\n    End If\n    Exit Function\nEnd If\n\nIf XTm > 250 And XTm <= 500 Then\n    If AlsZahl = False Then\n        Mondphase = \"Abnehmender Mond (Halbmond -> Neumond) - \" & XTm & \" o/oo\"\n    Else\n        Mondphase = 8\n    End If\n    Exit Function\nEnd If\n\nIf XTm > 500 And XTm <= 750 Then\n    If AlsZahl = False Then\n        Mondphase = \"Zunehmender Mond (Neumond -> Halbmond) - \" & XTm & \" o/oo\"\n    Else\n        Mondphase = 2\n    End If\n    Exit Function\nEnd If\n\nIf XTm > 750 And XTm <= 1000 Then\n    If AlsZahl = False Then\n        Mondphase = \"Zunehmender Mond (Halbmond -> Vollmond) - \" & XTm & \" o/oo\"\n    Else\n        Mondphase = 4\n    End If\n    Exit Function\nEnd If\n\nEnd Function\n\n\nFunction Mp_Tst1(Optional ByVal XDatum As Date, Optional j As Integer = 99)\nDim i As Integer\nIf (Not IsDate(XDatum)) Or (IsMissing(XDatum) Or (XDatum = 0)) Then XDatum = Date\nFor i = 1 To j\n    Debug.Print Mondphase_Prom(XDatum + i)\nNext i\nEnd Function\n\n\nFunction Mp_Tst2(Optional ByVal XDatum As Date, Optional ByVal j As Integer = 99)\nDim xx As String, xy As String\nDim i As Integer\nIf (Not IsDate(XDatum)) Or (IsMissing(XDatum) Or (XDatum = 0)) Then XDatum = Date\nFor i = 1 To j\n    xx = Mondphase(XDatum + i, False)\n    xy = Left(xx, 1)\n    If xy = \"N\" Or xy = \"V\" Or xy = \"H\" Then\n        Debug.Print xx & \" \" & Format(XDatum + i, \"dd.mm.yyyy\", vbMonday, vbFirstFourDays)\n    End If\nNext i\nEnd Function\n\n\nFunction Tage360(ByVal StartDatum As Date, ByVal EndDatum As Date) As Long\n' Berechnen Tage 360 nach Bankregel\n' Newsgroup: Elmar Boye\n    If DatePart(\"d\", StartDatum) > 30 Then\n        StartDatum = StartDatum - 1\n    End If\n    If DatePart(\"d\", EndDatum) > 30 Then\n        EndDatum = EndDatum - 1\n    End If\n    If StartDatum > EndDatum Then\n        Tage360 = (DatePart(\"d\", StartDatum) - DatePart(\"d\", EndDatum) + _\n        (DatePart(\"m\", StartDatum) - DatePart(\"m\", EndDatum)) * 30 + _\n        (DatePart(\"yyyy\", StartDatum) - DatePart(\"yyyy\", EndDatum)) * 360) * -1\n    Else\n        Tage360 = DatePart(\"d\", EndDatum) - DatePart(\"d\", StartDatum) + _\n        (DatePart(\"m\", EndDatum) - DatePart(\"m\", StartDatum)) * 30 + _\n        (DatePart(\"yyyy\", EndDatum) - DatePart(\"yyyy\", StartDatum)) * 360\n    End If\nEnd Function\n\n\n'Zufallsdatum erzeugen\nFunction RandomDatum(Optional ByVal JahrVon As Long = 1900, Optional ByVal Jahrbis As Long = 2010, Optional ByVal MonVon = 1, Optional ByVal MonBis = 12, Optional ByVal NurWerktage As Boolean = False) As Date\n\nDim TagesNr As Long\nDim MonatsNr As Long\nDim JahresNr As Long\n\nDim ZufDat As Date\n\nRandomize\n\n' Verwenden Sie die folgende Formel, um ganzzahlige Zufallszahlen innerhalb eines bestimmten\n' Bereichs zu erzeugen:\n' Wert1 = Int((Obergrenze - Untergrenze + 1) * Rnd + Untergrenze)\n' Obergrenze steht hier für die größte Zahl des Bereichs und Untergrenze für die kleinste Zahl des Bereichs.\n\nRand_Start:\n    TagesNr = Int((31 - 1 + 1) * Rnd + 1)\n    MonatsNr = Int((MonBis - MonVon + 1) * Rnd + MonVon)\n    JahresNr = Int((Jahrbis - JahrVon + 1) * Rnd + JahrVon)\n    ZufDat = DateSerial(JahresNr, MonatsNr, TagesNr)\n\nIf NurWerktage And Weekday(ZufDat, vbMonday) > 5 Then GoTo Rand_Start\n\nRandomDatum = ZufDat\n\nEnd Function\n\n\nFunction fWeekNos(Optional StartDate, Optional lng_MaxWeek As Long = 217)\n\nDim istartWeek As Long\nDim iStartYear As Long\nDim iWeekday As Long\nDim iweekno As Long\nDim i As Long\nDim j As Long\nDim k As Long\nDim L As Long\nDim iM As Long\nDim iJ As Long\nDim lMon As Long\nDim lJahr As Long\nDim iMaxWeek(10) As Long\nDim iMaxYear(10) As Long\n\n'Debug.Print Now()\n\n'Dim MonNamen\n'MonNamen = Array(\"Jan\", \"Feb\", \"Mär\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\")\n'Woche1 = Array(\"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\", \"So\")\n\nReDim allWeekNo(1 To lng_MaxWeek)\nReDim allMonNo(1 To lng_MaxWeek)\nReDim allJahrNo(1 To lng_MaxWeek)\nReDim allJahrWeekNo(1 To lng_MaxWeek)\n\nIf IsMissing(StartDate) Or Not IsDate(StartDate) Then\n'    StartDate = Date\n    StartDate = DateSerial(2007, 9, 1)\nEnd If\n\nStartDate = StartDate - (Weekday(StartDate, 2) - 1)\n\niStartYear = year(StartDate)\nIf StartDate < DateSerial(year(StartDate), 12, 28) Then\n    istartWeek = Format(StartDate, \"ww\", vbMonday, vbFirstFourDays)\nElse\n    iStartYear = iStartYear + 1\n    istartWeek = 1\n    StartDate = fctKWMon(1, iStartYear)\nEnd If\n\nFor i = 0 To 10\n    iMaxWeek(i) = MaxWeekNo(iStartYear + i)\n    iMaxYear(i) = iStartYear + i\nNext i\n\n' Die Woche gehört zum Monat mit dem Donnerstag der Woche\nlMon = Month(StartDate + 3)\nlJahr = iStartYear\nj = istartWeek\nk = 0\n\nFor L = 1 To lng_MaxWeek\n    \n'Dim allWeekNo(0 To 2, 1 To CONST_MaxWeek)\n' 0 = Wochennr  -  1 = MonatsNr  - 2 = JahresNr\n    \n    allWeekNo(L) = j\n    allMonNo(L) = Month(fctKWMon(j, lJahr) + 3)  ' Der Donnerstag der Woche\n    allJahrNo(L) = lJahr\n    allJahrWeekNo(L) = lJahr & Right(\"00\" & allWeekNo(L), 2)\n    \n    j = j + 1\n    If j > iMaxWeek(k) Then\n        lJahr = lJahr + 1\n        j = 1\n        k = k + 1\n    End If\nNext L\n\n'Debug.Print allWeekNo(LBound(allWeekNo))\n'Debug.Print allMonNo(LBound(allMonNo))\n'Debug.Print allJahrNo(LBound(allJahrNo))\n'\n'Debug.Print allWeekNo(UBound(allWeekNo))\n'Debug.Print allMonNo(UBound(allMonNo))\n'Debug.Print allJahrNo(UBound(allJahrNo))\n'\n'Debug.Print Now()\n\nEnd Function\n\nFunction fYrweekNo(ByVal X As Date, Optional ByVal Y As Long = 0) As Long\n' Gibt YYYYWW des Datums zurück (Workaround,\n' da das Format \"ww\" beim Jahreswechsel einige Macken hat)\n'Zusatzparameter y =    0 Alles,  1 Nur KW, 2 Nur JJ\n\nDim iYr As Long\nDim iyr1 As Long\nDim iwk As Long\n\nIf Not IsDate(X) Then\n    fYrweekNo = -1\n    Exit Function\nEnd If\n\niYr = year(X)\niwk = Format(X, \"ww\", vbMonday, vbFirstFourDays)\niyr1 = year(X + 7)\nIf Format(X + 7, \"ww\", vbMonday, vbFirstFourDays) = 2 Then\n    iwk = 1\n    iYr = iyr1\nEnd If\n\nIf iwk > 50 And Month(X) = 1 Then iYr = iYr - 1\n\nSelect Case Y\n    Case 0\n        fYrweekNo = (iYr * 100) + iwk\n    Case 1\n        fYrweekNo = iwk\n    \n    Case 2\n        fYrweekNo = iYr\n    \n    Case Else\n        fYrweekNo = (iYr * 100) + iwk\n    \nEnd Select\n\nEnd Function\n\n\nFunction TestAufMontag()\nCall TestWochenAnfangEnde(0)\nEnd Function\n\nFunction TestAufSonntag()\nCall TestWochenAnfangEnde(6)\nEnd Function\n\n\nFunction TestWochenAnfangEnde(ByVal WochentagsNr As Long)\n' WochentagsNr 0 = Montag\n' WochentagsNr 6 = folgender Sonntag\n\nIf WochentagsNr < 0 Then WochentagsNr = 0\nIf WochentagsNr > 6 Then WochentagsNr = 6\n\nDim ctlCurrentControl As control\nDim strControlName As String\nDim IstDate As Date\nDim strFormName As String\nDim frmCurrentForm As Form\n\nSet frmCurrentForm = Screen.ActiveForm\nSet ctlCurrentControl = Screen.ActiveControl\n\nstrFormName = frmCurrentForm.Name\nstrControlName = ctlCurrentControl.Name\n\nIf IsDate(ctlCurrentControl.Value) Then\n    IstDate = ctlCurrentControl.Value\n    IstDate = IstDate + 1 - Weekday(IstDate, vbMonday) + WochentagsNr\n    ctlCurrentControl.Value = IstDate\n'    MsgBox strFormName & \" - \" & strControlName & \" - \" & Format(IstDate, \"dddddd\")\nElse\n    If Len(Trim(Nz(ctlCurrentControl.Value))) > 0 Then\n       MsgBox strFormName & \" - \" & strControlName & \" - Is Nix\"\n    End If\nEnd If\n\nEnd Function\n\nFunction TestWochenAnfangEndeDate(ByVal X As Date, Optional ByVal WochentagsNr As Long = 0) As Date\n' WochentagsNr 0 = Montag\n' WochentagsNr 6 = folgender Sonntag\n\nDim IstDate As Date\n\nIf WochentagsNr < 0 Then WochentagsNr = 0\nIf WochentagsNr > 6 Then WochentagsNr = 6\nIf IsDate(X) Then\n    IstDate = X\n    IstDate = IstDate + 1 - Weekday(IstDate, vbMonday) + WochentagsNr\n    TestWochenAnfangEndeDate = IstDate\n'    MsgBox strFormName & \" - \" & strControlName & \" - \" & Format(IstDate, \"dddddd\")\nElse\n    TestWochenAnfangEndeDate = 0\nEnd If\n\nEnd Function\n\nFunction WochenMo(X As Variant) As Date\n\n' Übergabe String \"ww/yy\"\n'  also 17/07\n\nDim iWo As Long\nDim ijr As Long\n\nDim iSl As Long\n\niSl = InStr(1, X, \"/\")\n\nIf iSl > 0 Then\n    iWo = Mid(X, 1, iSl - 1)\n    ijr = Mid(X, iSl + 1) + 2000\n    WochenMo = fctKWMon(iWo, ijr)\nElse\n    WochenMo = 0\nEnd If\n\nEnd Function\n\n\nFunction WochenMo4(X As Variant) As Date\n\n' Übergabe String \"ww/yyyy\"\n'  also 17/2007\n\nDim iWo As Long\nDim ijr As Long\n\nDim iSl As Long\n\nIf Len(Trim(Nz(X))) = 0 Then Exit Function\n\niSl = InStr(1, X, \"/\")\n\nIf iSl > 0 Then\n    iWo = Mid(X, 1, iSl - 1)\n    ijr = Mid(X, iSl + 1)\n    WochenMo4 = fctKWMon(iWo, ijr)\nElse\n    WochenMo4 = 0\nEnd If\n\nEnd Function\n\nFunction WochenMo4X(X As Variant) As Date\n\n' Übergabe Zahl yyyyww\n'  also 200717\n\nDim iWo As Long\nDim ijr As Long\n\nDim iSl As Long\n\nIf Len(Trim(Nz(X))) <> 6 Then Exit Function\n\nijr = Left(X, 4)\niWo = Right(X, 2)\nWochenMo4X = fctKWMon(iWo, ijr)\n\nEnd Function\n\n\n\nFunction KWDiffber0(StartKW As Long, EndKW As Long) As Long\n\n'Verwendet Tabelle tblHilfKW daher nur zwischen 2005 und 2035 verwendbar\n\nDim StartJahr As Long\nDim EndJahr As Long\nDim StartKW1 As Long\nDim EndKW1 As Long\nDim Diff1 As Long\n\nStartJahr = Left(StartKW, 4)\nEndJahr = Left(EndKW, 4)\n\nIf StartJahr = EndJahr Then\n    Diff1 = EndKW - StartKW + 1\nElse\n    Diff1 = TCount(\"JJJJKW\", \"tblHilfKW\", \"JJJJKW >= \" & StartKW & \" AND JJJJKW <= \" & EndKW)\nEnd If\n\nKWDiffber0 = Diff1\n\nEnd Function\n\n\nFunction KWDiffber1(StartKW As Long, EndKW As Long, GesAnzKW As Long) As Long\n\n'Verwendet Tabelle tblHilfKW daher nur zwischen 2005 und 2035 verwendbar\n\nDim StartJahr As Long\nDim EndJahr As Long\nDim StartKW1 As Long\nDim EndKW1 As Long\nDim Diff1 As Long\n\nStartJahr = Left(StartKW, 4)\nEndJahr = Left(EndKW, 4)\n\nIf StartJahr = EndJahr Then\n    Diff1 = EndKW - StartKW + 1\nElse\n    Diff1 = TCount(\"JJJJKW\", \"tblHilfKW\", \"JJJJKW >= \" & StartKW & \" AND JJJJKW <= \" & EndKW)\nEnd If\n\nKWDiffber1 = GesAnzKW - Diff1\n\nEnd Function\n\n\nFunction fYrweekNoPretty(X As Date) As Variant\n' Gibt \"ww / yyyy (tt.mm.jjjj)\" zurück\nDim iYr As Long\nDim iyr1 As Long\nDim iwk As Long\nDim iwk1 As Long\n\niYr = year(X)\niwk = Format(X, \"ww\", vbMonday, vbFirstFourDays)\niyr1 = year(X + 7)\nIf Format(X + 7, \"ww\", vbMonday, vbFirstFourDays) = 2 Then\n    iwk = 1\n    iYr = iyr1\nEnd If\n\nfYrweekNoPretty = Right(\"00\" & iwk, 2) & \" / \" & iYr & \" - (\" & Format(X, \"dd.mm.yyyy\", 2, 2) & \")\"\n\nEnd Function\n\nFunction HW_GibNr(JJJJKW As Long) As Long\nHW_GibNr = TLookup(\"LfdNr\", \"tblHilfKW\", \"JJJJKW = \" & JJJJKW)\nEnd Function\n\nFunction HWDat_GibNr(X As Date) As Long\nDim JJJJKW As Long\nJJJJKW = fYrweekNo(X)\nHWDat_GibNr = TLookup(\"LfdNr\", \"tblHilfKW\", \"JJJJKW = \" & JJJJKW)\nEnd Function\n\nFunction HW_GibKW(LfdNr As Long) As Long\nHW_GibKW = TLookup(\"JJJJKW\", \"tblHilfKW\", \"LfdNr = \" & LfdNr)\nEnd Function\n\nFunction HW_GibJJ(LfdNr As Long) As Long\nHW_GibJJ = TLookup(\"Jahr\", \"tblHilfKW\", \"LfdNr = \" & LfdNr)\nEnd Function\n\n\nFunction HW_GibDat(LfdNr As Long) As Date\nHW_GibDat = TLookup(\"StartDatum\", \"tblHilfKW\", \"LfdNr = \" & LfdNr)\nEnd Function\n\n\nFunction IsLeapYear(dt As Date) As Boolean\nIsLeapYear = (CLng(Format(DateSerial(year(dt), 12, 31), \"y\", 2, 2)) - 365) * -1\nEnd Function\n\n\nFunction HWL_GibXlNr(JJJJKW As Long) As Long\nHWL_GibXlNr = TLookup(\"SpalteNr\", \"tblHilfKWLokal\", \"JJJJKW = \" & JJJJKW)\nEnd Function\n\nFunction HWLDat_GibXLNr(X As Date) As Long\nDim JJJJKW As Long\nJJJJKW = fYrweekNo(X)\nHWLDat_GibXLNr = TLookup(\"SpalteNr\", \"tblHilfKWLokal\", \"JJJJKW = \" & JJJJKW)\nEnd Function\n\n'Function HW_GibNr(JJJJKW As Long) As Long\n'Function HWDat_GibNr(x As Date) As Long\n\n'Function HWL_GibXLNr(JJJJKW As Long) As Long\n'Function HWLDat_GibXLNr(x As Date) As Long\n\n'Function HW_GibKW(LfdNr As Long) As Long\n'Function HW_GibDat(LfdNr As Long) As Date\n'Function HW_GibJJ(LfdNr As Long) As Long\n\n\n\nPublic Function LaufMon2DateMon(iMon As Long, Optional istartJahr As Long = 0, Optional istartMon As Long = 0) As Date\nIf istartJahr = 0 Then istartJahr = year(Date)\nIf istartMon = 0 Then istartMon = Month(Date)\nDim i As Long, i1 As Long, iYr As Long\niYr = istartJahr\ni1 = istartMon\ni = iMon\nIf istartMon <> 1 Then\n    i = i + i1 - 1\n    If i > 12 Then\n        i = i - 12\n        iYr = iYr + 1\n    End If\nEnd If\n\nLaufMon2DateMon = DateSerial(iYr, i, 1)\nEnd Function\n\nPublic Function DateMon2LaufMon(iMon As Long, Optional istartJahr As Long = 0, Optional istartMon As Long = 0) As Date\nIf istartJahr = 0 Then istartJahr = year(Date)\nIf istartMon = 0 Then istartMon = Month(Date)\nDim i As Long, i1 As Long, iYr As Long\niYr = istartJahr\ni = iMon\ni1 = i\nIf istartMon <> 1 Then\n    i1 = iMon - istartMon + 1\n    If i1 < 1 Then\n        i1 = i1 + 12\n        iYr = iYr + 1\n    End If\nEnd If\n\nDateMon2LaufMon = DateSerial(iYr, i1, 1)\nEnd Function\n\nPublic Function btn2Date(btnName As String, Optional istartJahr As Long = 0, Optional istartMon As Long = 0) As Date\nIf istartJahr = 0 Then istartJahr = year(Date)\nIf istartMon = 0 Then istartMon = Month(Date)\n' Me(\"btn\" & i1 & \"Tg\" & j & k)\n\nDim X, ilMon, iKW, iwt, i, iTag, i1 As Long, ijr, dt1, wkd1\nX = btnName\nX = Mid(X, 4)\ni = InStr(1, X, \"Tg\")\ni1 = Mid(X, 1, i - 1)\nX = Mid(X, i + 2)\niKW = Left(X, 1)\niwt = Right(X, 1)\ndt1 = LaufMon2DateMon(i1, istartJahr, istartMon)\nwkd1 = Weekday(DateSerial(year(dt1), Month(dt1), 1), 2)\niTag = (iKW * 7) + iwt - wkd1 + 1\n\nbtn2Date = DateSerial(year(dt1), Month(dt1), iTag)\nEnd Function\n\n\n\nPublic Function Date2btn(btnDatum As Date, Optional istartJahr As Long = 0, Optional istartMon As Long = 0) As String\nIf istartJahr = 0 Then istartJahr = year(Date)\nIf istartMon = 0 Then istartMon = Month(Date)\n'Me(\"btn\" & i1 & \"Tg\" & j & k)\nDim dt1 As Date, i1 As Long\n dt1 = DateMon2LaufMon(Month(btnDatum), istartJahr, istartMon)\n i1 = Month(dt1)\n\n'iday: Tag ([KalDatum])\n'idiwk: Format(DatSeriel([iJahr];[i];1);\"w\";2;2)-1\n'ikw: (([iday]+[diwk]-1)\\7)+1\n'btnname: \"btn\" & [i1] & \"Tg\" & [kw] & [WochentagNr]\n'ijahr: Jahr ([KalDatum])\n'i: Monat ([KalDatum])\n'i1: Monat ([in der Maske])\nDim iday, idiwk, iKW, iwotg, iJahr, i\niJahr = year(btnDatum)\ni = Month(btnDatum)\niday = Day(btnDatum)\nidiwk = Format(DateSerial(iJahr, i, 1), \"w\", 2, 2) - 1 ' Wochentag Monatsanfang\niKW = ((iday + idiwk - 1) \\ 7) + 1\niwotg = Format(btnDatum, \"w\", 2, 2)\nDate2btn = \"btn\" & i1 & \"Tg\" & iKW & iwotg\n\nEnd Function\n\n\n\nFunction StdZeitraum_Von_Bis(Zeitraum As Long, Me_vonDat As Date, Me_bisDat As Date)\n\n    Dim iwkday As Long\n    Dim iQ As Long\n    Dim iM As Long\n    \n    'Sort     'ID Bemerkung\n    '1        '1   Heute\n    '2        '17  Die nächsten 90 Tage\n    '3        '4   Aktuelle Woche\n    '4        '8   Aktueller Monat\n    '5        '14  Aktuelles Quartal\n    '6        '11  Aktuelles Jahr\n    '7        '18  Nächster Monat\n    '8        '19  Die nächsten 90 Tage\n    '9        '20  Nächstes Jahr\n    '\n    '10        '2   Gestern\n    '11        '3   Vorgestern\n    '12        '5   Die letzten 7 Tage\n    '13        '6   Letzte Woche\n    '14        '7   Vorletzte Woche\n    '15        '15  Letztes Quartal\n    '16        '16  Die letzten 90 Tage\n    '17        '9   Letzter Monat\n    '18        '10  Vorletzter Monat\n    '19        '12  Letztes Jahr\n    '20        '13  Vorletztes Jahr\n    '750       '21  Nächstes Quartal\n    '201       '23  Die nächsten 10 Tage\n    \n    iwkday = Weekday(Date, 2)\n    \n    Select Case Zeitraum\n        Case 2\n            Me_vonDat = Date - 1\n            Me_bisDat = Date - 1\n        Case 3\n            Me_vonDat = Date - 2\n            Me_bisDat = Date - 2\n        Case 4\n            Me_vonDat = Date - iwkday + 1\n            Me_bisDat = Date - iwkday + 6\n        Case 5\n            Me_vonDat = Date - 6\n            Me_bisDat = Date\n        Case 6\n            Me_vonDat = Date - iwkday + 1 - 7\n            Me_bisDat = Date - iwkday\n        Case 7\n            Me_vonDat = Date - iwkday + 1 - 14\n            Me_bisDat = Date - iwkday - 7\n        Case 8\n            Me_vonDat = DateSerial(year(Date), Month(Date), 1)\n            Me_bisDat = DateSerial(year(Date), Month(Date) + 1, 0)\n        Case 9\n            Me_vonDat = DateSerial(year(Date), Month(Date) - 1, 1)\n            Me_bisDat = DateSerial(year(Date), Month(Date), 0)\n        Case 10\n            Me_vonDat = DateSerial(year(Date), Month(Date) - 2, 1)\n            Me_bisDat = DateSerial(year(Date), Month(Date) - 1, 0)\n        Case 11\n            Me_vonDat = DateSerial(year(Date), 1, 1)\n            Me_bisDat = DateSerial(year(Date), 12, 31)\n        Case 12\n            Me_vonDat = DateSerial(year(Date) - 1, 1, 1)\n            Me_bisDat = DateSerial(year(Date) - 1, 12, 31)\n'        Case 13\n'            Me_vonDat = DateSerial(Year(Date) - 2, 1, 1)\n'            Me_bisDat = DateSerial(Year(Date) - 2, 12, 31)\n        Case 13\n            Me_vonDat = DateSerial(year(Date), Month(Date) - 2, 1)\n            Me_bisDat = DateSerial(year(Date), Month(Date), -1)\n'        Case 14\n'            iQ = Format(Date, \"q\", 2, 2)\n'            iM = (iQ - 1) * 3 + 1\n'            Me_vonDat = DateSerial(Year(Date), iM, 1)\n'            Me_bisDat = DateSerial(Year(Date), iM + 3, 0)\n        Case 14\n            Me_vonDat = DateSerial(year(Date), Month(Date) - 3, 1)\n            Me_bisDat = DateSerial(year(Date), Month(Date), -1)\n        Case 15\n            iQ = Format(Date, \"q\", 2, 2)\n            iM = (iQ - 1) * 3 + 1\n            Me_vonDat = DateSerial(year(Date), iM - 3, 1)\n            Me_bisDat = DateSerial(year(Date), iM, 0)\n        Case 16\n            Me_bisDat = Date\n            Me_vonDat = Date - 90\n        Case 17\n            Me_bisDat = Date + 90\n            Me_vonDat = Date\n        Case 18\n            Me_bisDat = DateSerial(year(Date), Month(Date) + 2, 0)\n            Me_vonDat = DateSerial(year(Date), Month(Date) + 1, 1)\n        Case 19\n            Me_bisDat = Date + 90\n            Me_vonDat = Date\n        Case 20\n            Me_vonDat = DateSerial(year(Date) + 1, 1, 1)\n            Me_bisDat = DateSerial(year(Date) + 1, 12, 31)\n        Case 21\n            iQ = Format(Date, \"q\", 2, 2)\n            iM = ((iQ - 1) * 3 + 1) + 3\n            Me_vonDat = DateSerial(year(Date), iM, 1)\n            Me_bisDat = DateSerial(year(Date), iM + 3, 0)\n        \n        Case 22\n            Me_vonDat = Date\n            Me_bisDat = Date + 30\n        \n        Case 23\n            Me_vonDat = Date\n            Me_bisDat = Date + 10\n        \n        Case 24\n            Me_vonDat = Date\n            Me_bisDat = Date + 14\n        \n        Case 25\n            Me_vonDat = Date\n            Me_bisDat = Date + 1000\n        \n        Case 26\n            Me_vonDat = DateSerial(year(Date), 1, 1)\n            Me_bisDat = Date\n            \n        Case 27\n            Me_vonDat = Date + 1\n            Me_bisDat = Date + 1000\n        \n        Case Else ' Heute\n            Me_vonDat = Date\n            Me_bisDat = Date\n    End Select\n    DoEvents\n\nEnd Function\n"}
