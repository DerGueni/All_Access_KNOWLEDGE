{"id":"MOD_mdl_AI_KnowledgeLoader","name":"mdl_AI_KnowledgeLoader","kind":"standard","procedures":["Public Function AIK_EnsureLoaded() As Boolean","Public Function AIK_TableExists(ByVal tbl As String) As Boolean","Public Function AIK_FormExists(ByVal frm As String) As Boolean","Public Function AIK_GetFormRecordSource(ByVal frm As String) As String","Public Function AIK_ListFormControls(ByVal frm As String) As String","Public Function AIK_GetDependencies(ByVal objName As String) As String","Public Function AIK_Search(ByVal needle As String) As Boolean","Public Sub AIK_DumpSummary()","Private Function AIK_Root() As String","Private Function AIK_KnowledgeDir() As String","Private Function AIK_LogFile() As String","Private Sub AIK_EnsureDir(ByVal p As String)","Private Sub AIK_Log(ByVal msg As String)","Private Function AIK_ReadFile(ByVal p As String) As String","Private Sub AIK_InitStores()","Private Sub AIK_LoadAll()","Private Sub AIK_CollectControls(ByVal f As Form, ByVal list As Object, ByVal prefix As String)","Private Sub AIK_ScanFormsIntoCaches()","Public Sub AIK_BuildFormLexikon()","Private Sub AIK_ParseNamesFromJSON(ByVal js As String)","Private Sub AIK_ConsiderName(ByVal nm As String)","Private Sub AIK_LoadDependencies(ByVal txt As String)","Private Sub AIK_AddDeps(ByVal lhs As String, ByVal rhsList As String)","Private Sub AIK_LoadFormLexikon(ByVal txt As String)","Private Function AIK_NewArrayList() As Object","Private Sub AIK_ArrayListAddUnique(ByVal arr As Object, ByVal Value As String)"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"'=== mdl_AI_KnowledgeLoader ==============================================\nOption Compare Database\nOption Explicit\n\n' --- Modulzustand / Caches ---\nPrivate mLoaded     As Boolean\nPrivate mTables     As Object   ' Scripting.Dictionary (Set)\nPrivate mForms      As Object   ' Scripting.Dictionary (Set)\nPrivate mDeps       As Object   ' Map: object -> ArrayList(deps)\nPrivate mFormRS     As Object   ' Map: form -> recordsource\nPrivate mFormCtrls  As Object   ' Map: form -> ArrayList(control names)\nPrivate mRawJSON    As String   ' Roh-JSON/Volltext\n\n'==================== Öffentliche API ====================\n\nPublic Function AIK_EnsureLoaded() As Boolean\n    On Error GoTo EH\n    If mLoaded Then AIK_EnsureLoaded = True: Exit Function\n    AIK_InitStores\n    AIK_LoadAll\n    mLoaded = True\n    AIK_EnsureLoaded = True\n    Exit Function\nEH:\n    mLoaded = False\n    AIK_Log \"AIK_EnsureLoaded ERROR: \" & err.Number & \" / \" & err.description\nEnd Function\n\nPublic Function AIK_TableExists(ByVal tbl As String) As Boolean\n    If Not mLoaded Then Call AIK_EnsureLoaded\n    AIK_TableExists = (mTables.exists(LCase$(Trim$(tbl))))\nEnd Function\n\nPublic Function AIK_FormExists(ByVal frm As String) As Boolean\n    If Not mLoaded Then Call AIK_EnsureLoaded\n    AIK_FormExists = (mForms.exists(LCase$(Trim$(frm))))\nEnd Function\n\nPublic Function AIK_GetFormRecordSource(ByVal frm As String) As String\n    If Not mLoaded Then Call AIK_EnsureLoaded\n    frm = LCase$(Trim$(frm))\n    If mFormRS.exists(frm) Then\n        AIK_GetFormRecordSource = mFormRS(frm)\n    Else\n        AIK_GetFormRecordSource = \"\"\n    End If\nEnd Function\n\n' Gibt Komma-Liste bekannter Controls eines Formulars zurück\nPublic Function AIK_ListFormControls(ByVal frm As String) As String\n    If Not mLoaded Then Call AIK_EnsureLoaded\n    frm = LCase$(Trim$(frm))\n    If mFormCtrls.exists(frm) Then\n        AIK_ListFormControls = Join(mFormCtrls(frm).ToArray, \",\")\n    Else\n        AIK_ListFormControls = \"\"\n    End If\nEnd Function\n\n' Abhängigkeiten als Komma-Liste\nPublic Function AIK_GetDependencies(ByVal objName As String) As String\n    If Not mLoaded Then Call AIK_EnsureLoaded\n    objName = LCase$(Trim$(objName))\n    If mDeps.exists(objName) Then\n        AIK_GetDependencies = Join(mDeps(objName).ToArray, \",\")\n    Else\n        AIK_GetDependencies = \"\"\n    End If\nEnd Function\n\n' Grobe Volltextsuche\nPublic Function AIK_Search(ByVal needle As String) As Boolean\n    If Not mLoaded Then Call AIK_EnsureLoaded\n    needle = LCase$(Trim$(needle))\n    AIK_Search = (InStr(1, mRawJSON, needle, vbTextCompare) > 0) _\n                 Or mTables.exists(needle) _\n                 Or mForms.exists(needle)\nEnd Function\n\n' Diagnose\nPublic Sub AIK_DumpSummary()\n    If Not mLoaded Then Call AIK_EnsureLoaded\n    Debug.Print \"=== AIK SUMMARY ===\"\n    Debug.Print \"Tables:   \"; mTables.Count\n    Debug.Print \"Forms:    \"; mForms.Count\n    Debug.Print \"Deps:     \"; mDeps.Count\n    Debug.Print \"FormRS:   \"; mFormRS.Count\n    Debug.Print \"FormCtrl: \"; mFormCtrls.Count\n    AIK_Log \"AIK Summary: TBL=\" & mTables.Count & \" FORM=\" & mForms.Count & \" DEP=\" & mDeps.Count\nEnd Sub\n\n'==================== Pfade / Logging ====================\n\nPrivate Function AIK_Root() As String\n    AIK_Root = Environ$(\"USERPROFILE\") & \"\\Documents\\000_Runner\"\nEnd Function\n\nPrivate Function AIK_KnowledgeDir() As String\n    AIK_KnowledgeDir = AIK_Root() & \"\\Consys_Knowledge\\FE_Abhaengigkeiten\"\nEnd Function\n\nPrivate Function AIK_LogFile() As String\n    AIK_LogFile = AIK_Root() & \"\\logs\\access_runner_log.txt\"\nEnd Function\n\nPrivate Sub AIK_EnsureDir(ByVal p As String)\n    On Error Resume Next\n    If Len(Dir(p, vbDirectory)) = 0 Then MkDir p\nEnd Sub\n\nPrivate Sub AIK_Log(ByVal msg As String)\n    On Error Resume Next\n    AIK_EnsureDir AIK_Root()\n    AIK_EnsureDir AIK_Root() & \"\\logs\"\n    Dim f As Integer: f = FreeFile\n    Open AIK_LogFile For Append As #f\n        Print #f, Format(Now, \"yyyy-mm-dd hh:nn:ss\"); \"  - \"; msg\n    Close #f\nEnd Sub\n\nPrivate Function AIK_ReadFile(ByVal p As String) As String\n    On Error GoTo EH\n    Dim h As Integer, L As Long, b() As Byte, i As Long, s As String\n    If Len(Dir(p)) = 0 Then Exit Function\n    h = FreeFile\n    Open p For Binary As #h\n        L = LOF(h)\n        If L > 0 Then\n            ReDim b(1 To L)\n            Get #h, , b\n        End If\n    Close #h\n    For i = LBound(b) To UBound(b)\n        If b(i) <> 0 Then s = s & Chr$(b(i))\n    Next\n    s = Replace(s, \"ï»¿\", \"\")\n    s = Replace(s, ChrW$(&HFEFF), \"\")\n    AIK_ReadFile = s\n    Exit Function\nEH:\n    AIK_ReadFile = \"\"\nEnd Function\n\n'==================== Init / Laden ====================\n\nPrivate Sub AIK_InitStores()\n    Set mTables = CreateObject(\"Scripting.Dictionary\")\n    Set mForms = CreateObject(\"Scripting.Dictionary\")\n    Set mDeps = CreateObject(\"Scripting.Dictionary\")\n    Set mFormRS = CreateObject(\"Scripting.Dictionary\")\n    Set mFormCtrls = CreateObject(\"Scripting.Dictionary\")\n    mTables.RemoveAll: mForms.RemoveAll: mDeps.RemoveAll\n    mFormRS.RemoveAll: mFormCtrls.RemoveAll\n    mRawJSON = \"\"\nEnd Sub\n\n' Auto-Fallback + Laden aller Quellen\nPrivate Sub AIK_LoadAll()\n    On Error Resume Next\n    Dim base As String: base = AIK_KnowledgeDir()\n    Dim lex As String:  lex = base & \"\\FormLexikon.md\"\n\n    ' Lexikon automatisch erzeugen, wenn fehlend/zu klein\n    If Len(Dir(lex)) = 0 Or (fileLen(lex) < 50) Then\n        AIK_BuildFormLexikon\n    Else\n        ' Caches zumindest initialisieren\n        If mFormRS Is Nothing Then Set mFormRS = CreateObject(\"Scripting.Dictionary\")\n        If mFormCtrls Is Nothing Then Set mFormCtrls = CreateObject(\"Scripting.Dictionary\")\n    End If\n\n    ' 1) JSON\n    mRawJSON = AIK_ReadFile(base & \"\\Enhanced_Knowledge.json\")\n    AIK_ParseNamesFromJSON mRawJSON\n\n    ' 2) Dependencies\n    AIK_LoadDependencies AIK_ReadFile(base & \"\\DependencyLinks.txt\")\n    AIK_LoadDependencies AIK_ReadFile(base & \"\\DependencyObjects.txt\")\n\n    ' 3) FormLexikon aus Datei (zur Sicherheit nachziehen)\n    AIK_LoadFormLexikon AIK_ReadFile(lex)\n\n    AIK_Log \"AIK loaded. TBL=\" & mTables.Count & \" FORM=\" & mForms.Count & \" DEP=\" & mDeps.Count\nEnd Sub\n\n'==================== Builder / Scanner ====================\n\n' Rekursiv Controls einsammeln (inkl. Subforms)\nPrivate Sub AIK_CollectControls(ByVal f As Form, ByVal list As Object, ByVal prefix As String)\n    On Error Resume Next\n    Dim c As control\n    For Each c In f.controls\n        Select Case c.ControlType\n            Case acTextBox, acComboBox, acListBox, acCommandButton, _\n                 acCheckBox, acOptionButton, acToggleButton, acTabCtl, _\n                 acPage, acLabel, acSubform\n                Dim nm As String: nm = LCase$(prefix & c.Name)\n                If Len(nm) > 0 Then If list.IndexOf(nm) < 0 Then list.Add nm\n                If c.ControlType = acSubform Then\n                    If Not c.Form Is Nothing Then\n                        AIK_CollectControls c.Form, list, nm & \"!\"\n                    End If\n                End If\n        End Select\n    Next\nEnd Sub\n\n' Alle Forms scannen und direkt in Caches schreiben\nPrivate Sub AIK_ScanFormsIntoCaches()\n    On Error GoTo EH\n    Dim i As Long, ao As AccessObject, frmName As String, wasOpen As Boolean\n\n    Application.Echo False\n    DoCmd.SetWarnings False\n\n    If mFormRS Is Nothing Then Set mFormRS = CreateObject(\"Scripting.Dictionary\")\n    If mFormCtrls Is Nothing Then Set mFormCtrls = CreateObject(\"Scripting.Dictionary\")\n\n    For i = 0 To CurrentProject.AllForms.Count - 1\n        Set ao = CurrentProject.AllForms(i)\n        frmName = ao.Name\n        If Len(frmName) = 0 Then GoTo CONT\n\n        wasOpen = (SysCmd(acSysCmdGetObjectState, acForm, frmName) And acObjStateOpen) <> 0\n        If Not wasOpen Then\n            DoCmd.OpenForm frmName, acDesign, , , , acHidden\n        End If\n\n        On Error Resume Next\n        mFormRS(LCase$(frmName)) = Nz(Forms(frmName).recordSource & \"\", \"\")\n        On Error GoTo EH\n\n        Dim al As Object: Set al = CreateObject(\"System.Collections.ArrayList\")\n        AIK_CollectControls Forms(frmName), al, \"\"\n        mFormCtrls(LCase$(frmName)) = al\n\n        If Not mForms.exists(LCase$(frmName)) Then mForms.Add LCase$(frmName), True\n\n        If Not wasOpen Then\n            DoCmd.Close acForm, frmName, acSaveNo\n        End If\nCONT:\n    Next i\n\n    DoCmd.SetWarnings True\n    Application.Echo True\n    Exit Sub\nEH:\n    DoCmd.SetWarnings True\n    Application.Echo True\n    AIK_Log \"AIK_ScanFormsIntoCaches ERROR: \" & err.Number & \" / \" & err.description\nEnd Sub\n\n' FormLexikon neu erzeugen (und Caches füllen)\nPublic Sub AIK_BuildFormLexikon()\n    On Error GoTo EH\n    Dim base As String, fn As String, f As Integer, k As Variant, lst As Object\n\n    base = AIK_KnowledgeDir()\n    AIK_EnsureDir AIK_Root()\n    AIK_EnsureDir AIK_Root() & \"\\Consys_Knowledge\"\n    AIK_EnsureDir base\n\n    ' frisch scannen\n    If mFormRS Is Nothing Then Set mFormRS = CreateObject(\"Scripting.Dictionary\")\n    If mFormCtrls Is Nothing Then Set mFormCtrls = CreateObject(\"Scripting.Dictionary\")\n    mFormRS.RemoveAll: mFormCtrls.RemoveAll\n\n    AIK_ScanFormsIntoCaches\n\n    ' Datei schreiben\n    fn = base & \"\\FormLexikon.md\"\n    f = FreeFile\n    Open fn For Output As #f\n        Print #f, \"# FormLexikon (auto-generated)\"\n        Print #f, \"\"\n        For Each k In mFormRS.Keys\n            Print #f, \"Form: \" & k\n            Print #f, \"RecordSource: \" & mFormRS(k)\n            Set lst = mFormCtrls(k)\n            If Not lst Is Nothing Then\n                If lst.Count > 0 Then\n                    Print #f, \"Controls: \" & Join(lst.ToArray, \", \")\n                Else\n                    Print #f, \"Controls: \"\n                End If\n            Else\n                Print #f, \"Controls: \"\n            End If\n            Print #f, \"\"\n        Next k\n    Close #f\n\n    AIK_Log \"AIK_BuildFormLexikon OK: \" & fn & \" (Forms=\" & mFormRS.Count & \")\"\n    Exit Sub\nEH:\n    AIK_Log \"AIK_BuildFormLexikon ERROR: \" & err.Number & \" / \" & err.description\nEnd Sub\n\n'==================== Parser für Dateien ====================\n\n' leichte JSON-Namenernte (Heuristik)\nPrivate Sub AIK_ParseNamesFromJSON(ByVal js As String)\n    On Error Resume Next\n    Dim L As Long: L = Len(js)\n    If L = 0 Then Exit Sub\n\n    Dim i As Long, token As String, inQuote As Boolean, buf As String\n    For i = 1 To L\n        token = Mid$(js, i, 1)\n        If token = \"\"\"\" Then\n            inQuote = Not inQuote\n            If Not inQuote Then\n                AIK_ConsiderName buf\n                buf = \"\"\n            End If\n        ElseIf inQuote Then\n            buf = buf & token\n        End If\n    Next\nEnd Sub\n\nPrivate Sub AIK_ConsiderName(ByVal nm As String)\n    On Error Resume Next\n    Dim k As String: k = LCase$(Trim$(nm))\n    If Len(k) = 0 Then Exit Sub\n    If Left$(k, 4) = \"tbl_\" Then If Not mTables.exists(k) Then mTables.Add k, True\n    If Left$(k, 4) = \"frm_\" Then If Not mForms.exists(k) Then mForms.Add k, True\nEnd Sub\n\n' Dependencies: akzeptiert \"A -> B,C\" und \"A: B,C\"\nPrivate Sub AIK_LoadDependencies(ByVal txt As String)\n    On Error Resume Next\n    If Len(Trim$(txt)) = 0 Then Exit Sub\n\n    Dim lines() As String, i As Long, ln As String\n    lines = Split(Replace(Replace(txt, vbCr, vbLf), vbLf & vbLf, vbLf), vbLf)\n\n    For i = LBound(lines) To UBound(lines)\n        ln = Trim$(lines(i))\n        If Len(ln) = 0 Then GoTo CONT\n\n        Dim lhs As String, rhs As String, p As Long\n\n        p = InStr(1, ln, \"->\", vbTextCompare)\n        If p > 0 Then\n            lhs = Trim$(Left$(ln, p - 1))\n            rhs = Trim$(Mid$(ln, p + 2))\n            AIK_AddDeps lhs, rhs\n            GoTo CONT\n        End If\n\n        p = InStr(1, ln, \":\", vbTextCompare)\n        If p > 0 Then\n            lhs = Trim$(Left$(ln, p - 1))\n            rhs = Trim$(Mid$(ln, p + 1))\n            AIK_AddDeps lhs, rhs\n            GoTo CONT\n        End If\nCONT:\n    Next i\nEnd Sub\n\nPrivate Sub AIK_AddDeps(ByVal lhs As String, ByVal rhsList As String)\n    On Error Resume Next\n    Dim a As Variant, i As Long, key As String\n    key = LCase$(Replace(lhs, \" \", \"\"))\n    If Not mDeps.exists(key) Then mDeps.Add key, AIK_NewArrayList()\n\n    a = Split(rhsList, \",\")\n    For i = LBound(a) To UBound(a)\n        Dim item As String\n        item = LCase$(Trim$(a(i)))\n        item = Replace(item, \" \", \"\")\n        If Len(item) > 0 Then AIK_ArrayListAddUnique mDeps(key), item\n    Next\nEnd Sub\n\n' FormLexikon.md einlesen (falls schon vorhanden)\nPrivate Sub AIK_LoadFormLexikon(ByVal txt As String)\n    On Error Resume Next\n    If Len(Trim$(txt)) = 0 Then Exit Sub\n\n    Dim lines() As String, i As Long, ln As String, curForm As String\n    lines = Split(Replace(Replace(txt, vbCr, vbLf), vbLf & vbLf, vbLf), vbLf)\n\n    For i = LBound(lines) To UBound(lines)\n        ln = Trim$(lines(i))\n        If Len(ln) = 0 Then GoTo CONT\n\n        If LCase$(Left$(ln, 5)) = \"form:\" Or LCase$(Left$(ln, 6)) = \"form =\" Then\n            curForm = LCase$(Trim$(Mid$(ln, InStr(ln, \":\") + 1)))\n            If Not mForms.exists(curForm) And Left$(curForm, 4) = \"frm_\" Then mForms(curForm) = True\n            GoTo CONT\n        End If\n        If Left$(LCase$(ln), 4) = \"frm_\" Then\n            curForm = LCase$(ln)\n            If Not mForms.exists(curForm) Then mForms(curForm) = True\n            GoTo CONT\n        End If\n\n        If InStr(1, LCase$(ln), \"recordsource\", vbTextCompare) > 0 And curForm <> \"\" Then\n            Dim p As Long: p = InStr(1, ln, \":\", vbTextCompare)\n            If p > 0 Then mFormRS(curForm) = Trim$(Mid$(ln, p + 1))\n            GoTo CONT\n        End If\n\n        If InStr(1, LCase$(ln), \"controls\", vbTextCompare) > 0 And curForm <> \"\" Then\n            Dim listStr As String, arr As Variant, j As Long\n            listStr = Trim$(Mid$(ln, InStr(1, ln, \":\") + 1))\n            arr = Split(listStr, \",\")\n            Dim col As Object: Set col = AIK_NewArrayList\n            For j = LBound(arr) To UBound(arr)\n                Dim c As String: c = LCase$(Trim$(arr(j)))\n                If Len(c) > 0 Then AIK_ArrayListAddUnique col, c\n            Next\n            mFormCtrls(curForm) = col\n            GoTo CONT\n        End If\nCONT:\n    Next i\nEnd Sub\n\n'==================== kleine Hilfen ====================\n\nPrivate Function AIK_NewArrayList() As Object\n    Set AIK_NewArrayList = CreateObject(\"System.Collections.ArrayList\")\nEnd Function\n\nPrivate Sub AIK_ArrayListAddUnique(ByVal arr As Object, ByVal Value As String)\n    On Error Resume Next\n    If arr Is Nothing Then Exit Sub\n    If arr.IndexOf(Value) < 0 Then arr.Add Value\nEnd Sub\n\n'=== END mdl_AI_KnowledgeLoader ==========================================\n\n"}
