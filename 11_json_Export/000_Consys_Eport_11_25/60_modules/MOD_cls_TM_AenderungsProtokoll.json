{"id":"MOD_cls_TM_AenderungsProtokoll","name":"cls_TM_AenderungsProtokoll","kind":"standard","procedures":["Public Sub Init(Optional frmFormular As Form, _","Private Sub Class_Initialize()","Private Sub Class_Terminate()","Private Sub mp_frmForm_BeforeUpdate(Cancel As Integer)","Private Sub mp_frmForm_AfterUpdate()","Private Sub mp_frmForm_Delete(Cancel As Integer)","Private Sub mp_frmForm_AfterDelConfirm(Status As Integer)","Private Sub mp_cmdButtonProtokollÖffnen_Click()","Private Function ErmittleComputerName() As String","Private Function ErmittleUserName() As String","Private Sub ComboDetails(ctlCombo As control, ByRef strAlterWert As String, ByRef strNeuerWert As String)","Private Sub ListDetails(ctlList As control, ByRef strAlterWert As String, ByRef strNeuerWert As String)"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\n'############################\n' ToDo's:\n' -\n'\n' Langfristige Wünsche:\n' - Änderungen auf Wunsch rückgängig\n'   machen (???)\n\n\n'############################\n' API's\n'############################\nPrivate Declare PtrSafe Function GetComputerName Lib \"kernel32\" Alias \"GetComputerNameA\" (ByVal lpBuffer As String, nSize As Long) As Long\nPrivate Declare PtrSafe Function GetUserName Lib \"advapi32.dll\" Alias \"GetUserNameA\" (ByVal lpBuffer As String, nSize As Long) As Long\nPrivate Declare PtrSafe Function SafeArrayGetDim Lib \"oleaut32\" (pArray() As Any) As Long\n\n'############################\n' Enumerationen\n'############################\n\nPublic Enum tmEnum_DatensatzNeu\n    tmc_NurDatensatzNeu = 0\n    tmc_DatensatzNeuUndEinzelwerte = 1\nEnd Enum\n\nPublic Enum tmEnum_DatensatzGelöscht\n    tmc_DatensatzGelöschtSpeichern = 0\n    tmc_AlleEinträgeImProtokollLöschen = 1\nEnd Enum\n\n'############################\n' Typen\n'############################\nPrivate Type TM_Änderung\n    DSNr As String\n    Wert_Name As String\n    Wert_Alt As String\n    Wert_Neu As String\n    Datum As String\n    benutzer As String\n    UserName As String\n    ComputerName As String\nEnd Type\n\n'############################\n' Membervariablen der Klasse\n'############################\n\nDim WithEvents mp_frmForm As Access.Form\nDim WithEvents mp_cmdButtonProtokollÖffnen As Access.CommandButton\nDim mp_txtPrimaryKeyControl As Access.TextBox\nDim mp_strProtokollTab As String\nDim mp_strFormName As String\nDim mp_intDatensatzNeu As Integer\nDim mp_intDatensatzGelöscht As Integer\nDim mp_fLöschenProtokollieren As Boolean\nDim m_strIDGelöscht As String\nDim m_aÄnderung() As TM_Änderung\nDim m_db As DAO.Database\n\n'############################\n' Properties der Klasse\n'############################\n\nPublic Property Set Formular(ByRef frmFormular As Access.Form)\n'Fehlerbehandlung definieren\nOn Error GoTo Err_Formular\n\n    Set mp_frmForm = frmFormular\n    mp_strFormName = mp_frmForm.Name\n    mp_frmForm.BeforeUpdate = \"[Event Procedure]\"\n    mp_frmForm.AfterUpdate = \"[Event Procedure]\"\n    mp_frmForm.AfterUpdate = \"[Event Procedure]\"\n    mp_frmForm.OnDelete = \"[Event Procedure]\"\n    mp_frmForm.AfterDelConfirm = \"[Event Procedure]\"\n\n'Ende\nExit_Formular:\n    On Error Resume Next\n    Exit Property\n\n'Fehlerbehandlung\nErr_Formular:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_TM_ÄnderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  Formular\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_Formular\n    End Select\n\nEnd Property\n\nPublic Property Set ButtonProtokollÖffnen(ByRef cmdNewButtonProtokollÖffnen As Access.CommandButton)\n'Fehlerbehandlung definieren\nOn Error GoTo Err_ButtonProtokollÖffnen\n\n    Set mp_cmdButtonProtokollÖffnen = cmdNewButtonProtokollÖffnen\n    mp_cmdButtonProtokollÖffnen.onClick = \"[Event Procedure]\"\n\n'Ende\nExit_ButtonProtokollÖffnen:\n    On Error Resume Next\n    Exit Property\n\n'Fehlerbehandlung\nErr_ButtonProtokollÖffnen:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_TM_AenderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  ButtonProtokollÖffnen\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_ButtonProtokollÖffnen\n    End Select\n\nEnd Property\n\nPublic Property Let ProtokollTabelle(ByVal strProtokollTabelle As String)\n'Fehlerbehandlung definieren\nOn Error GoTo Err_ProtokollTabelle\n    \n    'Variablen deklarieren\n    Dim dbs As Object\n    Dim obj As AccessObject\n    Dim fTabVorhanden As Boolean\n    Dim strTitel As String\n    Dim strHinweis As String\n    \n    'Prüfen, ob Tabelle vorhanden\n    Set dbs = Application.CurrentData\n    fTabVorhanden = False\n    For Each obj In dbs.AllTables\n        If obj.Name = strProtokollTabelle Then\n            fTabVorhanden = True\n        End If\n    Next obj\n\n    'Werte zuweisen\n    If fTabVorhanden = True Then\n        mp_strProtokollTab = strProtokollTabelle\n    Else\n        strTitel = \"Tabelle nicht vorhanden\"\n        strHinweis = \"Sie haben für das TM-ÄnderungsProtokoll folgende\" & vbCrLf & _\n                     \"Einstellungen festgelegt:\" & vbCrLf & vbCrLf & _\n                     \"ProtokollTabelle: \" & strProtokollTabelle & vbCrLf & vbCrLf & _\n                     \"Die angegebene Tabelle existiert nicht.\"\n        MsgBox strHinweis, vbCritical, strTitel\n    End If\n\n'Ende\nExit_ProtokollTabelle:\n    On Error Resume Next\n    Set dbs = Nothing\n    Exit Property\n\n'Fehlerbehandlung\nErr_ProtokollTabelle:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_TM_ÄnderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  ProtokollTabelle\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_ProtokollTabelle\n    End Select\n\nEnd Property\n\nPublic Property Let Formularname(ByVal strFormName As String)\n'Fehlerbehandlung definieren\nOn Error GoTo Error_Handler\n\n    mp_strFormName = strFormName\n\n'Ende\nExit_Here:\n    On Error Resume Next\n    Exit Property\n\n'Fehlerbehandlung\nError_Handler:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_TM_AenderungsProtokoll \" & vbCrLf & _\n                   \"Prozedur: FormName\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_Here\n    End Select\n\nEnd Property\n\nPublic Property Set PrimaryKeyControl(ByRef txtNewPrimaryKeyControl As Access.TextBox)\n'Fehlerbehandlung definieren\nOn Error GoTo Err_PrimaryKeyControl\n    \n    Set mp_txtPrimaryKeyControl = txtNewPrimaryKeyControl\n\n'Ende\nExit_PrimaryKeyControl:\n    On Error Resume Next\n    Exit Property\n\n'Fehlerbehandlung\nErr_PrimaryKeyControl:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_TM_ÄnderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  PrimaryKeyControl\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_PrimaryKeyControl\n    End Select\n\nEnd Property\n\nPublic Property Let DatensatzNeu(ByVal tmDatensatzNeu As tmEnum_DatensatzNeu)\n'Fehlerbehandlung definieren\nOn Error GoTo Err_DatensatzNeu\n\n    mp_intDatensatzNeu = tmDatensatzNeu\n\n'Ende\nExit_DatensatzNeu:\n    On Error Resume Next\n    Exit Property\n\n'Fehlerbehandlung\nErr_DatensatzNeu:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_TM_ÄnderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  DatensatzNeu\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_DatensatzNeu\n    End Select\n\nEnd Property\n\nPublic Property Let DatensatzGelöscht(ByVal tmDatensatzGelöscht As tmEnum_DatensatzGelöscht)\n'Fehlerbehandlung definieren\nOn Error GoTo Err_DatensatzGelöscht\n\n    mp_intDatensatzGelöscht = tmDatensatzGelöscht\n\n'Ende\nExit_DatensatzGelöscht:\n    On Error Resume Next\n    Exit Property\n\n'Fehlerbehandlung\nErr_DatensatzGelöscht:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_TM_ÄnderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  DatensatzGelöscht\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_DatensatzGelöscht\n    End Select\n\nEnd Property\n\nPublic Property Let LöschenProtokollieren(ByVal fLöschenProtokollieren As Boolean)\n'Fehlerbehandlung definieren\nOn Error GoTo Err_LöschenProtokollieren\n\n    mp_fLöschenProtokollieren = fLöschenProtokollieren\n\n'Ende\nExit_LöschenProtokollieren:\n    On Error Resume Next\n    Exit Property\n\n'Fehlerbehandlung\nErr_LöschenProtokollieren:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_tmÄnderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  LöschenProtokollieren\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_LöschenProtokollieren\n    End Select\n\nEnd Property\n\n'############################\n' Methoden der Klasse\n'############################\n\nPublic Sub Init(Optional frmFormular As Form, _\n                Optional cmdButtonProtokollÖffnen As Variant, _\n                Optional strProtokollTabelle As Variant, _\n                Optional strFormularName As Variant, _\n                Optional txtPrimaryKeyControl As Variant, _\n                Optional intDatensatzNeu As Variant, _\n                Optional intDatensatzGelöscht As Variant, _\n                Optional fLöschenProtokollieren As Variant)\n'Fehlerbehandlung definieren\nOn Error GoTo Err_Init\n\n    If Not IsEmpty(frmFormular) Then\n        Set Formular = frmFormular\n    End If\n\n    If Not IsEmpty(cmdButtonProtokollÖffnen) Then\n        Set ButtonProtokollÖffnen = cmdButtonProtokollÖffnen\n    End If\n    \n    If Not IsMissing(strProtokollTabelle) Then\n        Let ProtokollTabelle = strProtokollTabelle\n    End If\n    \n    If Not IsMissing(strFormularName) Then\n        Let Formularname = strFormularName\n    End If\n    \n    If Not IsEmpty(txtPrimaryKeyControl) Then\n        Set PrimaryKeyControl = txtPrimaryKeyControl\n    End If\n    \n    If Not IsMissing(intDatensatzNeu) Then\n        Let DatensatzNeu = intDatensatzNeu\n    End If\n    \n    If Not IsMissing(intDatensatzGelöscht) Then\n        Let DatensatzGelöscht = intDatensatzGelöscht\n    End If\n    \n    If Not IsMissing(fLöschenProtokollieren) Then\n        Let LöschenProtokollieren = fLöschenProtokollieren\n    End If\n\n'Ende\nExit_Init:\n    On Error Resume Next\n    Exit Sub\n\n'Fehlerbehandlung\nErr_Init:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_TM_ÄnderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  Init\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_Init\n    End Select\n\nEnd Sub\n\n'############################\n' Klasse verwalten\n'############################\n\nPrivate Sub Class_Initialize()\n'Fehlerbehandlung definieren\nOn Error GoTo Err_Class_Initialize\n\n    'Initialisieren\n    Set m_db = CurrentDb\n    \n    'Standardwerte setzen\n    mp_intDatensatzNeu = 0\n    mp_intDatensatzGelöscht = 0\n    mp_fLöschenProtokollieren = True\n    mp_strProtokollTab = \"tbl_AendungsProtokoll\"\n\n'Ende\nExit_Class_Initialize:\n    On Error Resume Next\n    Exit Sub\n\n'Fehlerbehandlung\nErr_Class_Initialize:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_TM_ÄnderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  Class_Initialize\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_Class_Initialize\n    End Select\n\nEnd Sub\n\nPrivate Sub Class_Terminate()\n'Fehlerbehandlung definieren\nOn Error GoTo Err_Class_Terminate\n\n    'Aufräumen\n    Set m_db = Nothing\n    Set mp_frmForm = Nothing\n\n'Ende\nExit_Class_Terminate:\n    On Error Resume Next\n    Exit Sub\n\n'Fehlerbehandlung\nErr_Class_Terminate:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_TM_ÄnderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  Class_Terminate\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_Class_Terminate\n    End Select\n\nEnd Sub\n\n'############################\n' Auf Ereignisse reagieren\n'############################\n\nPrivate Sub mp_frmForm_BeforeUpdate(Cancel As Integer)\n'Fehlerbehandlung definieren\nOn Error GoTo Err_mp_frmForm_BeforeUpdate\n\n    'Variablen deklarieren\n    Dim ctlSteuerElem As control    'Verweis auf Steuerelemente im frm\n    Dim ctl2 As control             '2. Verweis auf Steuerelemente im frm\n    Dim strAlterWert As String      'Inhalt des alten Wertes\n    Dim strNeuerWert As String      'Inhalt des neuen Wertes\n    Dim strDatensatzNr As String    'Inhalt Feld Primärschlüssel\n    Dim strDatum As String          'Datum der Änderung\n    Dim StrName As String           'Name des geänderten Feldes\n    Dim strName2 As String          '2. Name des geänderten Feldes\n                                    '(für Optionsgruppen benötigt)\n    Dim strBenutzer As String       'Name des Benutzers\n    Dim strUserName As String       'UserName aus Anmeldung\n    Dim strComputerName As String   'Name des Computers\n    Dim fSpeichern As Boolean       'Sind Änderungen zu speichern?\n    Dim intAnz As Integer\n    Dim fPrüfen As Boolean\n    \n    'Initialisierung\n    strDatum = Now\n    strBenutzer = CurrentUser\n    strDatensatzNr = mp_txtPrimaryKeyControl.Value\n    strUserName = ErmittleUserName\n    strComputerName = ErmittleComputerName\n    Erase m_aÄnderung()\n    intAnz = 0\n    \n    'Neuer Datensatz\n    If mp_frmForm.NewRecord Then\n        intAnz = 1\n        ReDim m_aÄnderung(1)\n        m_aÄnderung(1).DSNr = strDatensatzNr\n        m_aÄnderung(1).Wert_Name = \"Datensatz angelegt\"\n        m_aÄnderung(1).Wert_Alt = \"\"\n        m_aÄnderung(1).Wert_Neu = \"\"\n        m_aÄnderung(1).Datum = strDatum\n        m_aÄnderung(1).benutzer = strBenutzer\n        m_aÄnderung(1).UserName = strUserName\n        m_aÄnderung(1).ComputerName = strComputerName\n        'Umgang mit neuen Datensätzen prüfen\n        If mp_intDatensatzNeu = 0 Then\n            Exit Sub\n        End If\n    End If\n\n    fSpeichern = False\n    For Each ctlSteuerElem In mp_frmForm.controls\n        Select Case ctlSteuerElem.ControlType\n            Case acTextBox\n                strAlterWert = Nz(ctlSteuerElem.OldValue, \"LEER\")\n                strNeuerWert = Nz(ctlSteuerElem.Value, \"LEER\")\n                If StrComp(strAlterWert, strNeuerWert, vbBinaryCompare) <> 0 Then\n                    If ctlSteuerElem.controls.Count > 0 Then\n                        StrName = ctlSteuerElem.controls(0).caption\n                    End If\n                    fSpeichern = True\n                End If\n            'Bei Optionsgruppen\n            Case acOptionGroup\n                'Alten Wert ermitteln\n                strAlterWert = Nz(ctlSteuerElem.OldValue, \"LEER\")\n                If strAlterWert = \"-1\" Then\n                    strAlterWert = \"LEER\"\n                End If\n                'Neuen Wert ermitteln\n                strNeuerWert = Nz(ctlSteuerElem.Value, \"LEER\")\n                'Wenn Werte unterschiedlich\n                If strAlterWert <> strNeuerWert Then\n                    If ctlSteuerElem.controls.Count > 0 Then\n                        StrName = ctlSteuerElem.controls(0).caption\n                    End If\n                    For Each ctl2 In ctlSteuerElem.controls\n                        If ctl2.ControlType <> acLabel Then\n                        Select Case ctl2.ControlType\n                            'Beschriftung Alt und Neu für Umschaltflächen\n                            Case acToggleButton\n                                If ctl2.OptionValue = strNeuerWert Then\n                                    strNeuerWert = ctl2.caption\n                                End If\n                                If ctl2.OptionValue = strAlterWert Then\n                                    strAlterWert = ctl2.caption\n                                End If\n                            'Beschriftung Alt und Neu für OptionButton und CheckBox\n                            Case Else\n                            'Beschriftung \"Neuer Wert\" ermittteln\n                            If ctl2.OptionValue = strNeuerWert Then\n                                strName2 = ctl2.Name\n                                If ctl2.controls.Count > 0 Then\n                                    strNeuerWert = ctl2.controls(0).caption\n                                End If\n                            End If\n                            'Beschriftung \"Alter Wert\" ermitteln\n                            If ctl2.OptionValue = strAlterWert Then\n                                strName2 = ctl2.Name\n                                If ctl2.controls.Count > 0 Then\n                                    strAlterWert = ctl2.controls(0).caption\n                                End If\n                            End If\n                        End Select\n                        End If\n                    Next\n                    fSpeichern = True\n                End If\n            Case acComboBox\n                strAlterWert = Nz(ctlSteuerElem.OldValue, \"LEER\")\n                strNeuerWert = Nz(ctlSteuerElem.Value, \"LEER\")\n                If strAlterWert <> strNeuerWert Then\n                    'Bei mehr als 1 Spalte\n                    If ctlSteuerElem.ColumnCount > 1 Then\n                        Call ComboDetails(ctlSteuerElem, strAlterWert, strNeuerWert)\n                    End If\n                    If ctlSteuerElem.controls.Count > 0 Then\n                        StrName = ctlSteuerElem.controls(0).caption\n                    End If\n                    fSpeichern = True\n                End If\n            Case acListBox\n                If ctlSteuerElem.MultiSelect = 0 Then\n                    strAlterWert = Nz(ctlSteuerElem.OldValue, \"LEER\")\n                    strNeuerWert = Nz(ctlSteuerElem.Value, \"LEER\")\n                    'Bei mehr als 1 Spalte\n                    If ctlSteuerElem.ColumnCount > 1 Then\n                        Call ListDetails(ctlSteuerElem, strAlterWert, strNeuerWert)\n                    End If\n                    If strAlterWert <> strNeuerWert Then\n                        If ctlSteuerElem.controls.Count > 0 Then\n                            StrName = ctlSteuerElem.controls(0).caption\n                        End If\n                        fSpeichern = True\n                    End If\n                End If\n            Case acOptionButton\n                fPrüfen = False\n                If ctlSteuerElem.Parent.Name = mp_frmForm.Name Then\n                    fPrüfen = True\n                Else\n                    If ctlSteuerElem.Parent.ControlType <> acOptionGroup Then\n                        fPrüfen = True\n                    End If\n                End If\n                If fPrüfen = True Then\n                    strAlterWert = Nz(ctlSteuerElem.OldValue, \"LEER\")\n                    strAlterWert = IIf(strAlterWert = \"0\", \"Nein\", \"Ja\")\n                    strNeuerWert = Nz(ctlSteuerElem.Value, \"LEER\")\n                    strNeuerWert = IIf(strNeuerWert = \"0\", \"Nein\", \"Ja\")\n                    If strAlterWert <> strNeuerWert Then\n                        If ctlSteuerElem.controls.Count > 0 Then\n                            StrName = ctlSteuerElem.controls(0).caption\n                        End If\n                        fSpeichern = True\n                    End If\n                End If\n            Case acCheckBox\n                fPrüfen = False\n                If ctlSteuerElem.Parent.Name = mp_frmForm.Name Then\n                    fPrüfen = True\n                Else\n                    If ctlSteuerElem.Parent.ControlType <> acOptionGroup Then\n                        fPrüfen = True\n                    End If\n                End If\n                If fPrüfen = True Then\n                    strAlterWert = Nz(ctlSteuerElem.OldValue, \"LEER\")\n                    strAlterWert = IIf(strAlterWert = \"0\", \"Nein\", \"Ja\")\n                    strNeuerWert = Nz(ctlSteuerElem.Value, \"LEER\")\n                    strNeuerWert = IIf(strNeuerWert = \"0\", \"Nein\", \"Ja\")\n                    If strAlterWert <> strNeuerWert Then\n                        If ctlSteuerElem.controls.Count > 0 Then\n                            StrName = ctlSteuerElem.controls(0).caption\n                        End If\n                        fSpeichern = True\n                    End If\n                End If\n            Case acToggleButton\n                fPrüfen = False\n                If ctlSteuerElem.Parent.Name = mp_frmForm.Name Then\n                    fPrüfen = True\n                Else\n                    If ctlSteuerElem.Parent.ControlType <> acOptionGroup Then\n                        fPrüfen = True\n                    End If\n                End If\n                If fPrüfen = True Then\n                    strAlterWert = Nz(ctlSteuerElem.OldValue, \"LEER\")\n                    strAlterWert = IIf(strAlterWert = \"0\", \"Nein\", \"Ja\")\n                    strNeuerWert = Nz(ctlSteuerElem.Value, \"LEER\")\n                    strNeuerWert = IIf(strNeuerWert = \"0\", \"Nein\", \"Ja\")\n                    If strAlterWert <> strNeuerWert Then\n                        StrName = ctlSteuerElem.caption\n                        fSpeichern = True\n                    End If\n                End If\n        End Select\n        'Ergebnis speichern\n        If fSpeichern = True Then\n            'Prüfen, ob Label vorhanden\n            If StrName = \"\" Then\n                StrName = \"???\"\n            End If\n            intAnz = intAnz + 1\n            ReDim Preserve m_aÄnderung(intAnz)\n            m_aÄnderung(intAnz).DSNr = strDatensatzNr\n            m_aÄnderung(intAnz).Wert_Name = StrName\n            m_aÄnderung(intAnz).Wert_Alt = Left$(strAlterWert, 255)\n            m_aÄnderung(intAnz).Wert_Neu = Left$(strNeuerWert, 255)\n            m_aÄnderung(intAnz).Datum = strDatum\n            m_aÄnderung(intAnz).benutzer = strBenutzer\n            m_aÄnderung(intAnz).UserName = strUserName\n            m_aÄnderung(intAnz).ComputerName = strComputerName\n            fSpeichern = False\n        End If\n    Next\n\n'Ende\nExit_mp_frmForm_BeforeUpdate:\n    On Error Resume Next\n    Exit Sub\n\n'Fehlerbehandlung\nErr_mp_frmForm_BeforeUpdate:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_tmÄnderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  mp_frmForm_BeforeUpdate\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_mp_frmForm_BeforeUpdate\n    End Select\n\nEnd Sub\n\nPrivate Sub mp_frmForm_AfterUpdate()\n'Fehlerbehandlung definieren\nOn Error GoTo Err_mp_frmForm_AfterUpdate\n\n    'Variablen deklarieren\n    Dim rst As DAO.Recordset\n    Dim intI As Integer\n\n    'Abbruch, wenn kein Wert gespeichert\n    If SafeArrayGetDim(m_aÄnderung) = 0 Then\n        Exit Sub\n    End If\n    \n    'Initialisieren\n    Set rst = m_db.OpenRecordset(mp_strProtokollTab)\n    \n    'Zwischengespeicherte Änderungen seichern\n    With rst\n        For intI = 1 To UBound(m_aÄnderung)\n            .AddNew\n            !formName = mp_strFormName\n            !Datensatznr = m_aÄnderung(intI).DSNr\n            !Wert_Name = m_aÄnderung(intI).Wert_Name\n            If Len(Trim$(m_aÄnderung(intI).Wert_Alt)) > 0 Then\n                !Wert_Alt = m_aÄnderung(intI).Wert_Alt\n            End If\n            If Len(Trim$(m_aÄnderung(intI).Wert_Neu)) > 0 Then\n                !Wert_Neu = m_aÄnderung(intI).Wert_Neu\n            End If\n            !Datum = m_aÄnderung(intI).Datum\n            !benutzer = m_aÄnderung(intI).benutzer\n            !UserName = m_aÄnderung(intI).UserName\n            !ComputerName = m_aÄnderung(intI).ComputerName\n            .update\n        Next intI\n    End With\n\n'Ende\nExit_mp_frmForm_AfterUpdate:\n    On Error Resume Next\n    rst.Close\n    Set rst = Nothing\n    Exit Sub\n\n'Fehlerbehandlung\nErr_mp_frmForm_AfterUpdate:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_TM_AenderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  mp_frmForm_AfterUpdate\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_mp_frmForm_AfterUpdate\n    End Select\n\nEnd Sub\n\nPrivate Sub mp_frmForm_Delete(Cancel As Integer)\n'Fehlerbehandlung definieren\nOn Error GoTo Err_mp_frmForm_Delete\n\n    If mp_fLöschenProtokollieren = True Then\n        m_strIDGelöscht = mp_txtPrimaryKeyControl.Value\n    End If\n\n'Ende\nExit_mp_frmForm_Delete:\n    On Error Resume Next\n    Exit Sub\n\n'Fehlerbehandlung\nErr_mp_frmForm_Delete:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_tmÄnderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  mp_frmForm_Delete\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_mp_frmForm_Delete\n    End Select\n\nEnd Sub\n\nPrivate Sub mp_frmForm_AfterDelConfirm(Status As Integer)\n'Fehlerbehandlung definieren\nOn Error GoTo Err_mp_frmForm_AfterDelConfirm\n\n    'Variablen deklarieren\n    Dim rst As DAO.Recordset\n    Dim strDatum As String          'Datum der Löschung\n    Dim strBenutzer As String       'Name des Benutzers\n    Dim strSQL As String            'SQL-String für Löschen der Datensätze\n    Dim strUserName As String       'UserName aus Anmeldung\n    Dim strComputerName As String   'Name des Computers\n    \n    If mp_fLöschenProtokollieren = True Then\n\n        If Status = acDeleteOK Then\n            Select Case mp_intDatensatzGelöscht\n                Case 0  '>Datensatz gelöscht< speichern\n                    Set rst = m_db.OpenRecordset(mp_strProtokollTab)\n                    strDatum = Now\n                    strBenutzer = CurrentUser\n                    strUserName = ErmittleUserName\n                    strComputerName = ErmittleComputerName\n                    With rst\n                        .AddNew\n                        !formName = mp_strFormName\n                        !Datensatznr = m_strIDGelöscht\n                        !Wert_Name = \"Datensatz gelöscht\"\n                        !Datum = strDatum\n                        !benutzer = strBenutzer\n                        !UserName = strUserName\n                        !ComputerName = strComputerName\n                        .update\n                    End With\n                Case 1  'Alle Einträge für DS im Änderungsprotokoll löschen\n                    strSQL = \"DELETE * FROM \" & mp_strProtokollTab & \" WHERE Datensatznr='\" & m_strIDGelöscht & \"';\"\n                    m_db.Execute strSQL\n            End Select\n        End If\n    End If\n\n'Ende\nExit_mp_frmForm_AfterDelConfirm:\n    On Error Resume Next\n    rst.Close\n    Set rst = Nothing\n    Exit Sub\n\n'Fehlerbehandlung\nErr_mp_frmForm_AfterDelConfirm:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_tmÄnderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  mp_frmForm_AfterDelConfirm\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_mp_frmForm_AfterDelConfirm\n    End Select\n\nEnd Sub\n\nPrivate Sub mp_cmdButtonProtokollÖffnen_Click()\n'Fehlerbehandlung definieren\nOn Error GoTo Err_mp_cmdButtonProtokollÖffnen_Click\n\n    'Variablen deklarieren\n    Dim strDocName As String\n    Dim strOpenArgs As String\n    \n    strDocName = \"zfrmAenderungsprotokoll\"\n    strOpenArgs = mp_strProtokollTab & \",\" & mp_strFormName & \",\" & mp_txtPrimaryKeyControl.Value\n    \n    DoCmd.OpenForm strDocName, , , , , , strOpenArgs\n\n'Ende\nExit_mp_cmdButtonProtokollÖffnen_Click:\n    On Error Resume Next\n    Exit Sub\n\n'Fehlerbehandlung\nErr_mp_cmdButtonProtokollÖffnen_Click:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox \"Ein Fehler ist aufgetreten: \" & vbCrLf & _\n                   \"Klassenmodul cls_TM_AenderungsProtokoll\" & vbCrLf & _\n                   \"Prozedur:  mp_cmdButtonProtokollÖffnen_Click\" & vbCrLf & _\n                   \"Fehler-Nr.: \" & err.Number & vbCrLf & _\n                   err.description, vbCritical\n            Resume Exit_mp_cmdButtonProtokollÖffnen_Click\n    End Select\n\nEnd Sub\n\n'############################\n' Hilfsfunktionen\n'############################\n\nPrivate Function ErmittleComputerName() As String\n'\n'    Name: ErmittleComputerName\n'   Zweck: Ermittelt den Computernamen durch API-Call\n'\n'   Autor: Thomas Möller\n'          Access@Team-Moeller.de\n'\n'Erstellt: 01.03.2003\n'  Update: 01.03.2003\n' Version: 1.00\n'\n'   Input: -\n'\n'  Output: - Ermittelter Computername\n'\n'Benötigt: - Deklaration von \"GetComputerName\"\n'\n'  Anmer-: -\n'  kungen:\n'\n\n'Fehlerbehandlung definieren\nOn Error GoTo Fehlerbehandlung\n\n    'Variablen deklarieren\n    Dim strBuffer As String\n    Dim lSize As Long\n    \n    'Buffer bereitstellen\n    lSize = 32\n    strBuffer = String(lSize, Chr$(0))\n    \n    'Compternamen ermitteln\n    GetComputerName strBuffer, lSize\n    \n    'Computernamen übergeben\n    ErmittleComputerName = Left(strBuffer, lSize)\n\n'Ende\nAusstieg:\n    On Error Resume Next\n    Exit Function\n\n'Fehlerbehandlung\nFehlerbehandlung:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox err.description, vbCritical, err.Number\n            Resume Ausstieg\n    End Select\n    \nEnd Function\n\nPrivate Function ErmittleUserName() As String\n'\n'    Name: ErmittleUserName\n'   Zweck: Ermittelt den Usernamen durch API-Call\n'\n'   Autor: Thomas Möller\n'          Access@Team-Moeller.de\n'\n'Erstellt: 01.03.2003\n'  Update: 01.03.2003\n' Version: 1.00\n'\n'   Input: -\n'\n'  Output: - Ermittelter Username\n'\n'Benötigt: - Deklaration von \"GetUserName\"\n'\n'  Anmer-: -\n'  kungen:\n'\n\n'Fehlerbehandlung definieren\nOn Error GoTo Fehlerbehandlung\n\n    'Variablen deklarieren\n    Dim strBuffer As String\n    \n    'Buffer bereitstellen\n    strBuffer = String(100, Chr$(0))\n    \n    'Compternamen ermitteln\n    GetUserName strBuffer, 100\n    \n    'Computernamen übergeben\n    ErmittleUserName = Left$(strBuffer, InStr(strBuffer, Chr$(0)) - 1)\n\n'Ende\nAusstieg:\n    On Error Resume Next\n    Exit Function\n\n'Fehlerbehandlung\nFehlerbehandlung:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox err.description, vbCritical, err.Number\n            Resume Ausstieg\n    End Select\n    \nEnd Function\n\nPrivate Sub ComboDetails(ctlCombo As control, ByRef strAlterWert As String, ByRef strNeuerWert As String)\n'\n'    Name: ComboDetails\n'   Zweck: Ermittelt für Kombinationsfelder den sichtbaren\n'          bisherigen Wert und den sichtbaren neuen Wert\n'\n'   Autor: Thomas Möller\n'          Access@Team-Moeller.de\n'\n'Erstellt: 02.05.2003\n'  Update: 04.05.2003\n' Version: 1.50\n'\n'   Input: - KombinationsfeldSteuerelement\n'          - Alter Wert\n'          - Neuer Wert\n'\n'  Output: - strAlterWert wird ggfs. geändert\n'          - strNeuerWert wird ggfs. geändert\n'\n'Benötigt: -\n'\n'  Anmer-: - Funktion nicht für \"Benutzerdefinierte Funktion\"\n'  kungen:   als Datenquelle verfügbar\n'\n\n'Fehlerbehandlung definieren\nOn Error GoTo Fehlerbehandlung\n    \n    'Variablen deklarieren\n    Dim intAnzSpalten As Integer\n    Dim intGebSpalte As Integer\n    Dim bytErsteSichtSp As Byte\n    Dim strSpaltenBreiten As String\n    Dim intSpalte As Integer\n    Dim intPos As Integer\n    Dim intCount As Integer\n    Dim acboWerte As Variant\n    Dim rst As DAO.Recordset\n\n    'Daten ermitteln\n    intAnzSpalten = ctlCombo.ColumnCount\n    intGebSpalte = ctlCombo.BoundColumn\n    \n    'Erste sichtbare Spalte ermitteln\n    strSpaltenBreiten = ctlCombo.ColumnWidths\n    If strSpaltenBreiten = \"\" Then\n        bytErsteSichtSp = 1\n    Else\n        If strSpaltenBreiten = \"0\" Then\n            bytErsteSichtSp = 2\n        Else\n            intPos = InStr(strSpaltenBreiten, \";\")\n            intCount = 1\n            Do Until intPos = 1 Or intPos = 0\n                If CDbl(Left$(strSpaltenBreiten, intPos - 1)) <> 0 Then\n                    Exit Do\n                End If\n                strSpaltenBreiten = Right$(strSpaltenBreiten, Len(strSpaltenBreiten) - intPos)\n                intPos = InStr(strSpaltenBreiten, \";\")\n                intCount = intCount + 1\n                If strSpaltenBreiten = \"0\" Then\n                    intCount = intCount + 1\n                    Exit Do\n                End If\n            Loop\n            bytErsteSichtSp = intCount\n        End If\n    End If\n    \n    'Gebundene Spalte sichtbar?\n    If bytErsteSichtSp = intGebSpalte Then\n        Exit Sub\n    End If\n    \n    'Werte in sichtbarer Spalte ermitteln\n    If strAlterWert = \"LEER\" Then\n        strNeuerWert = Nz(ctlCombo.Column(bytErsteSichtSp - 1), \"LEER\") & \" (\" & strNeuerWert & \")\"\n    Else\n        Select Case ctlCombo.RowSourceType\n            Case \"Table/Query\"      'Tabelle/Abfrage\n                Set rst = m_db.OpenRecordset(ctlCombo.rowSource)\n                rst.MoveFirst\n                Do While Not rst.EOF\n                    If rst(intGebSpalte - 1) = strAlterWert Then\n                        strAlterWert = rst(bytErsteSichtSp - 1) & \" (\" & strAlterWert & \")\"\n                        strNeuerWert = Nz(ctlCombo.Column(bytErsteSichtSp - 1), \"LEER\") & \" (\" & strNeuerWert & \")\"\n                        Exit Do\n                    End If\n                    rst.MoveNext\n                Loop\n            Case \"Value List\"       'Werteliste\n                'Array erstellen\n                acboWerte = Split(ctlCombo.rowSource, \";\")\n                'Nach altem Wert suchen\n                For intPos = intGebSpalte - 1 To UBound(acboWerte) Step intAnzSpalten\n                    If acboWerte(intPos) = strAlterWert Then\n                        strAlterWert = acboWerte(intPos - intGebSpalte + bytErsteSichtSp) & \" (\" & strAlterWert & \")\"\n                        strNeuerWert = Nz(ctlCombo.Column(bytErsteSichtSp - 1), \"LEER\") & \" (\" & strNeuerWert & \")\"\n                        Exit For\n                    End If\n                Next\n            Case \"Field List\"       'Feldliste\n                '\n                'Kein besonderer Code notwendig. Es gibt eigentlich nur eine Spalte.\n                'Damit ist die erste sichtbare Spalte immer gleich der gebundenen Spalte.\n                '\n            Case Else               'Benutzerdefinierte Funktion\n                '\n                'Wird derzeit nicht unterstützt.\n                '\n        End Select\n    End If\n    \n'Ende\nAusstieg:\n    On Error Resume Next\n    rst.Close\n    Set rst = Nothing\n    Exit Sub\n    \n'Fehlerbehandlung\nFehlerbehandlung:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox err.description, vbCritical, err.Number\n            Resume Ausstieg\n    End Select\n\nEnd Sub\nPrivate Sub ListDetails(ctlList As control, ByRef strAlterWert As String, ByRef strNeuerWert As String)\n'\n'    Name: ListDetails\n'   Zweck: Ermittelt für Listenfelder die sichtbaren\n'          bisherigen Werte und die sichtbaren neuen Werte\n'\n'   Autor: Thomas Möller\n'          Access@Team-Moeller.de\n'\n'Erstellt: 11.05.2003\n'  Update: 01.06.2003\n' Version: 1.55\n'\n'   Input: - ListenfeldSteuerelement\n'          - Alter Wert\n'          - Neuer Wert\n'\n'  Output: - strAlterWert wird ggfs. geändert\n'          - strNeuerWert wird ggfs. geändert\n'\n'Benötigt: -\n'\n'  Anmer-: - Funktion nicht für \"Benutzerdefinierte Funktion\"\n'  kungen:   als Datenquelle verfügbar\n'\n\n'Fehlerbehandlung definieren\nOn Error GoTo Fehlerbehandlung\n    \n    'Variablen deklarieren\n    Dim strAlterWertBisher As String\n    Dim strNeuerWertBisher As String\n    Dim intAnzSpalten As Integer\n    Dim intGebSpalte As Integer\n    Dim fSpalteSichtb() As Boolean\n    Dim strSpaltenBreiten As String\n    Dim intI As Integer\n    Dim intCount As Integer\n    Dim intPos As Integer\n    Dim acboWerte As Variant\n    Dim rst As DAO.Recordset\n    Dim intSpalte As Integer\n\n    'Daten ermitteln\n    strAlterWertBisher = strAlterWert\n    strNeuerWertBisher = strNeuerWert\n    intAnzSpalten = ctlList.ColumnCount\n    ReDim fSpalteSichtb(intAnzSpalten)\n    intGebSpalte = ctlList.BoundColumn\n    \n    'Sichtbare Spalten ermitteln\n    strSpaltenBreiten = ctlList.ColumnWidths\n    If strSpaltenBreiten = \"\" Then\n        For intI = 1 To intAnzSpalten\n            fSpalteSichtb(intI) = True\n        Next\n    Else\n        If strSpaltenBreiten = \"0\" Then\n            fSpalteSichtb(1) = False\n            For intI = 2 To intAnzSpalten\n                fSpalteSichtb(intI) = True\n            Next\n        Else\n            intCount = 1\n            intPos = InStr(strSpaltenBreiten, \";\")\n            Do Until intPos = 0\n                If intPos = 1 Then\n                    fSpalteSichtb(intCount) = True\n                Else\n                    If Left$(strSpaltenBreiten, intPos - 1) = 0 Then\n                        fSpalteSichtb(intCount) = False\n                    Else\n                        fSpalteSichtb(intCount) = True\n                    End If\n                End If\n                strSpaltenBreiten = Right$(strSpaltenBreiten, Len(strSpaltenBreiten) - intPos)\n                intPos = InStr(strSpaltenBreiten, \";\")\n                intCount = intCount + 1\n            Loop\n            If Len(strSpaltenBreiten) > 0 Then\n                If strSpaltenBreiten = 0 Then\n                    fSpalteSichtb(intCount) = False\n                Else\n                    fSpalteSichtb(intCount) = True\n                End If\n                intCount = intCount + 1\n            End If\n            For intI = intCount To intAnzSpalten\n                fSpalteSichtb(intCount) = True\n            Next\n        End If\n    End If\n    \n    'Werte in sichtbaren Spalten ermitteln\n    If strAlterWert = \"LEER\" Then\n        strNeuerWert = \"\"\n        For intI = 1 To intAnzSpalten\n            If fSpalteSichtb(intI) Then\n                strNeuerWert = strNeuerWert & ctlList.Column(intI - 1) & \", \"\n            End If\n        Next\n        strNeuerWert = Left$(strNeuerWert, Len(strNeuerWert) - 2) & \" (\" & strNeuerWertBisher & \")\"\n    Else\n        Select Case ctlList.RowSourceType\n            Case \"Table/Query\"      'Tabelle/Abfrage\n                Set rst = m_db.OpenRecordset(ctlList.rowSource)\n                rst.MoveFirst\n                Do While Not rst.EOF\n                    If rst(intGebSpalte - 1) = strAlterWert Then\n                        'Alten Wert ermitteln\n                        strAlterWert = \"\"\n                        For intI = 1 To intAnzSpalten\n                            If fSpalteSichtb(intI) Then\n                                strAlterWert = strAlterWert & rst(intI - 1) & \", \"\n                            End If\n                        Next\n                        strAlterWert = Left$(strAlterWert, Len(strAlterWert) - 2) & \" (\" & strAlterWertBisher & \")\"\n                        'Neuen Wert ermitteln\n                        strNeuerWert = \"\"\n                        For intI = 1 To intAnzSpalten\n                            If fSpalteSichtb(intI) Then\n                                strNeuerWert = strNeuerWert & ctlList.Column(intI - 1) & \", \"\n                            End If\n                        Next\n                        strNeuerWert = Left$(strNeuerWert, Len(strNeuerWert) - 2) & \" (\" & strNeuerWertBisher & \")\"\n                        'Fertig\n                        Exit Do\n                    End If\n                    rst.MoveNext\n                Loop\n            Case \"Value List\"       'Werteliste\n                'Array erstellen\n                acboWerte = Split(ctlList.rowSource, \";\")\n                'Nach altem Wert suchen\n                For intPos = intGebSpalte - 1 To UBound(acboWerte) Step intAnzSpalten\n                    If acboWerte(intPos) = strAlterWert Then\n                        'Alten Wert ermitteln\n                        strAlterWert = \"\"\n                        For intI = 1 To intAnzSpalten\n                            If fSpalteSichtb(intI) Then\n                                strAlterWert = strAlterWert & acboWerte(intPos - intGebSpalte + intI) & \", \"\n                            End If\n                        Next\n                        strAlterWert = Left$(strAlterWert, Len(strAlterWert) - 2) & \" (\" & strAlterWertBisher & \")\"\n                        'Neuen Wert ermitteln\n                        strNeuerWert = \"\"\n                        For intI = 1 To intAnzSpalten\n                            If fSpalteSichtb(intI) Then\n                                strNeuerWert = strNeuerWert & ctlList.Column(intI - 1) & \", \"\n                            End If\n                        Next\n                        strNeuerWert = Left$(strNeuerWert, Len(strNeuerWert) - 2) & \" (\" & strNeuerWertBisher & \")\"\n                        'Fertig\n                        Exit For\n                    End If\n                Next\n            Case \"Field List\"       'Feldliste\n                '\n                'Kein besonderer Code notwendig. Es gibt eigentlich nur eine Spalte.\n                'Damit ist die erste sichtbare Spalte immer gleich der gebundenen Spalte.\n                '\n            Case Else               'Benutzerdefinierte Funktion\n                '\n                'Wird derzeit nicht unterstützt.\n                '\n        End Select\n    End If\n    \n'Ende\nAusstieg:\n    On Error Resume Next\n    rst.Close\n    Set rst = Nothing\n    Exit Sub\n    \n'Fehlerbehandlung\nFehlerbehandlung:\n    Select Case err.Number\n        Case 0\n            Resume Next\n        Case Else\n            MsgBox err.description, vbCritical, err.Number\n            Resume Ausstieg\n    End Select\n\nEnd Sub\n"}
