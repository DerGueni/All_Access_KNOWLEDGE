{"id":"MOD_mdlSonstiges2","name":"mdlSonstiges2","kind":"standard","procedures":["Function NurZahl(Eingabe As String)","Function Dec2Hex(ByVal X As Double) As String","Private Function GetDecimalSep()","Function Hex2Dec(strValue As String) As Long","Function CtrlAltDel(Erlaubt As Boolean)","Function Euro()","Public Function fmt_Euro$(lgEin@)","Public Function Autodial(ByVal stNumber As String)","Public Function ProgramClose(handle As Long)","Function MakeTempFileName(Extension As String) As String","Function BusinessUnit(Optional Bu) As String","Function ToDo(Optional description As String)","Sub FParsePath(ByVal FullPath As String, Drive As String, DirName As String, fname As String, Ext As String)","Function DBErstellen(strDatabaseName As String)","Function DOSPgmStart(DosAufruf As String, Optional AufrufArt As Integer = vbMinimizedNoFocus)","Function Name_All_Labels(formName As String)","Function CloseAllForms()","Function dbname() As String","Function DBPfad() As String","Function Fehlercd()","Function pz_berechnen(Wert As Variant)","Function TestAdd(Zaehler As String, Optional Stepper As Integer) As String","Public Function CurrMDBSchliessen()","Function backup_Reminder(AnzahlTage As Integer)","Function XPath(AltPathDatei As String, ByVal NeuPath As String) As String","Function WelcheRegisterSeite(Feldname As String, DeinRegisterSteuerelement As control)","Function ANSIToUni(varAnsi As Variant) As Variant","Function UniToAnsi(varUni As Variant) As Variant","Sub GetFormsProp2(ByVal objektName As String, Optional ObjektTyp As Integer)","Sub PropTst()"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\n'   NurZahl            - Entfernt alle nicht numerischen Werte und gibt die puren Ziffern zurück\n'   Dec2Hex            - Dezimal --> Hexadezimal\n'   Hex2Dec            - Hexadezimal --> Dezimal\n'   CtrlAltDel         - Ctrl Alt Del unter Win95 Disablen (Nicht für NT)\n'   Euro               - Das Euro-Zeichen ausgeben\n'   fmt_Euro           - Ausgabe eines DM Betrages als String umgerechnet in Euro\n'   AutoDial           - Automatische Wahl einer Telefonnummer mittels TAPI (Win95 / 98 / NT4.0?)\n'   ProgramCLose       - Fremdprogramm schließen\n'   MakeTempFileName   - Temporärdatei erzeugen (MSKB)\n'   BusinessUnit       - predefined BusinessUnit setzen oder löschen\n'   ToDo               - Auf unerledigte Programme hinweisen (ToDo für Programmierer)\n'   FParsePath         - Pfad, Dateiname und Extension aus Dateiname incl. Pfad extrahieren (MS Neatcd97.mdb)\n'   DBErstellen        - Erstellen einer MDB\n'   DOSPgmStart        - DOS-Programm starten\n'   ClearMyTxtboxes    - Textboxes einer Form löschen\n'   CloseAllForms      - Alle Forms auf einmal schließen\n'   MergeIt            - Methode, wie ich eine Liste mit E-mail-Adressen umwandeln kann, sodass ich eine Art Serienmail schicken kann\n'   DBName             - Ausgabe des aktuellen Datenbanknamens mit Path\n'   DBPfad             - Ausgabe des aktuellen Datenbankpfades ohne DBNamen\n'   Fehlercd           - Ausgabe von Fehlermeldungen\n'   pz_berechnen       - PrüfZiffern-Verfahren Mod 10 rekursiv für VESR (Null gibt 0)\n'   TestAdd            - Addiert einen Wert zu einem alphanumerischen String\n'   CurrMDBSchliessen  - Schließt die aktive Datenbank\n'   backup_Reminder    - Automatisch an´s Backup erinnern (in Autoexec einbinden)\n'   XPath              - Bestehenden Pfad durch einen fixen anderen ersetzen, benötigt FParsePath ...\n'   WelcheRegisterSeite- In welcher Registerseite befindet sich ein bestimmtes Control\n'   ANSIToUni          - Konvertiert ANSI nach Unicode\n'   UniToAnsi          - Konvertiert Unicode nach ANSI\n'\n'**********************************************************************************\n' Deklarationen für CtrlAltDelEinAus - Ctrl Alt Del unter Win95 verbieten\n'**********************************************************************************\nDeclare PtrSafe Function SystemParametersInfo Lib \"user32\" Alias _\n\"SystemParametersInfoA\" (ByVal uAction As Long, ByVal uParam As Long, _\nlpvParam As Any, ByVal fuWinIni As Long) As Long\n\n'**********************************************************************************\n' Fremdprogramm schließen\n'**********************************************************************************\nDeclare PtrSafe Function SendMessage Lib \"user32\" Alias \"SendMessageA\" (ByVal hwnd As Long, _\n    ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long\n  Public Const WM_CLOSE = &H10\n\nDeclare PtrSafe Function WNetAddConnection Lib \"mpr.dll\" Alias \"WNetAddConnectionA\" _\n(ByVal lpszNetPath As String, ByVal lpszPassword As String, ByVal _\nlpszLocalName As String) As Long\n\n\nFunction NurZahl(Eingabe As String)\n' ***********************************************************\n' Entfernt alle nicht numerischen Werte und gibt die puren Ziffern zurück\n' Ausschließlich gedacht, um z.B. aus Telefonnummern \"/\" oder \"-\" oder \"(\" \")\"\n' zu entfernen.\n' Achtung: Es entfernt auch Komma oder Tausenderpunkt etc ohne Rücksicht.\n' Die Funktion ist also für Zahlen mit Nachkommastellen ungeeignet !!!\n' ***********************************************************\n\nDim i As Integer, Max As Integer, tmp As String\n\nNurZahl = \"\"\n\nMax = Len(Trim(Nz(Eingabe)))\n\nIf Max = 0 Then\n    Exit Function\nEnd If\n\nFor i = 1 To Max\n    tmp = Mid(Eingabe, i, 1)\n    If Not (tmp < Chr(48) Or tmp > Chr(57)) Then\n        NurZahl = NurZahl & tmp\n    End If\nNext i\n\nEnd Function\n\nFunction Dec2Hex(ByVal X As Double) As String\n'\n' Converts Decimal value to Hexidecimal string equivalent\n' Geändert, Original aus Neatcode.mdb von MS\n' Verwendet mdlLocale (für GetDecimalSep)\n'\n  Dim result As String, i As Integer, temp As Integer\n\n  result = Hex(Int(X)) & GetDecimalSep()\n  X = X - Int(X)\n  For i = 1 To 16\n    X = X * 16\n    result = result & Hex(X)\n    X = X - Int(X)\n  Next i\n  Dec2Hex = result\n    \nEnd Function\n\nPrivate Function GetDecimalSep()\nGetDecimalSep = \",\"\nEnd Function\n\n\nFunction Hex2Dec(strValue As String) As Long\nOn Error GoTo CnvrtErr\n'\n' Geändert, Original aus Neatcode.mdb von MS\n' Verwendet mdlLocale (für GetDecimalSep)\n' Converts a string of hexadecimal digits into a decimal number.\n' Valid input range '0' to '7FFFFFFF'\n'\n' Check to see if string already begins with &H.\nIf Left(strValue, 2) <> \"&H\" Then strValue = \"&h\" & strValue\n\n' Check to see if string contains Decimals and strip them out.\nIf InStr(1, strValue, GetDecimalSep()) Then strValue = Left(strValue, (InStr(1, strValue, GetDecimalSep()) - 1))\n\nHex2Dec = CLng(strValue)\nExit Function\n\nCnvrtErr:\nHex2Dec = 0\n\nEnd Function\n\nFunction CtrlAltDel(Erlaubt As Boolean)\n'Ctrl Alt Del unter Win95 (und Win98) ausschalten.\n' Funktioniert lt. Newsgroups NICHT unter NT\n' Nur unter Win95 + 98 getestet\n\n' Erlaubt = True, dann Enable\n' Erlaubt = False, dann Disable\n\nDim Dummy\n\nIf Erlaubt Then\n    Call SystemParametersInfo(97, False, Dummy, 0)  ' enable Win95 system key\nElse\n    Call SystemParametersInfo(97, True, Dummy, 0)   ' kein alt-tab, ctrl-alt-del\nEnd If\n\nEnd Function\n\nFunction Euro()\n'Ausgabe des Eurozeichens, sofern man die Corefonts (Freefonts von MS) geladen hat\n' und als Font einer dieser neuen Fonts ausgewählt ist ...\n\n'Function im Direktfenster ausführen, das Eurozeichen ausschneiden. Es kann dann\n'überall da, wo \"neue\" Fonts verwendet werden, eingefügt werden ...\n\n' Leider ist MS Sans Serif nicht als Update verfügbar :-((((((((\n' Mit NT 4 SP4 ist auch MS Sans Serif eurofähig <g>\n\n'Es gibt (Stand 20.02.1998) unter\n'http://www.microsoft.com/typography/fontpack/default.htm\n'auch die neueren Fonts zum abholen (Arial, Times und andere), die das\n'Euro-Symbol haben. Sie haben den Zusatz \"32\", also Times32.exe,\n'Arial32.exe etc. Man kann sie aber als Paket holen: Corefonts für die\n'Standardfonts (Arial, Courier, Times) und ein anderes Paket für die\n'anderen (Verdana, Georgia usw.)\n\nEuro = ChrW(&H20AC)\n\nEnd Function\n\n\nPublic Function fmt_Euro$(lgEin@)\n\n    ' von Rainer Grau rgrau@ncs.de\n    \n    'Umrechnung und Ausgabe eines Betrags als String in Euro; Eingabe DM-Betrag\n    \n    'Der Arialfont wurde mit corfnt32.exe (zu beziehen unter\n    'http://www.microsoft.com/typography/fontpack/default.htm)\n    'auf Eurozeichen erweitert.\n    '\n    'Siehe auch tblEuroUmrechnung\n    '\n    'Etwas muehselig, aber funktioniert auch unter NT4.0\n    '\n    'ich zeige meine Betraege als Zeichenfolgen an und formatiere mit\n    'folgender Funktion:\n    \n    'hier ausnahmsweise definiert, damit es sich ohne Fehler kompilieren läßt.\n    'lgWechselKurs ist normalerweise eine globale Konstante\n    Dim lgWechselKurs As Double\n\n    Dim i%, strErg$, intPos%\n    \n    lgWechselKurs = 1.95583\n    \n    strErg = Format(lgEin / lgWechselKurs, \"Currency\")\n    intPos = InStr(1, strErg, \"DM\")\n    Mid(strErg, intPos, 2) = \"€ \"  'Arial Font; Eurozeichen aus Word\n    fmt_Euro$ = strErg             'in function kopiert\nEnd Function\n\n\n'--------------------------------------------------------------------------------------------\n' FUNKTION  : AutoDial(...)\n' ZWECK     : Automatische Wahl einer Telefonnummer mittels TAPI und WIN95 / 98 / NT4.0?\n' ARGUMENTE : stNumber = zuwählende Telefonnummer\n' ERGEBNIS  : -\n'Aus dem FAQ der Uni Kiel, Klaus Hoppe\n'--------------------------------------------------------------------------------------------\nPublic Function Autodial(ByVal stNumber As String)\n    Application.Run \"utility.wlib_AutoDial\", stNumber\nEnd Function\n\n\n'--------------------------------------------------------------------------------------------\n' Function ProgramClose(Handle As Long)\n' Aufruf mit: SendMessage Handle, WM_CLOSE, 0, 0\n' Aus www.basicworld.com\n'--------------------------------------------------------------------------------------------\nPublic Function ProgramClose(handle As Long)\n    SendMessage handle, WM_CLOSE, 0, 0\nEnd Function\n\n\nFunction MakeTempFileName(Extension As String) As String\n'INF: Sample Function to Generate a Random Temporary File Name\n'Article ID: Q88929\nOn Error Resume Next\nDim Isfile As Integer, FHandle As Integer, Cntr As Integer\nDim WinTemp As String, TF As String\n   Isfile = False\n   FHandle = FreeFile\n\nDo\n   WinTemp = Environ(\"TEMP\") & \"\\\"\n   'WinTemp = GetTempDir()\n   For Cntr = 1 To 8\n   WinTemp = WinTemp & Mid(LTrim(str(CInt(Rnd * 10))), 1, 1)\n   Next\n\n      TF = Trim(WinTemp$) & \".\" & Extension\n\n   Open TF For Output As #FHandle\nDebug.Print TF\n   Print #FHandle, \"This is a Temp file\"\nLoop While err > 0\nClose #FHandle\nMakeTempFileName = TF\n\nEnd Function\n\n\n\n'I had a problem where I had to run a series of reports and forms with a\n'predefined BusinessUnit. I didn't want it to change till I said so.\n'\n'The solution was to define a function that allows you to 'Set or Get' the value\n'you need and include that function as criteria in all your queries that are used\n'for reports or forms. (Use the like operator to get the a wildcard match.)\n'\n'it 's easy in Access 97, and you can hack out something like it in Access 2.0 if\n'you change the optional parameter to test IfNull()\n\nFunction BusinessUnit(Optional Bu) As String\n\n'Note this is a STATIC so it will remember its value between runs\nStatic sBu As String\n\nOn Error Resume Next\n\n   'If you don't assign a new Business Unit you'll get the last one\n     If Not IsMissing(Bu) Then\n\n      sBu = Bu\n\n     End If\n\n    If IsNull(sBu) Then\n\n    'This returns a wild card so that all Business Units will match\n     sBu = \"*\"\n\n    End If\n\n     BusinessUnit = sBu 'return the current value\n\nEnd Function\n\n'If you are a chaotic programmer like me, you will probably know this situation:\n'\n'While working on a larger Access project there are situations where some of the\n'Code you are writing can't be completed because it relies on things yet to be\n'implemented. (Or you are to lazy at the time). Then you forget this code because\n'it 's not essential, or only called in special situations.\n'\n'When the customer tries to use this 'feature' that you forgot to finish, one of\n'the following things will happen (add your favorite to this list):\n'\n'nothing at all,\n'the program crashes, or\n'nothing at all except many beeps and weird messages from test code you wrote.\n'\n'To overcome this, I wrote a VERY simple, but helpful function called 'The ToDo\n'function':\n\nFunction ToDo(Optional description As String)\n    MsgBox \"Not implemented.@@\" & description, vbInformation\nEnd Function\n'You can use it in Code or as event handler on forms. This has two advantages:\n'\n'Your Customers get a proper message\n'You can search your whole for \"ToDo\" to find unfinished parts\n\n\nSub FParsePath(ByVal FullPath As String, Drive As String, DirName As String, fname As String, Ext As String)\n'\n' Parses drive, directory, filename, and extension into separate variables.\n' Returns blank drive letter/path if none specified.\n' Frm Neatcd97.mdb (MS)\n'\nDim i As Integer, f As String, found As Integer\n  Drive = \"\"\n  DirName = \"\"\n  fname = \"\"\n  Ext = \"\"\n  FullPath = Trim$(FullPath)\n'\n' Get drive letter\n'\n  If Mid$(FullPath, 2, 1) = \":\" Then\n    Drive = Left$(FullPath, 2)\n    FullPath = Mid$(FullPath, 3)\n  End If\n'\n' Get directory name\n'\n  f = \"\"\n  found = False\n  For i = Len(FullPath) To 1 Step -1\n    If Mid$(FullPath, i, 1) = \"\\\" Then\n      f = Mid$(FullPath, i + 1)\n      DirName = Left$(FullPath, i)\n      found = True\n      Exit For\n    End If\n  Next i\n  If Not found Then\n    f = FullPath\n  End If\n'\n' Get File name and extension\n'\n  If f = \".\" Or f = \"..\" Then\n    fname = f\n  Else\n    i = InStrRev(f, \".\")\n    If i > 0 Then\n      fname = Left$(f, i - 1)\n      Ext = Mid$(f, i)\n    Else\n      fname = f\n    End If\n  End If\nEnd Sub\n\nFunction DBErstellen(strDatabaseName As String)\n    \n' Erstellen einer neuen Datenbank (z.b. auf Floppy)\n\n    Dim db As DAO.Database, nix\n    \nDBErstellen_Versuch:\n    err.clear\n    On Error GoTo DBErstellen_Error\n    \n    If Dir(strDatabaseName) = \"\" Then ' Datenbank existiert nicht\n        Set db = DBEngine.CreateDatabase(strDatabaseName, dbLangGeneral)\n        db.Close\n    End If\n    Exit Function\n    \nDBErstellen_Error:\n    If err.Number = 71 Then\n        err.clear\n        If MsgBox(\"Keine Diskette im Laufwerk A:\", vbCritical + vbOKCancel, \"Bitte Floppy einlegen\") = vbOK Then\n            GoTo DBErstellen_Versuch\n        Else\n            Exit Function\n        End If\n    Else\n        nix = MsgBox(\"Unerwarteter Fehler \" & err.Number, vbCritical, \"Allgemeiner Fehler\")\n        Exit Function\n    End If\n    End Function\n\n\nFunction DOSPgmStart(DosAufruf As String, Optional AufrufArt As Integer = vbMinimizedNoFocus)\nDim varDummy\n' Hergeleitet aus dem Newsgroup-Beispiel\n' vardummy = Shell(Environ(\"COMSPEC\") & \" /C COPY \" & Quelle & \" \" & Ziel, 6)\n\n' Beispiel:\n' Nix = DOSPgmStart(\"Copy C:\\Autoexec.bat A:\", 6)\n\n' AufrufArt einer der folgenden 6 Parameter: (aus der Hilfe:)\n\n'vbHide              0   Fenster ist ausgeblendet, und das ausgeblendete Fenster erhält den Fokus.\n'vbNormalFocus       1   Fenster hat den Fokus und wird mit der ursprünglichen Größe und Position wiederhergestellt.\n'vbMinimizedFocus    2   Fenster wird als Symbol angezeigt und hat den Fokus.\n'vbMaximizedFocus    3   Fenster ist maximiert und hat den Fokus.\n'vbNormalNoFocus     4   Fenster wird mit der letzten Größe und Position wiederhergestellt. Das momentan aktive Fenster bleibt aktiv.\n'vbMinimizedNoFocus  6   Fenster wird als Symbol angezeigt. Das momentan aktive Fenster bleibt aktiv.\n\nvarDummy = Shell(Environ(\"COMSPEC\") & \" /C \" & DosAufruf, AufrufArt)\n\nEnd Function\n\n' Aus der Newsgroup:\n'In VBA (in A97 getestet) kannst du  über die Controls-Auflistung auf wirklich\n'alle Felder eines Formulars zugreifen:\n'(Funktion nur innerhalb eines Formulars ausführbar, da Me verwendet wird)\n'\n' Funktion auskommentiert, da sonst Fehler beim Kompilieren ...\n\n'Sub ClearMyTxtboxes(formname As String)\nFunction Name_All_Labels(formName As String)\nDim i As Integer, Anz As Integer\nDim c As control\nDim frm As Form\nDoCmd.OpenForm formName, acDesign\nSet frm = Forms(formName)\n\nAnz = frm.controls.Count ' liefert die Anzahl Steuerelemente im Formular\nIf Anz <= 0 Then Exit Function ' keine Steuerelemente da\nFor i = 0 To Anz - 1\n    Set c = frm.controls(i)\n'    Debug.Print C.ControlType, C.Name\n    If c.ControlType = acLabel Then  ' wenn's n Label ist\n        MsgBox \" LabelName    = \" & c.Name & vbCrLf & _\n        \" LabelCaption = \" & c.caption\n    End If\nNext i\nDoCmd.Close acForm, formName\nEnd Function\n\n\n'OOTypFunction Add_Label_To_Table(otyp As Long, formname As String, C_ControlType As Long, C_Visible As Boolean, C_Name As String, C_Caption As String)\n\n\nFunction CloseAllForms()\n' Schließen aller Forms\n' aus der Newsgroup\n\nDim frm As Form\nDim FormNummer, i As Integer\nDim Ausnahme As String\n\nFormNummer = 0\ni = 0\nAusnahme = \"zUtilityServer\"\n\nWhile Forms.Count > 1\n    i = i + 1\n    Set frm = Forms(FormNummer)\n    If frm.formName = Ausnahme Then\n        FormNummer = 1\n    Else\n        If frm.Modal Then frm.Modal = False  '<<<added\n        If frm.PopUp Then frm.PopUp = False  '<<<added\n        DoCmd.Close acForm, frm.Name\n    End If\nWend\n\nEnd Function\n\n\nFunction dbname() As String\n' Ausgabe des aktuellen Datenbanknamens\ndbname = CurrentDb.Name\nEnd Function\n\n\nFunction DBPfad() As String\n' Ausgabe des aktuellen Datenbankpfades\nDBPfad = Left(CurrentDb.Name, Len(CurrentDb.Name) - Len(Dir(CurrentDb.Name)))\nEnd Function\n\nFunction Fehlercd()\n'Newsgroup - Raimund Linn\nDim X\n\nFor X = 1 To 32767\n    If Error$(X) <> \"Benutzerdefinierter Fehler\" _\n    And Error$(X) <> \"Reservierter Fehler\" _\n    And Error$(X) <> \"Anwendungs- oder objektdefinierter Fehler\" _\nThen Debug.Print X, Error$(X)\nNext X\n\nEnd Function\n\nFunction pz_berechnen(Wert As Variant)\n'Newsgroup Konrad Marfurt\n'PrüfZiffern-Verfahren Mod 10 rekursiv für VESR (Null gibt 0)\nIf IsNull(Wert) Then\n    pz_berechnen = \"???\"\n    Exit Function\nEnd If\nDim begriff As String, z0 As Integer, z1 As Integer, i As Integer\nConst z10 = \"0946827135\"\nbegriff = Wert\nz0 = 0\nFor i = 1 To Len(begriff)\n       z1 = val(Mid(begriff, i, 1))\n       z0 = val(Mid(z10, (z1 + z0) Mod 10 + 1, 1))\nNext i\npz_berechnen = Chr(Asc(\"0\") + (10 - z0) Mod 10)\nEnd Function\n\nFunction TestAdd(Zaehler As String, Optional Stepper As Integer) As String\n'KObd\n'Addiert oder subtrahiert einen Wert(Stepper) zu einem String\n'Wenn Stepper 0 oder nicht definiert, dann Stepper = 1\n'ausgehend von folgendem Aufbau:\n'Links eine Konstante mit der Länge LENLEFT, Rechts die Zahl\n\nConst LENLEFT = 1\n\nDim LenRight As Integer\nDim leftchr As String\nDim rightnum As Long\nDim rightTmp\n\nIf Len(Trim(Nz(Zaehler))) = 0 Then\n    MsgBox \"Kein Zähler übergeben\"\n    Exit Function\nEnd If\n\nLenRight = Len(Zaehler) - LENLEFT\n\nIf Stepper = 0 Then 'Stepper = 0 oder nicht übergeben\n    Stepper = 1\nEnd If\n\nleftchr = Left(Zaehler, LENLEFT)\nrightnum = Right(Zaehler, LenRight)\n\nrightTmp = rightnum + Stepper\nTestAdd = leftchr & Right(\"0000000000000000000000000000\" & rightTmp, LenRight)\n\nEnd Function\n\nPublic Function CurrMDBSchliessen()\n   Application.CloseCurrentDatabase\nEnd Function\n\nFunction backup_Reminder(AnzahlTage As Integer)\n'Erzeugt eine private Property namens \"BackupReminder\" die als Wert\n'das Datum der letzten Erinnerung hat.\n'Diese Property wird ausgelesen und mit dem übergebenen Wert verglichen.\n'Wenn die Anzahl der Tage (AnzahlTage) überschritten ist, wird eine Warnung ausgelöst.\n'Eine Warnung wird IMMER ausgelöst, wenn AnzahlTage = 0 ist.\n'Kann in die Autoexec eingebunden werden\n' Benötigt das Modul \"mdlPrivProperty\"\nDim Letzter_Reminder, nix\nDim LeRimDat As Date\nOn Error Resume Next\nLetzter_Reminder = Get_Priv_Property(\"BackupReminder\")\nIf Len(Nz(Letzter_Reminder)) = 0 Then\n    LeRimDat = Date\nElse\n    LeRimDat = Letzter_Reminder\nEnd If\nIf (Not (LeRimDat > (Date - AnzahlTage))) Then ' Datum kleiner oder gleich Heute\n    Call Beep\n    MsgBox \"Bitte Backup der Datenbank nicht vergessen\", vbExclamation, \"Backup-Warnung\"\n    nix = Set_Priv_Property(\"BackupReminder\", Format(Date, \"dd\") & \"-\" & Format(Date, \"mmm\") & \"-\" & Format(Date, \"yyyy\"))\nEnd If\nEnd Function\n\nFunction XPath(AltPathDatei As String, ByVal NeuPath As String) As String\n'Bestehenden Pfad durch einen fixen anderen ersetzen, benötigt FParsePath\nDim XDrive As String, XDirName As String, XfName As String, XExt As String\nIf Len(Trim(Nz(AltPathDatei))) = 0 Then\n    XPath = \"\"\n    Exit Function\nEnd If\nCall FParsePath(AltPathDatei, XDrive, XDirName, XfName, XExt)\nIf Right(NeuPath, 1) <> \"\\\" Then NeuPath = NeuPath & \"\\\"\nXPath = NeuPath & XfName & XExt\nEnd Function\n\n\nFunction WelcheRegisterSeite(Feldname As String, DeinRegisterSteuerelement As control)\n'wie kann ich denn per VB-Code herausfinden, auf welcher Registerseite (im\n'Reg-StE) sich ein bestimmtes Steuerelement (Textfeld, List oder Kombo)\n'befindet?\n'Das Ergebnis sollte in etwa so aussehen:\n'\"Das Feld <Feld-Name> befindet sich im Register <Register-Überschrift>\"\n'Karl Donaubauer schrieb: Sendkeys\n'Also in's Formularmodul damit und Aufruf mit\n' = WelcheRegisterSeite(\"DeinFeldname\", \"DeinRegisterSteuerelement\")\n'\nDim p As Page\nDim c As control\nFor Each p In DeinRegisterSteuerelement.Pages\n    For Each c In p.controls\n        If c.Name = Feldname Then\n            MsgBox \"Das Feld \" & Feldname & \" befindet sich im Register \" & p.Name\n        End If\n    Next c\nNext p\nEnd Function\n\n\nFunction ANSIToUni(varAnsi As Variant) As Variant\n    ' Convert an ANSI string to Unicode.\n    \n    ANSIToUni = StrConv(varAnsi, vbUnicode)\nEnd Function\n\nFunction UniToAnsi(varUni As Variant) As Variant\n    ' Convert a Unicode string to ANSI.\n    \n    UniToAnsi = StrConv(varUni, vbFromUnicode)\nEnd Function\n\n\n'Und schon piepst er:\n'Autor: Newsgroup -  Fredi Hertel\n\n'Private Declare PtrSafe Function api_Beep Lib \"kernel32\" Alias \"Beep\" (ByVal dwFreq As Long, ByVal dwDuration As Long) As Long\n\n     ' Inputs:dwFreq\n     ' Specifies the frequency, in hertz, of the sound.\n     ' This parameter must be in the range 37 through 32,767\n     ' (0x25 through 0x7FFF).\n     ' dwDuration Beep\n     ' Specifies the duration, in milliseconds, of the sound.\n     ' One value has a special meaning: If dwDuration is - 1, the\n     ' Function operates asynchronously and produces sound until called again.\n     '\n     ' Returns:If the function succeeds, the return value is TRUE.\n     ' If the Function fails, the return value is FALSE. To Get extended\n     ' Error information, call GetLastError.\n     '\n     'Assumes:\n     'The Beep Function is synchronous in all but one case; the function does\n     ' not generally return control to its caller until the sound finishes.\n     ' The exception to this occurs when dwDuration has the value - 1.\n     ' In that case, Beep is asynchronous, returning control immediately to\n     ' its caller While the sound continues playing. The sound continues\n     ' until the Next call to Beep.\n\nSub GetFormsProp2(ByVal objektName As String, Optional ObjektTyp As Integer)\n'Autor: Newsgroup Roman Havlik, Erweiterungen Kobd\n'> Wie kann ich das Änderungsdatum von Forms, reports u.ä. auslesen ? Bei\n'> Tabellen und Abfragen hab' ich keine Probleme...\n'\n'Einfach per Code die entsprechende Eigenschaft (LastUpdated) auslesen. Anbei\n'eine Prozedur die das machen sollte;-))\n    Dim frmChk As Document\n    Dim frmPrp As Property\nOn Error GoTo GetFormsProp2_Err\n\nSelect Case ObjektTyp\n    Case acForm\n        Set frmChk = DAO.DBEngine(0)(0).Containers!Forms(objektName)\n    Case acReport\n        Set frmChk = DAO.DBEngine(0)(0).Containers!Reports(objektName)\n    Case acTable\n        Set frmChk = DAO.DBEngine(0)(0).Containers!tables(objektName)\n    Case acQuery\n        MsgBox \"Queries nicht unterstützt\", vbCritical\n        GoTo GetFormsProp2_Exit\n'        Set frmChk = DAO.DBEngine(0)(0).Containers!Queries(Objektname)\n    Case acMacro\n        Set frmChk = DAO.DBEngine(0)(0).Containers!Scripts(objektName)\n    Case acModule\n        Set frmChk = DAO.DBEngine(0)(0).Containers!Modules(objektName)\n    Case Else\n        Set frmChk = DAO.DBEngine(0)(0).Containers!Databases(0)\nEnd Select\n'\n    For Each frmPrp In frmChk.Properties\n        Debug.Print frmPrp.Name, frmPrp.Value\n    Next\n    \nGetFormsProp2_Exit:\n    Exit Sub\nGetFormsProp2_Err:\n    MsgBox err.description, vbInformation, err.Number\n    Resume GetFormsProp2_Exit\nEnd Sub\n\n\nSub PropTst()\nCall GetFormsProp2(\"tblStdBilder\", acTable)\nCall GetFormsProp2(\"qrptStückliste\", acQuery)\nCall GetFormsProp2(\"frmJagd\", acForm)\nCall GetFormsProp2(\"rptTimeLines\", acReport)\nCall GetFormsProp2(\"Autoexec Beispiel Verbinde\", acMacro)\nCall GetFormsProp2(\"mdlProperties\", acModule)\nCall GetFormsProp2(\"\", 27)\nEnd Sub\n"}
