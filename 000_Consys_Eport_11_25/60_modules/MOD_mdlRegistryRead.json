{"id":"MOD_mdlRegistryRead","name":"mdlRegistryRead","kind":"standard","procedures":["Public Function SetValueEx(ByVal hKey As Long, sValueName As String, _","Function QueryValueEx(ByVal lhKey As Long, ByVal szValueName As _","Function QueryValue(StartDirectory, sKeyName As String, sValueName As String) As String","Function GetRegistryValue(ByVal hKey As Long, ByVal KeyName As String, _"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\n' GetRegistryValue - Read the value of a Registry key\n'Private Declare PtrSafe Function RegOpenKeyEx Lib \"advapi32.dll\" Alias \"RegOpenKeyExA\" _\n'    (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, _\n'    ByVal samDesired As Long, phkResult As Long) As Long\n'Private Declare PtrSafe Function RegCloseKey Lib \"advapi32.dll\" (ByVal hKey As Long) As _\n'    Long\n'Private Declare PtrSafe Function RegQueryValueEx Lib \"advapi32.dll\" Alias _\n'    \"RegQueryValueExA\" (ByVal hKey As Long, ByVal lpValueName As String, _\n'    ByVal lpReserved As Long, lpType As Long, lpData As Any, _\n'    lpcbData As Long) As Long\nPrivate Declare PtrSafe Sub CopyMemory Lib \"kernel32\" Alias \"RtlMoveMemory\" (dest As _\n    Any, Source As Any, ByVal numBytes As Long)\n\nConst KEY_READ = &H20019  ' ((READ_CONTROL Or KEY_QUERY_VALUE Or\n                          ' KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY) And (Not\n                          ' SYNCHRONIZE))\n\nConst REG_EXPAND_SZ = 2\nConst REG_MULTI_SZ = 7\nConst ERROR_MORE_DATA = 234\n\n\n\n\nGlobal Const REG_SZ As Long = 1\nGlobal Const REG_DWORD As Long = 4\nGlobal Const REG_BINARY As Long = 3\n\nGlobal Const HKEY_CLASSES_ROOT = &H80000000\nGlobal Const HKEY_CURRENT_USER = &H80000001\nGlobal Const HKEY_LOCAL_MACHINE = &H80000002\nGlobal Const HKEY_USERS = &H80000003\n\nGlobal Const ERROR_NONE = 0\nGlobal Const ERROR_BADDB = 1\nGlobal Const ERROR_BADKEY = 2\nGlobal Const ERROR_CANTOPEN = 3\nGlobal Const ERROR_CANTREAD = 4\nGlobal Const ERROR_CANTWRITE = 5\nGlobal Const ERROR_OUTOFMEMORY = 6\nGlobal Const ERROR_INVALID_PARAMETER = 7\nGlobal Const ERROR_ACCESS_DENIED = 8\nGlobal Const ERROR_INVALID_PARAMETERS = 87\nGlobal Const ERROR_NO_MORE_ITEMS = 259\n\nGlobal Const KEY_ALL_ACCESS = &H3F\n\nGlobal Const REG_OPTION_NON_VOLATILE = 0\n\nPublic Const KEY_SET_VALUE = &H2\n\nType SECURITY_ATTRIBUTES\n        nLength As Long\n        lpSecurityDescriptor As Long\n        bInheritHandle As Long\nEnd Type\n\nDim hKey As Long\nDim sz As Long\nDim Success As Long\nDim v$\nDim nval&\n\n\nDeclare PtrSafe Function RegCloseKey Lib \"advapi32.dll\" _\n(ByVal hKey As Long) As Long\n\nDeclare PtrSafe Function RegCreateKeyEx Lib \"advapi32.dll\" Alias _\n\"RegCreateKeyExA\" (ByVal hKey As Long, ByVal lpSubKey As String, _\nByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions _\nAs Long, ByVal samDesired As Long, ByVal lpSecurityAttributes _\nAs Long, phkResult As Long, lpdwDisposition As Long) As Long\n\nDeclare PtrSafe Function RegOpenKeyEx Lib \"advapi32.dll\" Alias _\n\"RegOpenKeyExA\" (ByVal hKey As Long, ByVal lpSubKey As String, _\nByVal ulOptions As Long, ByVal samDesired As Long, phkResult As _\nLong) As Long\n\nDeclare PtrSafe Function RegQueryValueExString Lib \"advapi32.dll\" Alias _\n\"RegQueryValueExA\" (ByVal hKey As Long, ByVal lpValueName As _\nString, ByVal lpReserved As Long, lpType As Long, ByVal lpData _\nAs String, lpcbData As Long) As Long\n\nPrivate Declare PtrSafe Function RegQueryValueEx Lib \"advapi32.dll\" Alias _\n    \"RegQueryValueExA\" (ByVal hKey As Long, ByVal lpValueName As String, _\n    ByVal lpReserved As Long, lpType As Long, lpData As Any, _\n    lpcbData As Long) As Long\n\n\nDeclare PtrSafe Function RegQueryValueExLong Lib \"advapi32.dll\" Alias _\n\"RegQueryValueExA\" (ByVal hKey As Long, ByVal lpValueName As _\nString, ByVal lpReserved As Long, lpType As Long, lpData As _\nLong, lpcbData As Long) As Long\n\nDeclare PtrSafe Function RegQueryValueExNULL Lib \"advapi32.dll\" Alias _\n\"RegQueryValueExA\" (ByVal hKey As Long, ByVal lpValueName As _\nString, ByVal lpReserved As Long, lpType As Long, ByVal lpData _\nAs Long, lpcbData As Long) As Long\n\nDeclare PtrSafe Function RegSetValueExString Lib \"advapi32.dll\" Alias _\n\"RegSetValueExA\" (ByVal hKey As Long, ByVal lpValueName As String, _\nByVal Reserved As Long, ByVal dwType As Long, ByVal lpValue As _\nString, ByVal cbData As Long) As Long\n\nDeclare PtrSafe Function RegSetValueExLong Lib \"advapi32.dll\" Alias _\n\"RegSetValueExA\" (ByVal hKey As Long, ByVal lpValueName As String, _\nByVal Reserved As Long, ByVal dwType As Long, lpValue As Long, _\nByVal cbData As Long) As Long\n   \n   \n   \n'SetValueEx and QueryValueEx Wrapper Functions:\n\nPublic Function SetValueEx(ByVal hKey As Long, sValueName As String, _\n   lType As Long, vValue As Variant) As Long\n       Dim lValue As Long\n       Dim sValue As String\n       Select Case lType\n           Case REG_SZ\n               sValue = vValue & Chr$(0)\n               SetValueEx = RegSetValueExString(hKey, sValueName, 0&, _\n                                              lType, sValue, Len(sValue))\n           Case REG_DWORD\n               lValue = vValue\n               SetValueEx = RegSetValueExLong(hKey, sValueName, 0&, _\n   lType, lValue, 4)\n           End Select\nEnd Function\n\nFunction QueryValueEx(ByVal lhKey As Long, ByVal szValueName As _\n   String, vValue As Variant) As Long\n       Dim cch As Long\n       Dim lrc As Long\n       Dim lType As Long\n       Dim lValue As Long\n       Dim sValue As String\n\n       On Error GoTo QueryValueExError\n\n       ' Determine the size and type of data to be read\n       lrc = RegQueryValueExNULL(lhKey, szValueName, 0&, lType, 0&, cch)\n       If lrc <> ERROR_NONE Then Error 5\n\n       Select Case lType\n           ' For strings\n           Case REG_SZ:\n               sValue = String(cch, 0)\n   lrc = RegQueryValueExString(lhKey, szValueName, 0&, lType, _\n   sValue, cch)\n               If lrc = ERROR_NONE Then\n                   vValue = Left$(sValue, cch - 1)\n               Else\n                   vValue = Empty\n               End If\n           ' For DWORDS\n           Case REG_DWORD:\n   lrc = RegQueryValueExLong(lhKey, szValueName, 0&, lType, _\n   lValue, cch)\n               If lrc = ERROR_NONE Then vValue = lValue\n           Case Else\n               'all other data types not supported\n               lrc = -1\n       End Select\n\nQueryValueExExit:\n       QueryValueEx = lrc\n       Exit Function\nQueryValueExError:\n       Resume QueryValueExExit\n   End Function\n\n\nFunction QueryValue(StartDirectory, sKeyName As String, sValueName As String) As String\n'*****************************\n' Diese Function gibt den Wert eines Keys zurück, der in der Registry steht.\n'\n' Beispiel: QueryValue(HKEY_LOCAL_MACHINE, \"SOFTWARE\\Microsoft\\Shared Tools\\MSInfo\", \"Path\")\n'\n' Gibt den korrekten Dateinamen incl. Pfad für MSINFO32 zurück oder einen Leerstring, wenn nicht installiert\n' StartDirectory muß eine der folgenden Variablen sein:\n'\n'            HKEY_CLASSES_ROOT\n'            HKEY_CURRENT_USER\n'            HKEY_LOCAL_MACHINE\n'            HKEY_USERS\n'\n' Den Wert, den man sucht, ermittelt man am besten zuerst manuell aus der Registry,\n' in dem man direkt in der Registry sucht ...\n'\n' Näheres siehe unter: HOWTO - Use the Registry API to Save and Retrieve Setting.htm\n' und: Controlling Entries in the Operating System Registry\n'*******************************\n       \n       Dim lRetVal As Long         'result of the API functions\n       Dim hKey As Long            'handle of opened key\n       Dim vValue As Variant       'setting of queried value\n       \n       lRetVal = RegOpenKeyEx(StartDirectory, sKeyName, 0, KEY_ALL_ACCESS, hKey)\n       lRetVal = QueryValueEx(hKey, sValueName, vValue)\n       \n       QueryValue = vValue & \"\"\n       RegCloseKey (hKey)\nEnd Function\n\n\n\n\n\n' Read a Registry value\n'\n' Use KeyName = \"\" for the default value\n' If the value isn't there, it returns the DefaultValue\n' argument, or Empty if the argument has been omitted\n'\n' Supports DWORD, REG_SZ, REG_EXPAND_SZ, REG_BINARY and REG_MULTI_SZ\n' REG_MULTI_SZ values are returned as a null-delimited stream of strings\n' (VB6 users can use SPlit to convert to an array of string)\n\nFunction GetRegistryValue(ByVal hKey As Long, ByVal KeyName As String, _\n    ByVal ValueName As String, Optional defaultValue As Variant) As Variant\n    Dim handle As Long\n    Dim resLong As Long\n    Dim resString As String\n    Dim resBinary() As Byte\n    Dim Length As Long\n    Dim Retval As Long\n    Dim valueType As Long\n    Dim i As Long\n    \n    ' Prepare the default result\n    GetRegistryValue = IIf(IsMissing(defaultValue), Empty, defaultValue)\n    \n    ' Open the key, exit if not found.\n    If RegOpenKeyEx(hKey, KeyName, 0, KEY_READ, handle) Then\n        Exit Function\n    End If\n    \n    ' prepare a 1K receiving resBinary\n    Length = 1024\n    ReDim resBinary(0 To Length - 1) As Byte\n    \n    ' read the registry key\n    Retval = RegQueryValueEx(handle, ValueName, 0, valueType, resBinary(0), _\n        Length)\n    ' if resBinary was too small, try again\n    If Retval = ERROR_MORE_DATA Then\n        ' enlarge the resBinary, and read the value again\n        ReDim resBinary(0 To Length - 1) As Byte\n        Retval = RegQueryValueEx(handle, ValueName, 0, valueType, resBinary(0), _\n            Length)\n    End If\n    \n    ' return a value corresponding to the value type\n    Select Case valueType\n        Case REG_DWORD\n            CopyMemory resLong, resBinary(0), 4\n            GetRegistryValue = resLong\n        Case REG_SZ, REG_EXPAND_SZ\n            ' copy everything but the trailing null char\n            resString = Space$(Length - 1)\n            CopyMemory ByVal resString, resBinary(0), Length - 1\n            GetRegistryValue = resString\n        \n        Case REG_BINARY\n            ' resize the result resBinary\n            If Length <> UBound(resBinary) + 1 Then\n                ReDim Preserve resBinary(0 To Length - 1) As Byte\n            End If\n'            GetRegistryValue = resBinary()\n            GetRegistryValue = \"\"\n            For i = 0 To UBound(resBinary)\n                GetRegistryValue = GetRegistryValue & Right(\"00\" & Hex(resBinary(i)), 2) & \" \"\n            Next i\n        \n        Case REG_MULTI_SZ\n            ' copy everything but the 2 trailing null chars\n            resString = Space$(Length - 2)\n            CopyMemory ByVal resString, resBinary(0), Length - 2\n            GetRegistryValue = resString\n        Case Else\n            RegCloseKey handle\n            err.Raise 1001, , \"Unsupported value type\"\n    End Select\n    \n    ' close the registry key\n    RegCloseKey handle\nEnd Function\n"}
