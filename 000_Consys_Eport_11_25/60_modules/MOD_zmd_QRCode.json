{"id":"MOD_zmd_QRCode","name":"zmd_QRCode","kind":"standard","procedures":["Public Sub drawQuickResponse(Text As TextBox, Optional level As String, Optional version As Integer = 1)","Private Function getPattern(ByVal X As Long, ByVal Y As Long, ByVal m As Integer, ByVal version As Integer) As Integer"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Explicit\nDim mat() As Byte, kanji As String ' matrix of QR, unicode to kanji conversion\n\n' QR Code 2005 bar code symbol creation according ISO/IEC 18004:2006\n'   param text: barcode data\n'   param level optional: quality level LMQH\n'   param version optional: minimum version size (-3:M1, -2:M2, .. 1, .. 40)\n'  called from report Detail_Format() to draw DataMatrix barcode QR and micro QR bar code symbol\nPublic Sub drawQuickResponse(Text As TextBox, Optional level As String, Optional version As Integer = 1)\nDim mode As Byte, lev As Byte, s As Long, a As Long, blk As Long, ec As Long\nDim i As Long, j As Long, k As Long, L As Long, c As Long, b As Long\nDim w As Long, X As Long, Y As Long, v As Double, el As Long, eb As Long\nDim m As Long, p As Variant, ecw As Variant, ecb As Variant\nDim rpt As Report, txt As String, k1 As String, k2 As String, r As Double\nConst alpha = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\"\nSet rpt = Text.Parent\nOn Error Resume Next ' get unicode to kanji conversion string\nIf kanji = \"\" Then kanji = \" \": kanji = CurrentDb.OpenRecordset(\"kanji\", dbOpenTable, dbReadOnly)(\"kanji\")\nOn Error GoTo failed\nIf level = \"\" Then\n    i = InStr(LCase(Text.TAG), \"qrcode\") ' get quality level from name postfix\n    If (i > 0 And i + 5 < Len(Text.TAG)) Then level = Mid(Text.TAG, i + 6, 1)\nEnd If\nlev = (InStr(\"LMQHlmqh0123\", level) - 1) And 3\nFor i = 1 To Len(Text) ' compute mode\n    c = AscW(Mid(Text, i, 1))\n    If c < 48 Or c > 57 Then\n        If mode = 0 Then mode = 1 ' alphanumeric mode\n        If InStr(alpha, ChrW(c)) = 0 Then\n            If mode = 1 Then mode = 2 ' binary or kanji ?\n            If c < 32 Or c > 126 Then\n                If InStr(Len(kanji) / 2 + 1, kanji, ChrW(c)) = 0 Then mode = 2: Exit For ' binary\n                mode = 3 ' kanji\n            End If\n        End If\n    End If\nNext i\ntxt = IIf(mode = 2, utf16to8(Text), Text) ' for reader conformity\nL = Len(txt)\nw = Int(L * Array(10 / 3, 11 / 2, 8, 13)(mode) + 0.5) ' 3 digits in 10 bits, 2 chars in 11 bits, 1 byte, 13 bits/byte\np = Array(Array(10, 12, 14), Array(9, 11, 13), Array(8, 16, 16), Array(8, 10, 12))(mode) ' # of bits of count indicator\n' error correction words L,M,Q,H and blocks L,M,Q,H for all version sizes (99=N/A)\necw = Array(Array(2, 5, 6, 8, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30), _\n    Array(99, 6, 8, 10, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28), _\n    Array(99, 99, 99, 14, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30), _\n    Array(99, 99, 99, 99, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30))\necb = Array(Array(1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25), _\n    Array(1, 1, 1, 1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49), _\n    Array(1, 1, 1, 1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68), _\n    Array(1, 1, 1, 1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81))\nversion = IIf(version < mode - 3, mode - 3, version) - 1\nDo ' compute QR size\n    version = version + 1\n    If version + 3 > UBound(ecb(0)) Then err.Raise 515, \"QRCode\", \"Message too long\"\n    s = version * IIf(version < 1, 2, 4) + 17 ' symbol size\n    j = ecb(lev)(version + 3) * ecw(lev)(version + 3)   ' error correction\n    a = IIf(version < 2, 0, version \\ 7 + 2) ' # of align pattern\n    el = (s - 1) * (s - 1) - (5 * a - 1) * (5 * a - 1) ' total bits - align - timing\n    el = el - IIf(version < 1, 59, IIf(version < 2, 191, IIf(version < 7, 136, 172))) ' finder, version, format\n    k = IIf(version < 1, version + (19 - 2 * mode) \\ 3, p((version + 7) \\ 17)) ' count indcator bits\n    i = IIf(version < 1, version + (version And 1) * 4 + 3, 4) ' mode indicator bits, M1+M3: +4 bits\nLoop While (el And -8) - 8 * j < w + i + k\nFor lev = lev To 2 ' increase security level if data still fits\n    j = ecb(lev + 1)(version + 3) * ecw(lev + 1)(version + 3)\n    If (el And -8) - 8 * j < w + i + k Then Exit For\nNext lev\nblk = ecb(lev)(version + 3) ' # of error correction blocks\nec = ecw(lev)(version + 3) ' # of error correction bytes\nel = el \\ 8 - ec * blk ' data capacity\nw = el \\ blk ' # of words in group 1\nb = blk + w * blk - el ' # of blocks in group 1\n\nReDim enc(el + ec * blk) As Byte, mat(s - 1, s - 1) As Byte\nc = 0 ' encode head indicator bits\nIf version > 0 Then v = 2 ^ mode: eb = 4 Else v = mode: eb = version + 3 ' mode indicator\neb = eb + k: v = v * 2 ^ k + L ' character count indicator\nFor i = 1 To L ' encode data\n    Select Case mode\n    Case 0: ' numeric\n        v = v * IIf(i + 1 < L, 1024, IIf(i < L, 128, 16)) + val(Mid(txt, i, 3))\n        eb = eb + IIf(i + 1 < L, 10, 4 + 3 * (L - i)): i = i + 2\n    Case 1: ' alphanumeric\n        j = InStr(alpha, Mid(txt, i, 1)) - 1\n        If i < L Then j = 45 * j + InStr(alpha, Mid(txt, i + 1, 1)) - 1\n        v = v * IIf(i < L, 2048, 64) + j\n        eb = eb + IIf(i < L, 11, 6): i = i + 1\n    Case 2: ' binary\n        v = v * 256 + Asc(Mid(txt, i, 1))\n        eb = eb + 8\n    Case 3: ' Kanji\n        j = InStr(Len(kanji) / 2 + 1, kanji, Mid(txt, i, 1)) - Len(kanji) / 2\n        j = (AscW(Mid(kanji, j, 1)) And &H3FFF) - 320 ' unicode to shift JIS X 2008\n        v = v * 8192 + (j \\ 256) * 192 + (j And 255) ' to 13 bit kanji\n        eb = eb + 13\n    End Select\n    For eb = eb To 8 Step -8 ' add data to bit stream\n        j = 2 ^ (eb - 8): enc(c) = v \\ j\n        v = v - enc(c) * j: c = c + 1\n    Next eb\nNext i\nIf el > c Then i = IIf(version > 0, 4, version + 6): v = v * 2 ^ i: eb = eb + i ' terminator\nenc(c) = v * 256 \\ 2 ^ eb: c = c + 1: enc(c) = (v * 65536 \\ 2 ^ eb) And 255\nIf eb > 8 And el >= c Then c = c + 1 ' bit padding\nIf (version And -3) = -3 And el = c Then enc(c) = enc(c) \\ 16 ' M1,M3: shift high bits to low nibble\ni = 236\nFor c = c To el - 1 ' byte padding\n    enc(c) = IIf((version And -3) = -3 And c = el - 1, 0, i)\n    i = i Xor 236 Xor 17\nNext c\n\nReDim rs(ec + 1) As Integer ' compute Reed Solomon error detection and correction\nDim lg(256) As Integer, ex(255) As Integer ' log/exp table\nj = 1\nFor i = 0 To 254\n    ex(i) = j: lg(j) = i ' compute log/exp table of Galois field\n    j = j + j: If j > 255 Then j = j Xor 285 ' GF polynomial a^8+a^4+a^3+a^2+1 = 100011101b = 285\nNext i\nrs(0) = 1 ' compute RS generator polynomial\nFor i = 0 To ec - 1\n    rs(i + 1) = 0\n    For j = i + 1 To 1 Step -1\n        rs(j) = rs(j) Xor ex((lg(rs(j - 1)) + i) Mod 255)\n    Next j\nNext i\neb = el: k = 0\nFor c = 1 To blk  ' compute RS correction data for each block\n    For i = IIf(c <= b, 1, 0) To w\n        X = enc(eb) Xor enc(k)\n        For j = 1 To ec\n            enc(eb + j - 1) = enc(eb + j) Xor IIf(X, ex((lg(rs(j)) + lg(X)) Mod 255), 0)\n        Next j\n        k = k + 1\n    Next i\n    eb = eb + ec\nNext c\n\n' fill QR matrix\nFor i = 8 To s - 1 ' timing pattern\n    mat(i, IIf(version < 1, 0, 6)) = i And 1 Xor 3\n    mat(IIf(version < 1, 0, 6), i) = i And 1 Xor 3\nNext i\nIf version > 6 Then ' reserve version area\n    For i = 0 To 17\n        mat(i \\ 3, s - 11 + i Mod 3) = 2\n        mat(s - 11 + i Mod 3, i \\ 3) = 2\n    Next i\nEnd If\nIf a < 2 Then a = IIf(version < 1, 1, 2)\nFor X = 1 To a ' layout finder/align pattern\n    For Y = 1 To a\n        If X = 1 And Y = 1 Then ' finder upper left\n            i = 0: j = 0\n            p = Array(383, 321, 349, 349, 349, 321, 383, 256, 511)\n        ElseIf X = 1 And Y = a Then  ' finder lower left\n            i = 0: j = s - 8\n            p = Array(256, 383, 321, 349, 349, 349, 321, 383)\n        ElseIf X = a And Y = 1 Then  ' finder upper right\n            i = s - 8: j = 0\n            p = Array(254, 130, 186, 186, 186, 130, 254, 0, 255)\n        Else ' alignment grid\n            c = 2 * Int(2 * (version + 1) / (1 - a)) ' pattern spacing\n            i = IIf(X = 1, 4, s - 9 + c * (a - X))\n            j = IIf(Y = 1, 4, s - 9 + c * (a - Y))\n            p = Array(31, 17, 21, 17, 31) ' alignment pattern\n        End If\n        If version <> 1 Or X + Y < 4 Then ' no align pattern for version 1\n            For c = 0 To UBound(p) ' set fixed pattern, reserve space\n                m = p(c): k = 0\n                Do\n                    mat(i + k, j + c) = (m And 1) Or 2\n                    m = m \\ 2: k = k + 1\n                Loop While 2 ^ k <= p(0)\n            Next c\n        End If\n    Next Y\nNext X\nX = s: Y = s - 1 ' layout codewords\nFor i = 0 To eb - 1\n    c = 0: k = 0: j = w + 1 ' interleave data\n    If i >= el Then\n        c = el: k = el: j = ec ' interleave checkwords\n    ElseIf i + blk - b >= el Then\n        c = -b: k = c ' interleave group 2 last bytes\n    ElseIf (i Mod blk) >= b Then\n        c = -b ' interleave group 2\n    Else\n        j = j - 1 ' interleave group 1\n    End If\n    c = enc(c + ((i - k) Mod blk) * j + (i - k) \\ blk) ' interleave data\n    For j = IIf((-3 And version) = -3 And i = el - 1, 3, 7) To 0 Step -1 ' M1,M3: 4 bit\n        k = IIf(version > 0 And X < 6, 1, 0) ' skip vertical timing pattern\n        Do ' advance x,y\n            X = X - 1\n            If 1 And (X + 1) Xor k Then\n                If s - X - k And 2 Then\n                    If Y > 0 Then Y = Y - 1: X = X + 2 ' up, top turn\n                Else\n                    If Y < s - 1 Then Y = Y + 1: X = X + 2 ' down, bottom turn\n                End If\n            End If\n        Loop While mat(X, Y) And 2 ' skip reserved area\n        If c And 2 ^ j Then mat(X, Y) = 1\n    Next j\nNext i\n\nm = 0: p = 1000000 ' data masking\nFor k = 0 To IIf(version < 1, 3, 7)\n    If version < 1 Then ' penalty micro QR\n        X = 1: Y = 1\n        For i = 1 To s - 1\n            X = X - getPattern(i, s - 1, k, version)\n            Y = Y - getPattern(s - 1, i, k, version)\n        Next i\n        j = IIf(X > Y, 16 * X + Y, X + 16 * Y)\n    Else ' penalty QR\n        L = 0: k2 = \"\": j = 0\n        For Y = 0 To s - 1 ' horizontal\n            c = 0: i = 0: k1 = \"0000\"\n            For X = 0 To s - 1\n                w = getPattern(X, Y, k, version)\n                L = L + w: k1 = k1 & w ' rule 4: count darks\n                If c = w Then ' same as prev\n                    i = i + 1\n                    If X And Mid(k2, X + 4, 2) = c & c Then j = j + 3 ' rule 2: block 2x2\n                Else\n                    If i > 5 Then j = j + i - 2 ' rule 1: >5 adjacent\n                    c = 1 - c: i = 1\n                End If\n            Next X\n            If i > 5 Then j = j + i - 2 ' rule 1: >5 adjacent\n            i = 0\n            Do ' rule 3: like finder pattern\n                i = InStr(i + 4, k1, \"1011101\")\n                If i < 1 Then Exit Do\n                If Mid(k1, i - 4, 4) = \"0000\" Or Mid(k1 & \"0000\", i + 7, 4) = \"0000\" Then j = j + 40\n            Loop\n            k2 = k1 ' rule 2: remember last line\n        Next Y\n        For X = 0 To s - 1 ' vertical\n            c = 0: i = 0: k1 = \"0000\"\n            For Y = 0 To s - 1\n                w = getPattern(X, Y, k, version)\n                k1 = k1 & w ' vertical to string\n                If c = w Then ' same as prev\n                    i = i + 1\n                Else\n                    If i > 5 Then j = j + i - 2 ' rule 1: >5 adjacent\n                    c = 1 - c: i = 1\n                End If\n            Next Y\n            If i > 5 Then j = j + i - 2 ' rule 1: >5 adjacent\n            i = 0\n            Do ' rule 3: like finder pattern\n                i = InStr(i + 4, k1, \"1011101\")\n                If i < 1 Then Exit Do\n                If Mid(k1, i - 4, 4) = \"0000\" Or Mid(k1 & \"0000\", i + 7, 4) = \"0000\" Then j = j + 40\n            Loop\n        Next X\n        j = j + Int(Abs(10 - 20 * L / (s * s))) * 10 ' rule 4: darks\n    End If\n    If j < p Then p = j: m = k ' take mask of lower penalty\nNext k\n' add format information, code level and mask\nj = IIf(version = -3, m, IIf(version < 1, (2 * version + lev + 5) * 4 + m, ((5 - lev) And 3) * 8 + m))\nj = j * 1024: k = j\nFor i = 4 To 0 Step -1 ' BCH error correction: 5 data, 10 error bits\n    If j >= 1024 * 2 ^ i Then j = j Xor 1335 * 2 ^ i\nNext i ' generator polynom: x^10+x^8+x^5+x^4+x^2+x+1 = 10100110111b = 1335\nk = k Xor j Xor IIf(version < 1, 17477, 21522) ' XOR masking\nFor j = 0 To 14 ' layout format information\n    If version < 1 Then\n        mat(IIf(j < 8, 8, 15 - j), IIf(j < 8, j + 1, 8)) = k And 1 Xor 2 ' micro QR\n    Else\n        mat(IIf(j < 8, s - j - 1, IIf(j = 8, 7, 14 - j)), 8) = k And 1 Xor 2 ' QR horizontal\n        mat(8, IIf(j < 6, j, IIf(j < 8, j + 1, s + j - 15))) = k And 1 Xor 2 ' vertical\n    End If\n    k = k \\ 2\nNext j\nIf version > 6 Then ' add version information\n    k = version * 4096&\n    For i = 5 To 0 Step -1 ' BCH error correction: 6 data, 12 error bits\n        If k >= 4096 * 2 ^ i Then k = k Xor 7973 * 2 ^ i\n    Next i ' generator polynom: x^12+x^11+x^10+x^9+x^8+x^5+x^2+1 = 1111100100101b = 7973\n    k = k Xor (version * 4096&)\n    For j = 0 To 17 ' layout version information\n        mat(j \\ 3, s + j Mod 3 - 11) = k And 1 Xor 2\n        mat(s + j Mod 3 - 11, j \\ 3) = k And 1 Xor 2\n        k = k \\ 2\n    Next j\nEnd If\n    \nrpt.ScaleMode = 1 ' scale barcode to textbox\nX = IIf(Text.width < Text.height, 0, Text.height - Text.width) / 2 - Text.Left\nY = IIf(Text.width < Text.height, Text.width - Text.height, 0) / 2 - Text.Top\nr = IIf(Text.width < Text.height, Text.width, Text.height) / s\nrpt.Scale (X / r, Y / r)-((rpt.ScaleWidth + X) / r, (rpt.ScaleHeight + Y) / r)\n\nFor Y = 0 To s - 1 ' layout barcode\n    For X = 0 To s - 1\n        If getPattern(X, Y, m, version) Then ' apply mask\n            rpt.Line (X, Y)-Step(1, 1), Text.foreColor, BF\n        End If\n    Next X\nNext Y\n\nfailed:\nText.Visible = err.Number\nIf err.Number Then Debug.Print \"ERROR: \" & err.description\nEnd Sub\n\n' get QR pattern mask\nPrivate Function getPattern(ByVal X As Long, ByVal Y As Long, ByVal m As Integer, ByVal version As Integer) As Integer\nDim i As Integer, j As Long\nIf version < 1 Then m = Array(1, 4, 6, 7)(m) ' mask pattern of micro QR\ni = mat(X, Y)\nIf i < 2 Then\n    Select Case m\n    Case 0: j = (X + Y) And 1\n    Case 1: j = Y And 1\n    Case 2: j = X Mod 3\n    Case 3: j = (X + Y) Mod 3\n    Case 4: j = (X \\ 3 + Y \\ 2) And 1\n    Case 5: j = ((X * Y) And 1) + (X * Y) Mod 3\n    Case 6: j = (X * Y + (X * Y) Mod 3) And 1\n    Case 7: j = (X + Y + (X * Y) Mod 3) And 1\n    End Select\n    If j = 0 Then i = i Xor 1 ' invert only data according mask\nEnd If\ngetPattern = i And 1\nEnd Function\n\n\n"}
