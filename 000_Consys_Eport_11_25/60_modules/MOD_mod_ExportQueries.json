{"id":"MOD_mod_ExportQueries","name":"mod_ExportQueries","kind":"standard","procedures":["Public Sub ExportQueryDefsToJSON(ByVal exportPath As String)","Private Function GetQueryTypeName(queryType As Integer) As String","Private Function GetFieldTypeName(fieldType As Integer) As String","Private Function ExtractTablesFromSQL(sql As String) As String"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"'═══════════════════════════════════════════════════════════════════════════════\n' Modul:     mod_ExportQueries\n' Zweck:     Export aller Query-Definitionen zu JSON\n' Autor:     Access-Forensiker Agent\n' Datum:     2025-10-31\n' Version:   1.0\n'═══════════════════════════════════════════════════════════════════════════════\n\nOption Compare Database\nOption Explicit\n\n'═══════════════════════════════════════════════════════════════════════════════\n' HAUPT-EXPORT-FUNKTION\n'═══════════════════════════════════════════════════════════════════════════════\n\nPublic Sub ExportQueryDefsToJSON(ByVal exportPath As String)\n    On Error GoTo ErrorHandler\n    \n    Dim db As DAO.Database\n    Dim qdf As DAO.QueryDef\n    Dim fld As DAO.field\n    Dim prm As DAO.Parameter\n    Dim f As Integer\n    Dim filePath As String\n    Dim firstQuery As Boolean\n    Dim firstField As Boolean\n    Dim firstParam As Boolean\n    Dim queryCount As Integer\n    \n    Set db = CurrentDb()\n    filePath = exportPath & \"\\queries.json\"\n    f = FreeFile\n    \n    Open filePath For Output As #f\n    \n    ' JSON-Array starten\n    Print #f, \"[\"\n    \n    firstQuery = True\n    queryCount = 0\n    \n    ' Alle Queries durchgehen\n    For Each qdf In db.QueryDefs\n        ' System-Queries überspringen (beginnend mit ~)\n        If Left$(qdf.Name, 1) <> \"~\" Then\n            \n            ' Komma vor weiteren Einträgen\n            If Not firstQuery Then\n                Print #f, \",\"\n            End If\n            firstQuery = False\n            queryCount = queryCount + 1\n            \n            ' Query-Objekt öffnen\n            Print #f, \"  {\"\n            Print #f, \"    \"\"name\"\": \"\"\" & mod_ExportConsys.EscapeJSON(qdf.Name) & \"\"\",\"\n            Print #f, \"    \"\"type\"\": \" & qdf.Type & \",\"\n            Print #f, \"    \"\"typeName\"\": \"\"\" & GetQueryTypeName(qdf.Type) & \"\"\",\"\n            Print #f, \"    \"\"sql\"\": \"\"\" & mod_ExportConsys.EscapeJSON(qdf.sql) & \"\"\",\"\n            Print #f, \"    \"\"returnsRecords\"\": \" & LCase(qdf.ReturnsRecords) & \",\"\n            Print #f, \"    \"\"recordsAffected\"\": \" & qdf.RecordsAffected & \",\"\n            \n            ' Felder exportieren (wenn verfügbar)\n            Print #f, \"    \"\"fields\"\": [\"\n            On Error Resume Next ' Manche Queries haben keine Felder\n            firstField = True\n            For Each fld In qdf.fields\n                If err.Number = 0 Then\n                    If Not firstField Then\n                        Print #f, \",\"\n                    End If\n                    firstField = False\n                    \n                    Print #f, \"      {\"\n                    Print #f, \"        \"\"name\"\": \"\"\" & mod_ExportConsys.EscapeJSON(fld.Name) & \"\"\",\"\n                    Print #f, \"        \"\"type\"\": \" & fld.Type & \",\"\n                    Print #f, \"        \"\"typeName\"\": \"\"\" & GetFieldTypeName(fld.Type) & \"\"\",\"\n                    Print #f, \"        \"\"size\"\": \" & fld.Size\n                    Print #f, \"      }\"\n                End If\n            Next fld\n            On Error GoTo ErrorHandler\n            Print #f, \"    ],\"\n            \n            ' Parameter exportieren (für Parameter-Queries)\n            Print #f, \"    \"\"parameters\"\": [\"\n            firstParam = True\n            For Each prm In qdf.Parameters\n                If Not firstParam Then\n                    Print #f, \",\"\n                End If\n                firstParam = False\n                \n                Print #f, \"      {\"\n                Print #f, \"        \"\"name\"\": \"\"\" & mod_ExportConsys.EscapeJSON(prm.Name) & \"\"\",\"\n                Print #f, \"        \"\"type\"\": \" & prm.Type & \",\"\n                Print #f, \"        \"\"typeName\"\": \"\"\" & GetFieldTypeName(prm.Type) & \"\"\"\"\n                Print #f, \"      }\"\n            Next prm\n            Print #f, \"    ],\"\n            \n            ' SQL-Analyse: Tabellen und Felder erkennen\n            Print #f, \"    \"\"analysis\"\": {\"\n            Print #f, \"      \"\"tablesUsed\"\": \"\"\" & ExtractTablesFromSQL(qdf.sql) & \"\"\",\"\n            Print #f, \"      \"\"hasJoin\"\": \" & LCase(InStr(1, qdf.sql, \"JOIN\", vbTextCompare) > 0) & \",\"\n            Print #f, \"      \"\"hasWhere\"\": \" & LCase(InStr(1, qdf.sql, \"WHERE\", vbTextCompare) > 0) & \",\"\n            Print #f, \"      \"\"hasGroupBy\"\": \" & LCase(InStr(1, qdf.sql, \"GROUP BY\", vbTextCompare) > 0) & \",\"\n            Print #f, \"      \"\"hasOrderBy\"\": \" & LCase(InStr(1, qdf.sql, \"ORDER BY\", vbTextCompare) > 0) & \"\"\n            Print #f, \"    }\"\n            \n            Print #f, \"  }\"\n        End If\n    Next qdf\n    \n    ' JSON-Array schließen\n    Print #f, \"]\"\n    \n    Close #f\n    \n    Debug.Print \"      → \" & queryCount & \" Queries exportiert\"\n    \n    Exit Sub\n\nErrorHandler:\n    Close #f\n    Debug.Print \"      ✗ Fehler: \" & err.description\n    err.Raise err.Number, \"ExportQueryDefsToJSON\", err.description\nEnd Sub\n\n'═══════════════════════════════════════════════════════════════════════════════\n' HILFSFUNKTIONEN\n'═══════════════════════════════════════════════════════════════════════════════\n\n' Gibt den Query-Typ-Namen zurück\nPrivate Function GetQueryTypeName(queryType As Integer) As String\n    Select Case queryType\n        Case dbQSelect: GetQueryTypeName = \"Select\"\n        Case dbQAction: GetQueryTypeName = \"Action\"\n        Case dbQCrosstab: GetQueryTypeName = \"Crosstab\"\n        Case dbQDelete: GetQueryTypeName = \"Delete\"\n        Case dbQUpdate: GetQueryTypeName = \"Update\"\n        Case dbQAppend: GetQueryTypeName = \"Append\"\n        Case dbQMakeTable: GetQueryTypeName = \"MakeTable\"\n        Case dbQDDL: GetQueryTypeName = \"DDL\"\n        Case dbQSQLPassThrough: GetQueryTypeName = \"SQLPassThrough\"\n        Case dbQSetOperation: GetQueryTypeName = \"SetOperation\"\n        Case dbQSPTBulk: GetQueryTypeName = \"SPTBulk\"\n        Case Else: GetQueryTypeName = \"Unknown (\" & queryType & \")\"\n    End Select\nEnd Function\n\n' Gibt den Feld-Typ-Namen zurück\nPrivate Function GetFieldTypeName(fieldType As Integer) As String\n    Select Case fieldType\n        Case dbBoolean: GetFieldTypeName = \"Boolean\"\n        Case dbByte: GetFieldTypeName = \"Byte\"\n        Case dbInteger: GetFieldTypeName = \"Integer\"\n        Case dbLong: GetFieldTypeName = \"Long\"\n        Case dbCurrency: GetFieldTypeName = \"Currency\"\n        Case dbSingle: GetFieldTypeName = \"Single\"\n        Case dbDouble: GetFieldTypeName = \"Double\"\n        Case dbDate: GetFieldTypeName = \"Date/Time\"\n        Case dbText: GetFieldTypeName = \"Text\"\n        Case dbMemo: GetFieldTypeName = \"Memo\"\n        Case Else: GetFieldTypeName = \"Unknown (\" & fieldType & \")\"\n    End Select\nEnd Function\n\n' Extrahiert Tabellennamen aus SQL (einfache Version)\nPrivate Function ExtractTablesFromSQL(sql As String) As String\n    Dim tableList As String\n    Dim pos As Long\n    Dim fromPos As Long\n    Dim wherePos As Long\n    Dim tableSection As String\n    \n    ' SQL normalisieren\n    sql = UCase(sql)\n    \n    ' FROM-Position finden\n    fromPos = InStr(sql, \" FROM \")\n    If fromPos = 0 Then\n        ExtractTablesFromSQL = \"\"\n        Exit Function\n    End If\n    \n    ' WHERE-Position finden (oder Ende)\n    wherePos = InStr(fromPos, sql, \" WHERE \")\n    If wherePos = 0 Then wherePos = InStr(fromPos, sql, \" ORDER \")\n    If wherePos = 0 Then wherePos = InStr(fromPos, sql, \" GROUP \")\n    If wherePos = 0 Then wherePos = Len(sql)\n    \n    ' Tabellen-Bereich extrahieren\n    tableSection = Mid$(sql, fromPos + 6, wherePos - fromPos - 6)\n    \n    ' Vereinfachen (JOIN entfernen, etc.)\n    tableSection = Replace(tableSection, \" INNER JOIN \", \",\")\n    tableSection = Replace(tableSection, \" LEFT JOIN \", \",\")\n    tableSection = Replace(tableSection, \" RIGHT JOIN \", \",\")\n    tableSection = Replace(tableSection, \" ON \", \" \")\n    \n    ' Nur Tabellennamen extrahieren (sehr vereinfacht)\n    tableList = Trim(tableSection)\n    \n    ExtractTablesFromSQL = tableList\nEnd Function"}
