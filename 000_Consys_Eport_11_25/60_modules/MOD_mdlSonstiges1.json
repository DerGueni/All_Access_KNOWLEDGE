{"id":"MOD_mdlSonstiges1","name":"mdlSonstiges1","kind":"standard","procedures":["Function GetLinkedDBName(tableName As String)","Function GetShortPath(LongPath As String) As String","Public Function GetLongPathName(ShortPath As String) As String","Public Function GetLongFileName(ShortPath As String) As String","Function ZMittel(ParamArray p() As Variant)","Public Function Mittelwert_3(Kriterium As Integer) As Double","Function median(tabelle As String, var As String) As Variant","Sub Öffne_Bericht(f As Form, RName As String, DoPrint As Integer)","Function Long2Bin(ByVal n As Long) As String","Function Bin2Long(xstr As String) As Long","Public Function findemax(ParamArray p() As Variant)","Public Function SetSheetFeeder(RptName As String, nSheetFeeder As Integer)","Public Function B200STR(ByVal Zahl As Integer) As String","Public Function B200INT(ByVal Zahl As String) As Integer","Sub PrintAllProcs()","Function HideTbl(strTable As String, intHide As Integer) As Integer","Function TestFn()","Function TestFNTbl()","Function acg_CreateTable(strTable As String) As Integer","Function FeldFuellen(MaxFeldLen As Integer, Inhalt As String, _","Function RecordNumber(pstrPreFix As String, pFrm As Form) As String","Function MusicRule(ctl As control)","Function ExtractWords(ByVal strFrom As String, raWords() As String, strDelims _","Function TstWd()","Function fCreateAutoNumberField( _","Function fTableWithHyperlink(stTablename As String) As Boolean","Sub SavTxt(frmName As String, Dateiname As String, Optional ByVal AcArt As Long = acForm)","Sub LodTxt(frmName As String, Dateiname As String, Optional AcArt As Long = acForm)","Function NullTrim(ByVal XString As String, Optional AllNum As Integer = 3) As String","Function NullTrimTest()","Function BinImport(tabelle As String, PfadDatei As String, BinaryFeld As String, Optional Kurztext As String, Optional ID As Long = 0)","Function BinExport(tabelle As String, PfadDatei As String, BinaryFeld As String, IDNr As Long) As Boolean","Public Function KillABK(strDbName$, strSchalter$)"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\nOption Base 1\n\n' Funktionen (bzw.Subs) in diesem Modul:\n'   Sleep            - Warten\n'   GetLinkedDBName  - Wie heißt die MDB einer eingebundenen Tabelle\n'   GetShortPath     - Wie lautet der kurze Pfadnamen eines Langen Pfades\n'   GetLongPathName  - Wie lautet der lange Pfad eines kurzen Pfadnamens\n'   GetLongFileName  - Wie lautet der lange Dateiname (wird in GetLongPathName verwendet)\n'   ZMittel          - Mittelwert\n'   Mittelwert_3     - Mittelwert\n'   Median           - Berechnet den Median einer Tabelle\n'   Öffne_Bericht    - Wie öffne ich einen Bericht ?\n'   Long2Bin         - Ausgabe einer Zahl(long) als Binärstring (\"001001..\")\n'   Bin2Long         - Ausgabe eines Binärstrings als Zahl (Long)\n'   findemax         - Maximalwert eines Arrays\n'   SetSheetFeeder   - Sheedfeeter wechseln\n'   B200STR          - Zahl --> Basis 200 umrechnen\n'   B200INT          - Basis 200 --> Zahl umrechnen\n'   PrintAllProcs    - Alle Proceduren ausdrucken\n'   HideTbl          - Tabelle verstecken\n'   acg_CreateTable  - Tabelle per VBA erstellen\n'   FeldFuellen      - Feld (rechts- oder linksbündig) mit einem Wert versehen\n'   RecordNumber     - Record X von Y berechnen\n'   MusicRule        - jede 2. Zeile beim Druck grau hinterlegen\n'   ExtractWords     - Worte oder Parameter aus einem String extrahieren\n'   TstWd            - ExtractWords im Direktfenster testen\n'   fCreateAutoNumberField - Autowert Feld via VBA DAO Code erzeugen\n'   fTableWithHyperlink    - Hyperlinkfeld via VBA DAO Code erzeugen\n'   NullTrim         - Abschneiden aller anhängenden / führenden (leading/trailing) Nullen Hex(0)\n'   SavTxt           - Form als Textdatei speichern (leider nicht VB kompatibel)\n'   LodTxt           - Textdatei als Form zurücksichern (leider nicht VB kompatibel)\n'   BinImport        - Wie importiere ich eine Datei in ein OLE-Object eines Tabellenfeldes ?\n'   BinExport        - Wie exportiere ich ein OLE-Object eines Tabellenfeldes in eine Datei ?\n'   KillABK          - Hebt AllowByPass in anderer DB wieder auf oder schaltet wieder ein\n\n'**********************************************************************************\n' Deklarationen DiskFreeSpace\n'**********************************************************************************\nDeclare PtrSafe Function GetDiskFreeSpace Lib \"kernel32\" Alias \"GetDiskFreeSpaceA\" _\n    (ByVal lpRootPathName As String, lpSectorsPerCluster As Long, _\n    lpBytesPerSector As Long, lpNumberOfFreeClusters As Long, _\n    lpTotalNumberOfClusters As Long) As Long\n\n'**********************************************************************************\n' Deklarationen für kurzen  & langen Pfadnamen\n'**********************************************************************************\nDeclare PtrSafe Function GetShortPathName Lib \"kernel32\" Alias \"GetShortPathNameA\" (ByVal lpszLongPath As String, ByVal lpszShortPath As String, ByVal cchBuffer As Long) As Long\n\nPublic Const MAX_PATH = 260\nPublic Const INVALID_HANDLE_VALUE = -1\n\nType FILETIME\n    dwLowDateTime As Long\n    dwHighDateTime As Long\nEnd Type\n\nType WIN32_FIND_DATA\n    dwFileAttributes As Long\n    ftCreationTime As FILETIME\n    ftLastAccessTime As FILETIME\n    ftLastWriteTime As FILETIME\n    nFileSizeHigh As Long\n    nFileSizeLow As Long\n    dwReserved0 As Long\n    dwReserved1 As Long\n    cFileName As String * MAX_PATH\n    cAlternate As String * 14\nEnd Type\n  \nType str_DEVMODE\n    strGZF As String * 94\nEnd Type\n\nType type_DEVMODE\n    strDeviceName As String * 16\n    intSpecVersion As Integer\n    intDriverVersion As Integer\n    intSize As Integer\n    intDriverExtra As Integer\n    lngFields As Long\n    intOrientation As Integer\n    intPaperSize As Integer\n    intPaperLength As Integer\n    intPaperWidth As Integer\n    intScale As Integer\n    intCopies As Integer\n    intDefaultSource As Integer\n    intPrintQuality As Integer\n    intColor As Integer\n    intDuplex As Integer\n    intResolution As Integer\n    intTTOption As Integer\n    intCollate As Integer\n    strFormName As String * 16\n    lngPad As Long\n    lngBits As Long\n    lngPW As Long\n    lngPH As Long\n    lngDFI As Long\n    lngDFr As Long\nEnd Type\n\nDeclare PtrSafe Function FindFirstFile Lib \"kernel32\" Alias \"FindFirstFileA\" _\n    (ByVal lpFileName As String, lpFindFileData As WIN32_FIND_DATA) As Long\n  \n'**********************************************************************************\n' Sub Sleep (Funktion um zu warten)\n' Beispiel um 1 Sekunde zu warten:\n' Call Sleep 1000\n'**********************************************************************************\nPublic Declare PtrSafe Sub Sleep Lib \"kernel32\" (ByVal dwMilliseconds As Long)\n\n\n'**********************************************************************************\n' Rückgabe des Datenbanknamens incl. Pfad, der zu einer eingelinkten Tabelle gehört\n' The GetLinkedDBName() function requires the name of a\n' linked Microsoft Access table, in quotation marks, as an\n' argument. The function returns the full path of the originating\n' database if successful, or returns 0 if unsuccessful.\n'**********************************************************************************\nFunction GetLinkedDBName(tableName As String)\n         \n         Dim db As DAO.Database, ret\n         On Error GoTo DBNameErr\n         Set db = CurrentDb()\n         ret = db.TableDefs(tableName).connect\n         GetLinkedDBName = Right(ret, Len(ret) - (InStr(1, ret, \"DATABASE=\") + 8))\n      Exit Function\nDBNameErr:\n         GetLinkedDBName = \"\"\n\nEnd Function\n\nFunction GetShortPath(LongPath As String) As String\n'**********************************************************************************\n' Diese Funktion gibt den Kurzen Pfadnamen zurück\n'**********************************************************************************\n' Aus www.basicworld.com\n'Declare PtrSafe Function GetShortPathName Lib \"kernel32\" Alias \"GetShortPathNameA\" (ByVal lpszLongPath As String, ByVal lpszShortPath As String, ByVal cchBuffer As Long) As Long\n\nDim sBuffer As String, lLen As Long\nsBuffer = Space$(512)\nlLen = GetShortPathName(LongPath, sBuffer, Len(sBuffer))\nGetShortPath = Left$(sBuffer, lLen)\n\nEnd Function\n\n\nPublic Function GetLongPathName(ShortPath As String) As String\n'**********************************************************************************\n' Diese Funktion gibt den Langen Pfadnamen zurück\n' Diese Funktion verwendet GetLongFileName()\n'**********************************************************************************\n' Aus www.basicworld.com\n  Dim LongPath As String\n  Dim pos As Integer\n    ' Laufwerksangabe wg. Backslash einzeln behandeln\n    pos = InStr(ShortPath, \"\\\")\n    LongPath = Left$(ShortPath, pos)\n    pos = InStr(pos + 1, ShortPath, \"\\\")\n    ' erstes Verzeichnis suchen\n    While pos   ' Verzeichnisebenen umwandeln\n        LongPath = LongPath & GetLongFileName(Left$(ShortPath, pos - 1)) & \"\\\"\n        pos = InStr(pos + 1, ShortPath, \"\\\")\n    ' nächsten Backslash suchen\n    Wend\n    ' Den Dateinamen selbst hinzufügen, wenn kein Directory  'KOBD 1.8.2010\n    If Len(Trim(Nz(Dir(ShortPath, vbDirectory)))) > 0 Then\n        GetLongPathName = LongPath\n    Else\n        LongPath = LongPath & GetLongFileName(ShortPath)\n        ' Die Fehlerabfrage klauen wir ganz gemütlich aus der GetLongFileName-Funktion.\n        ' Auch GetLongPathName liefert bei Miserfolg einen Leerstring zurück:\n        If GetLongFileName(LongPath) <> vbNullString Then\n            GetLongPathName = LongPath\n        Else\n            GetLongPathName = vbNullString\n        End If\n    End If\nEnd Function\n\n  Public Function GetLongFileName(ShortPath As String) As String\n'**********************************************************************************\n' Diese Funktion gibt den Langen Dateinamen (ohne Pfad) zurück\n'**********************************************************************************\n' Aus www.basicworld.com\n  Dim DateiInfo As WIN32_FIND_DATA\n  Dim Retval As Long\n\n    Retval = FindFirstFile(ShortPath, DateiInfo)\n\n    If Retval <> INVALID_HANDLE_VALUE Then ' Abfrage, ob der Aufruf erfolgreich bearbeitet werden konnte\n        GetLongFileName = Left$(DateiInfo.cFileName, InStr(DateiInfo.cFileName, vbNullChar) - 1)\n    Else\n        GetLongFileName = vbNullString ' wenn erfolglos, dann leeren String zurückgeben\n    End If\n\n  End Function\n\n'--------------------------------------------------------\n'Mittelwertberechnung eines beliebigen Datenarrays\n'Günther Ritter\n'14.01.1998\n'--------------------------------------------------------\n'die Funktion liefert den Mittelwert x eines\n'beliebigen Arrays\nFunction ZMittel(ParamArray p() As Variant)\nDim i%, q%, zähl%\nIf UBound(p) >= 0 Then\n    i = UBound(p)\n    For q = 0 To i\n        If Not IsNull(p(q)) Then\n            zähl = zähl + 1\n            ZMittel = ZMittel + p(q)\n        End If\n    Next q\n    On Error GoTo endefunktion\n    ZMittel = ZMittel / zähl\nEnd If\n\nendefunktion:\n\nEnd Function\n\nPublic Function Mittelwert_3(Kriterium As Integer) As Double\nDim dbs As DAO.Database, qdf As QueryDef\n    Dim strSQL As String\n    'SQL Definition, um aus einer Tabelle die 3 groessten Datensaetze auszufiltern\n    strSQL = \"select top 3 * from Tabelle where Feld = \" & Kriterium & _\n    \"order by Mittelwert_Feld desc;\"\n    \n    ' Verweis auf aktuelle Datenbank holen.\n    Set dbs = CurrentDb\n    ' Neues QueryDef-Objekt erstellen.\n    Set qdf = dbs.CreateQueryDef(\"Top3\", strSQL)\n    Mittelwert_3 = DAvg(\"Spielzeit\", \"Top3\")\n    ' QueryDef-Objekt wieder loeschen.\n    DoCmd.DeleteObject acQuery, \"Top3\"\n    Set dbs = Nothing\n\nEnd Function\n\n\nFunction median(tabelle As String, var As String) As Variant\n\n'Berechnet den Median einer Tabelle\n'Autor: Johanna Kirsch\n\nDim i As Integer\nDim Anz As Long\nDim pos As Long\nDim mitte As Integer\nDim val1 As field\nDim val2 As field\nDim MyDB As DAO.Database\nDim mytab As DAO.Recordset\nSet MyDB = CurrentDb()\nSet mytab = MyDB.OpenRecordset(\"SELECT * FROM \" & tabelle & \" ORDER BY \" & var)\n\nmytab.MoveLast\nAnz = mytab.RecordCount\nIf (Anz Mod 2) > 0 Then\n  pos = (Anz - 1) / 2\n  mitte = 1\nElse\n  pos = (Anz / 2) - 1\n  mitte = 0\nEnd If\n\nFor i = 1 To pos\n  mytab.MovePrevious\nNext\nIf mitte = 1 Then\n  median = mytab.fields(var)\nElse\n  Set val1 = mytab.fields(var)\n  mytab.MovePrevious\n  Set val2 = mytab.fields(var)\n  median = (val1 + val2) / 2\nEnd If\nmytab.Close\n\nEnd Function\n\n\n\n'##------------------------------------------------------------\n'## Öffne_Bericht\n'##\n'## Öffnet einen Bericht von einem Dialogfenster aus, entweder als Druck\n'## oder als Vorschau und macht, solange der Bericht offen ist, das\n'## aufrufende Formular unsichtbar.\n'##\n'## Parameter:\n'## - F       : Das aufrufende Formular\n'## - RName   : Der gewünschte Bericht\n'## - DoPrint : True -> Drucken, False -> Vorschau\n'##\n'##------------------------------------------------------------\nSub Öffne_Bericht(f As Form, RName As String, DoPrint As Integer)\n\nOn Error GoTo Öffne_Bericht_Err\n\n    Dim Ansicht As Integer\n\n    '## Ausdruck (NORMAL) oder Vorschau?\n    Ansicht = IIf(DoPrint, A_NORMAL, A_PREVIEW)\n\n    '## Vorschau -> Dialogformular ausblenden\n    If Ansicht = A_PREVIEW Then\n        f.Visible = False\n    End If\n    \n    '## Bericht öffnen\n    DoCmd.OpenReport RName, Ansicht\n\n    '## Vorschau -> solange ausgeblendet bleiben, bis Bericht wieder geschlossen\n    If Ansicht = A_PREVIEW Then\n        Do While IsReportLoad(RName)\n            DoEvents\n        Loop\n        f.Visible = True\n    End If\n    \nÖffne_Bericht_Exit:\n    On Error Resume Next\n    Exit Sub\n\nÖffne_Bericht_Err:\n    Select Case MsgBox(Error, 50, \"Runtime-Error \" & err & \" in Öffne_Bericht\")\n        Case 3: Resume Öffne_Bericht_Exit\n        Case 4: Resume 0\n        Case 5: Resume Next\n    End Select\n\nEnd Sub\n\nFunction Long2Bin(ByVal n As Long) As String\n'**********************************************************************************\n'Umwandlung einer Longinteger Zahl in einen Binärstring\n'**********************************************************************************\n' Wertebereichdarstellung von bis\n'  2147483647 = 01111111111111111111111111111111\n'        1000 = 00000000000000000000001111101000\n'           1 = 00000000000000000000000000000001\n'           0 = 00000000000000000000000000000000\n'          -1 = 11111111111111111111111111111111\n'       -1000 = 11111111111111111111110000011000\n' -2147483648 = 10000000000000000000000000000000\n'\n'**********************************************************************************\nDim i As Integer\nDim E As String\n    E = \"0\"\n    If n < 0 Then\n        E = \"1\"\n        n = n And &H7FFFFFFF\n    End If\n    For i = 30 To 0 Step -1\n        If (n And (2& ^ i)) <> 0 Then\n            E = E + \"1\"\n        Else\n            E = E + \"0\"\n        End If\n    Next i\n    Long2Bin = E\nEnd Function\n\n\nFunction Bin2Long(xstr As String) As Long\n'**********************************************************************************\n' Umwandlung eines Binärstrings in eine Longinteger Zahl\n'**********************************************************************************\n' String sollte wie folgt aussehen: 100010111011. Die Umrechnung erfolgt analog zu\n' Long2BinString. Jedes Zeichen ungleich \"0\" wird als \"1\" interpretiert.\n' Der String wird immer auf 32 Stellen getrimmt, d.h. führende Nullen können entfallen.\n' Die rechten 31 Stellen werden positiv umgerechnet. Wenn das erste Zeichen <> \"0\"\n' ist, wird  der Wert als \"kleiner Null\" interpretiert, d.h. vom errechneten\n' Ergebnis wird dez. 2147483648 (= 2^31) subtrahiert.\n'\n' Wertebereichdarstellung von bis\n'  2147483647 = 01111111111111111111111111111111 ( = 2^31 - 1)\n'        1000 = 00000000000000000000001111101000\n'           1 = 00000000000000000000000000000001\n'           0 = 00000000000000000000000000000000\n'          -1 = 11111111111111111111111111111111\n'       -1000 = 11111111111111111111110000011000\n' -2147483648 = 10000000000000000000000000000000 (= 2^31)\n'\n'**********************************************************************************\n\nDim i As Integer\nDim j As Integer\nDim ZwSum As Long\nDim Neg As Boolean\nDim ZwString As String\nConst NEGWERT = 2147483648#\nConst VGLNULL = \"0\"\n\nj = 0\nZwSum = 0\nNeg = False\n\n' ZwString rechtsbündig auf 32 Zeichen trimmen\nZwString = Right(\"00000000000000000000000000000000\" & xstr, 32)\n\n'Prüfung der ersten Stelle auf Negativ\nIf Left(ZwString, 1) <> VGLNULL Then\n    Neg = True\nEnd If\n\n'Erste Stelle löschen\nZwString = Right(ZwString, 31)\n\n' Die Stellen von rechts nach links umrechnen\nFor i = 31 To 1 Step -1\n    If Mid(ZwString, i, 1) <> VGLNULL Then\n       ZwSum = ZwSum + (2 ^ j)\n    End If\n    j = j + 1\nNext i\n\n' Ergebnis auf Negativ prüfen\nIf Neg Then\n    ZwSum = ZwSum - NEGWERT\nEnd If\n\nBin2Long = ZwSum\n\nEnd Function\n\nPublic Function findemax(ParamArray p() As Variant)\nDim i As Integer, q As Integer\nIf UBound(p) >= 0 Then 'wurden parameter übergeben?\n    Debug.Print UBound(p)\n    i = UBound(p) 'Anzahl der werte\n    findemax = p(i) 'erster wert\n    For q = 0 To i 'alle durchgehen\n        If p(q) > findemax Then\n            findemax = p(q) 'finde den maximalwert ....\n        End If\n    Next q\nEnd If\nEnd Function\n\n\nPublic Function SetSheetFeeder(RptName As String, nSheetFeeder As Integer)\n'**********************************************************************************\n'Papierschacht zuweisen\n'**********************************************************************************\n'vielleicht hat jemand von Euch eine Idee, wie ich via ein Modul einem\n'Bericht einen bestimmten Drucker und einen bestimmten Papierschacht zuweisen kann.\n'Ich brauche dies, weil ich die Kopie des Berichtes auf Recycling-Papier\n'ausdrucken muss.\n'\n'Also, meinereiner nutzt diese Function dazu, leider funktioniert dies\n'nicht bei *.mde Dateien, was ich sehr ärgerlich finde.\n'**********************************************************************************\n    Dim GeräteZF As str_DEVMODE\n    Dim DM As type_DEVMODE\n    Dim strGerätemodus As String\n    Dim rpt As Report\n    DoCmd.OpenReport RptName, acDesign\n    Set rpt = Reports(RptName)\n    If Not IsNull(rpt.PrtDevMode) Then\n        strGerätemodus = rpt.PrtDevMode   ' Die Struktur DEVMODE lesen.\n        GeräteZF.strGZF = strGerätemodus\n        LSet DM = GeräteZF\n        DM.intDefaultSource = nSheetFeeder\n        LSet GeräteZF = DM          ' Die Eigenschaft aktualisieren.\n        Mid(strGerätemodus, 1, 94) = GeräteZF.strGZF\n        rpt.PrtDevMode = strGerätemodus\n    Else\n        MsgBox \"Keine Printer Dev Mode\"\n    End If\n    DoCmd.Close acReport, RptName, acSaveYes\n    \nEnd Function\n\nPublic Function B200STR(ByVal Zahl As Integer) As String\n'Funktionen welche mit der Basis 200 rechnen\n' Integer --> String\n   B200STR = Chr(Zahl \\ 200 + 48) + Chr(Zahl Mod 200 + 48)\nEnd Function\n\nPublic Function B200INT(ByVal Zahl As String) As Integer\n'Funktionen welche mit der Basis 200 rechnen\n' String --> Integer\n   Dim ix As Long\n   Zahl = Right(\"00\" + Zahl, 2)\n   ix = 200! * (Asc(Mid(Zahl, 1)) - 48) + Asc(Mid(Zahl, 2)) - 48\n   If ix <= 32767! Then\n        B200INT = ix\n   Else\n        B200INT = 0\n   End If\nEnd Function\n\nSub PrintAllProcs()\n' Anzeigen der Module im Testfenster\n    Dim mdl As Module\n    Dim lngCount As Long, lngCountDecl As Long, lngI As Long\n    Dim strProcName As String, astrProcNames() As String\n    Dim intI As Integer, strMsg As String\n    Dim lngR As Long\n    Dim dbs As DAO.Database, ctr As Container, doc As Document, strModuleName\n\n    Set dbs = CurrentDb\n    Set ctr = dbs.Containers!Modules\n\n    For Each doc In ctr.Documents\n        strModuleName = doc.Name\n         ' Open specified Module object.\n        DoCmd.OpenModule strModuleName\n         ' Return reference to Module object.\n        Set mdl = Modules(strModuleName)\n         ' Count lines in module.\n        lngCount = mdl.CountOfLines\n         ' Count lines in Declaration section in module.\n\n        lngCountDecl = mdl.CountOfDeclarationLines\n         ' Determine name of first procedure.\n        strProcName = mdl.ProcOfLine(lngCountDecl + 1, lngR)\n         ' Initialize counter variable.\n        intI = 0\n         ' Redimension array.\n        ReDim Preserve astrProcNames(intI)\n         ' Store name of first procedure in array.\n        astrProcNames(intI) = strProcName\n         ' Determine procedure name for each line after declarations.\n        For lngI = lngCountDecl + 1 To lngCount\n         ' Compare procedure name with ProcOfLine property value.\n\n            If strProcName < mdl.ProcOfLine(lngI, lngR) Then\n             ' Increment counter.\n                intI = intI + 1\n                strProcName = mdl.ProcOfLine(lngI, lngR)\n                ReDim Preserve astrProcNames(intI)\n                 ' Assign unique procedure names to array.\n                astrProcNames(intI) = strProcName\n            End If\n        Next lngI\n        Debug.Print \"Procedures in module '\" & strModuleName & \"': \"\n        For intI = 0 To UBound(astrProcNames)\n            Debug.Print astrProcNames(intI)\n        Next intI\n         'the line below will close this module if open\n        DoCmd.Close\n    Next doc\n    Set dbs = Nothing\nEnd Sub\n\n\n\n\nFunction HideTbl(strTable As String, intHide As Integer) As Integer\n'*********************************\n'Purpose:   Hides or Shows Tables\n'Accepts:   intHide: True (-1) to hide table, false (0) to unhide\n'Returns:   True on Success, False on Failure\n'********************************\n\n' You may desire to have certain of your tables, such as set up information,\n' hidden in normal use. Here's a couple of ways to do it.\n' The non-code way is to prefix your table name with \"USys_\", this will make\n' the table visible only if the user has \"Show System Objects\" set to true.\n'\n' The other way to hide a table is to set its attribute property to hidden.\n' Unlike many other attributes, this one is read/write so it can be changed at\n' any time. In addition in Access 95 and 97 if you hide your tables using this\n' method, the user can't see it, even if they set the \"Show Hidden Objects\"\n' option to true! Here's the code to do it:\n\n' Problem is, that hidden tables are DELETED, while creating an MDE\n\n' *******************************\nOn Error GoTo HT_ERR\n\nDim tDef As TableDef\nDim CurDB As DAO.Database\n\nSet CurDB = CurrentDb()\nSet tDef = CurDB.TableDefs(strTable)\n\nSelect Case intHide\n    Case True\n        If Not (tDef.attributes And DB_HIDDENOBJECT) Then\n            tDef.attributes = tDef.attributes + DB_HIDDENOBJECT\n        End If\n    Case Else\n        If (tDef.attributes And DB_HIDDENOBJECT) Then\n            tDef.attributes = tDef.attributes - DB_HIDDENOBJECT\n        End If\nEnd Select\n\nHideTbl = True\n\nEXIT_HT:\n    Exit Function\nHT_ERR:\n    HideTbl = False\n    MsgBox \"Error: \" & err & \" \" & Error, 48\n    Resume EXIT_HT\n    \nEnd Function\n\nFunction TestFn()\n\nDim i As Long\nDim st1 As String\nDim st2 As String\n\nFor i = 0 To 90\n    st1 = \"Set fld(\" & i & \") = Newtbl.CreateField(\" & Chr$(34) & \"MyStringField\" & i & Chr$(34) & \", DB_TEXT, 75)\"\n    st2 = \"Newtbl.Fields.Append fld(\" & i & \")\"\n    Debug.Print st1\n    Debug.Print st2\nNext i\n\nEnd Function\n\n\nFunction TestFNTbl()\n\nOn Error GoTo ErrCT\n\nDim TDB As DAO.Database\nDim Newtbl As TableDef\nDim fld(260) As field\n\nSet TDB = CurrentDb()\nSet Newtbl = TDB.CreateTableDef(\"Testtabelle1\")\n\nSet fld(0) = Newtbl.CreateField(\"MyStringField0\", DB_TEXT, 75)\nNewtbl.fields.append fld(0)\nSet fld(1) = Newtbl.CreateField(\"MyStringField1\", DB_TEXT, 75)\nNewtbl.fields.append fld(1)\nSet fld(2) = Newtbl.CreateField(\"MyStringField2\", DB_TEXT, 75)\nNewtbl.fields.append fld(2)\nSet fld(3) = Newtbl.CreateField(\"MyStringField3\", DB_TEXT, 75)\nNewtbl.fields.append fld(3)\nSet fld(4) = Newtbl.CreateField(\"MyStringField4\", DB_TEXT, 75)\nNewtbl.fields.append fld(4)\nSet fld(5) = Newtbl.CreateField(\"MyStringField5\", DB_TEXT, 75)\nNewtbl.fields.append fld(5)\nSet fld(6) = Newtbl.CreateField(\"MyStringField6\", DB_TEXT, 75)\nNewtbl.fields.append fld(6)\nSet fld(7) = Newtbl.CreateField(\"MyStringField7\", DB_TEXT, 75)\nNewtbl.fields.append fld(7)\nSet fld(8) = Newtbl.CreateField(\"MyStringField8\", DB_TEXT, 75)\nNewtbl.fields.append fld(8)\nSet fld(9) = Newtbl.CreateField(\"MyStringField9\", DB_TEXT, 75)\nNewtbl.fields.append fld(9)\nSet fld(10) = Newtbl.CreateField(\"MyStringField10\", DB_TEXT, 75)\nNewtbl.fields.append fld(10)\nSet fld(11) = Newtbl.CreateField(\"MyStringField11\", DB_TEXT, 75)\nNewtbl.fields.append fld(11)\nSet fld(12) = Newtbl.CreateField(\"MyStringField12\", DB_TEXT, 75)\nNewtbl.fields.append fld(12)\nSet fld(13) = Newtbl.CreateField(\"MyStringField13\", DB_TEXT, 75)\nNewtbl.fields.append fld(13)\nSet fld(14) = Newtbl.CreateField(\"MyStringField14\", DB_TEXT, 75)\nNewtbl.fields.append fld(14)\nSet fld(15) = Newtbl.CreateField(\"MyStringField15\", DB_TEXT, 75)\nNewtbl.fields.append fld(15)\nSet fld(16) = Newtbl.CreateField(\"MyStringField16\", DB_TEXT, 75)\nNewtbl.fields.append fld(16)\nSet fld(17) = Newtbl.CreateField(\"MyStringField17\", DB_TEXT, 75)\nNewtbl.fields.append fld(17)\nSet fld(18) = Newtbl.CreateField(\"MyStringField18\", DB_TEXT, 75)\nNewtbl.fields.append fld(18)\nSet fld(19) = Newtbl.CreateField(\"MyStringField19\", DB_TEXT, 75)\nNewtbl.fields.append fld(19)\nSet fld(20) = Newtbl.CreateField(\"MyStringField20\", DB_TEXT, 75)\nNewtbl.fields.append fld(20)\nSet fld(21) = Newtbl.CreateField(\"MyStringField21\", DB_TEXT, 75)\nNewtbl.fields.append fld(21)\nSet fld(22) = Newtbl.CreateField(\"MyStringField22\", DB_TEXT, 75)\nNewtbl.fields.append fld(22)\nSet fld(23) = Newtbl.CreateField(\"MyStringField23\", DB_TEXT, 75)\nNewtbl.fields.append fld(23)\nSet fld(24) = Newtbl.CreateField(\"MyStringField24\", DB_TEXT, 75)\nNewtbl.fields.append fld(24)\nSet fld(25) = Newtbl.CreateField(\"MyStringField25\", DB_TEXT, 75)\nNewtbl.fields.append fld(25)\nSet fld(26) = Newtbl.CreateField(\"MyStringField26\", DB_TEXT, 75)\nNewtbl.fields.append fld(26)\nSet fld(27) = Newtbl.CreateField(\"MyStringField27\", DB_TEXT, 75)\nNewtbl.fields.append fld(27)\nSet fld(28) = Newtbl.CreateField(\"MyStringField28\", DB_TEXT, 75)\nNewtbl.fields.append fld(28)\nSet fld(29) = Newtbl.CreateField(\"MyStringField29\", DB_TEXT, 75)\nNewtbl.fields.append fld(29)\nSet fld(30) = Newtbl.CreateField(\"MyStringField30\", DB_TEXT, 75)\nNewtbl.fields.append fld(30)\nSet fld(31) = Newtbl.CreateField(\"MyStringField31\", DB_TEXT, 75)\nNewtbl.fields.append fld(31)\nSet fld(32) = Newtbl.CreateField(\"MyStringField32\", DB_TEXT, 75)\nNewtbl.fields.append fld(32)\nSet fld(33) = Newtbl.CreateField(\"MyStringField33\", DB_TEXT, 75)\nNewtbl.fields.append fld(33)\nSet fld(34) = Newtbl.CreateField(\"MyStringField34\", DB_TEXT, 75)\nNewtbl.fields.append fld(34)\nSet fld(35) = Newtbl.CreateField(\"MyStringField35\", DB_TEXT, 75)\nNewtbl.fields.append fld(35)\nSet fld(36) = Newtbl.CreateField(\"MyStringField36\", DB_TEXT, 75)\nNewtbl.fields.append fld(36)\nSet fld(37) = Newtbl.CreateField(\"MyStringField37\", DB_TEXT, 75)\nNewtbl.fields.append fld(37)\nSet fld(38) = Newtbl.CreateField(\"MyStringField38\", DB_TEXT, 75)\nNewtbl.fields.append fld(38)\nSet fld(39) = Newtbl.CreateField(\"MyStringField39\", DB_TEXT, 75)\nNewtbl.fields.append fld(39)\nSet fld(40) = Newtbl.CreateField(\"MyStringField40\", DB_TEXT, 75)\nNewtbl.fields.append fld(40)\nSet fld(41) = Newtbl.CreateField(\"MyStringField41\", DB_TEXT, 75)\nNewtbl.fields.append fld(41)\nSet fld(42) = Newtbl.CreateField(\"MyStringField42\", DB_TEXT, 75)\nNewtbl.fields.append fld(42)\nSet fld(43) = Newtbl.CreateField(\"MyStringField43\", DB_TEXT, 75)\nNewtbl.fields.append fld(43)\nSet fld(44) = Newtbl.CreateField(\"MyStringField44\", DB_TEXT, 75)\nNewtbl.fields.append fld(44)\nSet fld(45) = Newtbl.CreateField(\"MyStringField45\", DB_TEXT, 75)\nNewtbl.fields.append fld(45)\nSet fld(46) = Newtbl.CreateField(\"MyStringField46\", DB_TEXT, 75)\nNewtbl.fields.append fld(46)\nSet fld(47) = Newtbl.CreateField(\"MyStringField47\", DB_TEXT, 75)\nNewtbl.fields.append fld(47)\nSet fld(48) = Newtbl.CreateField(\"MyStringField48\", DB_TEXT, 75)\nNewtbl.fields.append fld(48)\nSet fld(49) = Newtbl.CreateField(\"MyStringField49\", DB_TEXT, 75)\nNewtbl.fields.append fld(49)\nSet fld(50) = Newtbl.CreateField(\"MyStringField50\", DB_TEXT, 75)\nNewtbl.fields.append fld(50)\nSet fld(51) = Newtbl.CreateField(\"MyStringField51\", DB_TEXT, 75)\nNewtbl.fields.append fld(51)\nSet fld(52) = Newtbl.CreateField(\"MyStringField52\", DB_TEXT, 75)\nNewtbl.fields.append fld(52)\nSet fld(53) = Newtbl.CreateField(\"MyStringField53\", DB_TEXT, 75)\nNewtbl.fields.append fld(53)\nSet fld(54) = Newtbl.CreateField(\"MyStringField54\", DB_TEXT, 75)\nNewtbl.fields.append fld(54)\nSet fld(55) = Newtbl.CreateField(\"MyStringField55\", DB_TEXT, 75)\nNewtbl.fields.append fld(55)\nSet fld(56) = Newtbl.CreateField(\"MyStringField56\", DB_TEXT, 75)\nNewtbl.fields.append fld(56)\nSet fld(57) = Newtbl.CreateField(\"MyStringField57\", DB_TEXT, 75)\nNewtbl.fields.append fld(57)\nSet fld(58) = Newtbl.CreateField(\"MyStringField58\", DB_TEXT, 75)\nNewtbl.fields.append fld(58)\nSet fld(59) = Newtbl.CreateField(\"MyStringField59\", DB_TEXT, 75)\nNewtbl.fields.append fld(59)\nSet fld(60) = Newtbl.CreateField(\"MyStringField60\", DB_TEXT, 75)\nNewtbl.fields.append fld(60)\nSet fld(61) = Newtbl.CreateField(\"MyStringField61\", DB_TEXT, 75)\nNewtbl.fields.append fld(61)\nSet fld(62) = Newtbl.CreateField(\"MyStringField62\", DB_TEXT, 75)\nNewtbl.fields.append fld(62)\nSet fld(63) = Newtbl.CreateField(\"MyStringField63\", DB_TEXT, 75)\nNewtbl.fields.append fld(63)\nSet fld(64) = Newtbl.CreateField(\"MyStringField64\", DB_TEXT, 75)\nNewtbl.fields.append fld(64)\nSet fld(65) = Newtbl.CreateField(\"MyStringField65\", DB_TEXT, 75)\nNewtbl.fields.append fld(65)\nSet fld(66) = Newtbl.CreateField(\"MyStringField66\", DB_TEXT, 75)\nNewtbl.fields.append fld(66)\nSet fld(67) = Newtbl.CreateField(\"MyStringField67\", DB_TEXT, 75)\nNewtbl.fields.append fld(67)\nSet fld(68) = Newtbl.CreateField(\"MyStringField68\", DB_TEXT, 75)\nNewtbl.fields.append fld(68)\nSet fld(69) = Newtbl.CreateField(\"MyStringField69\", DB_TEXT, 75)\nNewtbl.fields.append fld(69)\nSet fld(70) = Newtbl.CreateField(\"MyStringField70\", DB_TEXT, 75)\nNewtbl.fields.append fld(70)\nSet fld(71) = Newtbl.CreateField(\"MyStringField71\", DB_TEXT, 75)\nNewtbl.fields.append fld(71)\nSet fld(72) = Newtbl.CreateField(\"MyStringField72\", DB_TEXT, 75)\nNewtbl.fields.append fld(72)\nSet fld(73) = Newtbl.CreateField(\"MyStringField73\", DB_TEXT, 75)\nNewtbl.fields.append fld(73)\nSet fld(74) = Newtbl.CreateField(\"MyStringField74\", DB_TEXT, 75)\nNewtbl.fields.append fld(74)\nSet fld(75) = Newtbl.CreateField(\"MyStringField75\", DB_TEXT, 75)\nNewtbl.fields.append fld(75)\nSet fld(76) = Newtbl.CreateField(\"MyStringField76\", DB_TEXT, 75)\nNewtbl.fields.append fld(76)\nSet fld(77) = Newtbl.CreateField(\"MyStringField77\", DB_TEXT, 75)\nNewtbl.fields.append fld(77)\nSet fld(78) = Newtbl.CreateField(\"MyStringField78\", DB_TEXT, 75)\nNewtbl.fields.append fld(78)\nSet fld(79) = Newtbl.CreateField(\"MyStringField79\", DB_TEXT, 75)\nNewtbl.fields.append fld(79)\nSet fld(80) = Newtbl.CreateField(\"MyStringField80\", DB_TEXT, 75)\nNewtbl.fields.append fld(80)\nSet fld(81) = Newtbl.CreateField(\"MyStringField81\", DB_TEXT, 75)\nNewtbl.fields.append fld(81)\nSet fld(82) = Newtbl.CreateField(\"MyStringField82\", DB_TEXT, 75)\nNewtbl.fields.append fld(82)\nSet fld(83) = Newtbl.CreateField(\"MyStringField83\", DB_TEXT, 75)\nNewtbl.fields.append fld(83)\nSet fld(84) = Newtbl.CreateField(\"MyStringField84\", DB_TEXT, 75)\nNewtbl.fields.append fld(84)\nSet fld(85) = Newtbl.CreateField(\"MyStringField85\", DB_TEXT, 75)\nNewtbl.fields.append fld(85)\nSet fld(86) = Newtbl.CreateField(\"MyStringField86\", DB_TEXT, 75)\nNewtbl.fields.append fld(86)\nSet fld(87) = Newtbl.CreateField(\"MyStringField87\", DB_TEXT, 75)\nNewtbl.fields.append fld(87)\nSet fld(88) = Newtbl.CreateField(\"MyStringField88\", DB_TEXT, 75)\nNewtbl.fields.append fld(88)\nSet fld(89) = Newtbl.CreateField(\"MyStringField89\", DB_TEXT, 75)\nNewtbl.fields.append fld(89)\nSet fld(90) = Newtbl.CreateField(\"MyStringField90\", DB_TEXT, 75)\nNewtbl.fields.append fld(90)\nSet fld(91) = Newtbl.CreateField(\"MyStringField91\", DB_TEXT, 75)\nNewtbl.fields.append fld(91)\nSet fld(92) = Newtbl.CreateField(\"MyStringField92\", DB_TEXT, 75)\nNewtbl.fields.append fld(92)\nSet fld(93) = Newtbl.CreateField(\"MyStringField93\", DB_TEXT, 75)\nNewtbl.fields.append fld(93)\nSet fld(94) = Newtbl.CreateField(\"MyStringField94\", DB_TEXT, 75)\nNewtbl.fields.append fld(94)\nSet fld(95) = Newtbl.CreateField(\"MyStringField95\", DB_TEXT, 75)\nNewtbl.fields.append fld(95)\nSet fld(96) = Newtbl.CreateField(\"MyStringField96\", DB_TEXT, 75)\nNewtbl.fields.append fld(96)\nSet fld(97) = Newtbl.CreateField(\"MyStringField97\", DB_TEXT, 75)\nNewtbl.fields.append fld(97)\nSet fld(98) = Newtbl.CreateField(\"MyStringField98\", DB_TEXT, 75)\nNewtbl.fields.append fld(98)\nSet fld(99) = Newtbl.CreateField(\"MyStringField99\", DB_TEXT, 75)\nNewtbl.fields.append fld(99)\nSet fld(100) = Newtbl.CreateField(\"MyStringField100\", DB_TEXT, 75)\nNewtbl.fields.append fld(100)\nSet fld(101) = Newtbl.CreateField(\"MyStringField101\", DB_TEXT, 75)\nNewtbl.fields.append fld(101)\nSet fld(102) = Newtbl.CreateField(\"MyStringField102\", DB_TEXT, 75)\nNewtbl.fields.append fld(102)\nSet fld(103) = Newtbl.CreateField(\"MyStringField103\", DB_TEXT, 75)\nNewtbl.fields.append fld(103)\nSet fld(104) = Newtbl.CreateField(\"MyStringField104\", DB_TEXT, 75)\nNewtbl.fields.append fld(104)\nSet fld(105) = Newtbl.CreateField(\"MyStringField105\", DB_TEXT, 75)\nNewtbl.fields.append fld(105)\nSet fld(106) = Newtbl.CreateField(\"MyStringField106\", DB_TEXT, 75)\nNewtbl.fields.append fld(106)\nSet fld(107) = Newtbl.CreateField(\"MyStringField107\", DB_TEXT, 75)\nNewtbl.fields.append fld(107)\nSet fld(108) = Newtbl.CreateField(\"MyStringField108\", DB_TEXT, 75)\nNewtbl.fields.append fld(108)\nSet fld(109) = Newtbl.CreateField(\"MyStringField109\", DB_TEXT, 75)\nNewtbl.fields.append fld(109)\nSet fld(110) = Newtbl.CreateField(\"MyStringField110\", DB_TEXT, 75)\nNewtbl.fields.append fld(110)\nSet fld(111) = Newtbl.CreateField(\"MyStringField111\", DB_TEXT, 75)\nNewtbl.fields.append fld(111)\nSet fld(112) = Newtbl.CreateField(\"MyStringField112\", DB_TEXT, 75)\nNewtbl.fields.append fld(112)\nSet fld(113) = Newtbl.CreateField(\"MyStringField113\", DB_TEXT, 75)\nNewtbl.fields.append fld(113)\nSet fld(114) = Newtbl.CreateField(\"MyStringField114\", DB_TEXT, 75)\nNewtbl.fields.append fld(114)\nSet fld(115) = Newtbl.CreateField(\"MyStringField115\", DB_TEXT, 75)\nNewtbl.fields.append fld(115)\nSet fld(116) = Newtbl.CreateField(\"MyStringField116\", DB_TEXT, 75)\nNewtbl.fields.append fld(116)\nSet fld(117) = Newtbl.CreateField(\"MyStringField117\", DB_TEXT, 75)\nNewtbl.fields.append fld(117)\nSet fld(118) = Newtbl.CreateField(\"MyStringField118\", DB_TEXT, 75)\nNewtbl.fields.append fld(118)\nSet fld(119) = Newtbl.CreateField(\"MyStringField119\", DB_TEXT, 75)\nNewtbl.fields.append fld(119)\nSet fld(120) = Newtbl.CreateField(\"MyStringField120\", DB_TEXT, 75)\nNewtbl.fields.append fld(120)\nSet fld(121) = Newtbl.CreateField(\"MyStringField121\", DB_TEXT, 75)\nNewtbl.fields.append fld(121)\nSet fld(122) = Newtbl.CreateField(\"MyStringField122\", DB_TEXT, 75)\nNewtbl.fields.append fld(122)\nSet fld(123) = Newtbl.CreateField(\"MyStringField123\", DB_TEXT, 75)\nNewtbl.fields.append fld(123)\nSet fld(124) = Newtbl.CreateField(\"MyStringField124\", DB_TEXT, 75)\nNewtbl.fields.append fld(124)\nSet fld(125) = Newtbl.CreateField(\"MyStringField125\", DB_TEXT, 75)\nNewtbl.fields.append fld(125)\nSet fld(126) = Newtbl.CreateField(\"MyStringField126\", DB_TEXT, 75)\nNewtbl.fields.append fld(126)\nSet fld(127) = Newtbl.CreateField(\"MyStringField127\", DB_TEXT, 75)\nNewtbl.fields.append fld(127)\nSet fld(128) = Newtbl.CreateField(\"MyStringField128\", DB_TEXT, 75)\nNewtbl.fields.append fld(128)\nSet fld(129) = Newtbl.CreateField(\"MyStringField129\", DB_TEXT, 75)\nNewtbl.fields.append fld(129)\nSet fld(130) = Newtbl.CreateField(\"MyStringField130\", DB_TEXT, 75)\nNewtbl.fields.append fld(130)\nSet fld(131) = Newtbl.CreateField(\"MyStringField131\", DB_TEXT, 75)\nNewtbl.fields.append fld(131)\nSet fld(132) = Newtbl.CreateField(\"MyStringField132\", DB_TEXT, 75)\nNewtbl.fields.append fld(132)\nSet fld(133) = Newtbl.CreateField(\"MyStringField133\", DB_TEXT, 75)\nNewtbl.fields.append fld(133)\nSet fld(134) = Newtbl.CreateField(\"MyStringField134\", DB_TEXT, 75)\nNewtbl.fields.append fld(134)\nSet fld(135) = Newtbl.CreateField(\"MyStringField135\", DB_TEXT, 75)\nNewtbl.fields.append fld(135)\nSet fld(136) = Newtbl.CreateField(\"MyStringField136\", DB_TEXT, 75)\nNewtbl.fields.append fld(136)\nSet fld(137) = Newtbl.CreateField(\"MyStringField137\", DB_TEXT, 75)\nNewtbl.fields.append fld(137)\nSet fld(138) = Newtbl.CreateField(\"MyStringField138\", DB_TEXT, 75)\nNewtbl.fields.append fld(138)\nSet fld(139) = Newtbl.CreateField(\"MyStringField139\", DB_TEXT, 75)\nNewtbl.fields.append fld(139)\nSet fld(140) = Newtbl.CreateField(\"MyStringField140\", DB_TEXT, 75)\nNewtbl.fields.append fld(140)\nSet fld(141) = Newtbl.CreateField(\"MyStringField141\", DB_TEXT, 75)\nNewtbl.fields.append fld(141)\nSet fld(142) = Newtbl.CreateField(\"MyStringField142\", DB_TEXT, 75)\nNewtbl.fields.append fld(142)\nSet fld(143) = Newtbl.CreateField(\"MyStringField143\", DB_TEXT, 75)\nNewtbl.fields.append fld(143)\nSet fld(144) = Newtbl.CreateField(\"MyStringField144\", DB_TEXT, 75)\nNewtbl.fields.append fld(144)\nSet fld(145) = Newtbl.CreateField(\"MyStringField145\", DB_TEXT, 75)\nNewtbl.fields.append fld(145)\nSet fld(146) = Newtbl.CreateField(\"MyStringField146\", DB_TEXT, 75)\nNewtbl.fields.append fld(146)\nSet fld(147) = Newtbl.CreateField(\"MyStringField147\", DB_TEXT, 75)\nNewtbl.fields.append fld(147)\nSet fld(148) = Newtbl.CreateField(\"MyStringField148\", DB_TEXT, 75)\nNewtbl.fields.append fld(148)\nSet fld(149) = Newtbl.CreateField(\"MyStringField149\", DB_TEXT, 75)\nNewtbl.fields.append fld(149)\nSet fld(150) = Newtbl.CreateField(\"MyStringField150\", DB_TEXT, 75)\nNewtbl.fields.append fld(150)\nSet fld(151) = Newtbl.CreateField(\"MyStringField151\", DB_TEXT, 75)\nNewtbl.fields.append fld(151)\nSet fld(152) = Newtbl.CreateField(\"MyStringField152\", DB_TEXT, 75)\nNewtbl.fields.append fld(152)\nSet fld(153) = Newtbl.CreateField(\"MyStringField153\", DB_TEXT, 75)\nNewtbl.fields.append fld(153)\nSet fld(154) = Newtbl.CreateField(\"MyStringField154\", DB_TEXT, 75)\nNewtbl.fields.append fld(154)\nSet fld(155) = Newtbl.CreateField(\"MyStringField155\", DB_TEXT, 75)\nNewtbl.fields.append fld(155)\nSet fld(156) = Newtbl.CreateField(\"MyStringField156\", DB_TEXT, 75)\nNewtbl.fields.append fld(156)\nSet fld(157) = Newtbl.CreateField(\"MyStringField157\", DB_TEXT, 75)\nNewtbl.fields.append fld(157)\nSet fld(158) = Newtbl.CreateField(\"MyStringField158\", DB_TEXT, 75)\nNewtbl.fields.append fld(158)\nSet fld(159) = Newtbl.CreateField(\"MyStringField159\", DB_TEXT, 75)\nNewtbl.fields.append fld(159)\nSet fld(160) = Newtbl.CreateField(\"MyStringField160\", DB_TEXT, 75)\nNewtbl.fields.append fld(160)\nSet fld(161) = Newtbl.CreateField(\"MyStringField161\", DB_TEXT, 75)\nNewtbl.fields.append fld(161)\nSet fld(162) = Newtbl.CreateField(\"MyStringField162\", DB_TEXT, 75)\nNewtbl.fields.append fld(162)\nSet fld(163) = Newtbl.CreateField(\"MyStringField163\", DB_TEXT, 75)\nNewtbl.fields.append fld(163)\nSet fld(164) = Newtbl.CreateField(\"MyStringField164\", DB_TEXT, 75)\nNewtbl.fields.append fld(164)\nSet fld(165) = Newtbl.CreateField(\"MyStringField165\", DB_TEXT, 75)\nNewtbl.fields.append fld(165)\nSet fld(166) = Newtbl.CreateField(\"MyStringField166\", DB_TEXT, 75)\nNewtbl.fields.append fld(166)\nSet fld(167) = Newtbl.CreateField(\"MyStringField167\", DB_TEXT, 75)\nNewtbl.fields.append fld(167)\nSet fld(168) = Newtbl.CreateField(\"MyStringField168\", DB_TEXT, 75)\nNewtbl.fields.append fld(168)\nSet fld(169) = Newtbl.CreateField(\"MyStringField169\", DB_TEXT, 75)\nNewtbl.fields.append fld(169)\nSet fld(170) = Newtbl.CreateField(\"MyStringField170\", DB_TEXT, 75)\nNewtbl.fields.append fld(170)\nSet fld(171) = Newtbl.CreateField(\"MyStringField171\", DB_TEXT, 75)\nNewtbl.fields.append fld(171)\nSet fld(172) = Newtbl.CreateField(\"MyStringField172\", DB_TEXT, 75)\nNewtbl.fields.append fld(172)\nSet fld(173) = Newtbl.CreateField(\"MyStringField173\", DB_TEXT, 75)\nNewtbl.fields.append fld(173)\nSet fld(174) = Newtbl.CreateField(\"MyStringField174\", DB_TEXT, 75)\nNewtbl.fields.append fld(174)\nSet fld(175) = Newtbl.CreateField(\"MyStringField175\", DB_TEXT, 75)\nNewtbl.fields.append fld(175)\nSet fld(176) = Newtbl.CreateField(\"MyStringField176\", DB_TEXT, 75)\nNewtbl.fields.append fld(176)\nSet fld(177) = Newtbl.CreateField(\"MyStringField177\", DB_TEXT, 75)\nNewtbl.fields.append fld(177)\nSet fld(178) = Newtbl.CreateField(\"MyStringField178\", DB_TEXT, 75)\nNewtbl.fields.append fld(178)\nSet fld(179) = Newtbl.CreateField(\"MyStringField179\", DB_TEXT, 75)\nNewtbl.fields.append fld(179)\nSet fld(180) = Newtbl.CreateField(\"MyStringField180\", DB_TEXT, 75)\nNewtbl.fields.append fld(180)\nSet fld(181) = Newtbl.CreateField(\"MyStringField181\", DB_TEXT, 75)\nNewtbl.fields.append fld(181)\nSet fld(182) = Newtbl.CreateField(\"MyStringField182\", DB_TEXT, 75)\nNewtbl.fields.append fld(182)\nSet fld(183) = Newtbl.CreateField(\"MyStringField183\", DB_TEXT, 75)\nNewtbl.fields.append fld(183)\nSet fld(184) = Newtbl.CreateField(\"MyStringField184\", DB_TEXT, 75)\nNewtbl.fields.append fld(184)\nSet fld(185) = Newtbl.CreateField(\"MyStringField185\", DB_TEXT, 75)\nNewtbl.fields.append fld(185)\nSet fld(186) = Newtbl.CreateField(\"MyStringField186\", DB_TEXT, 75)\nNewtbl.fields.append fld(186)\nSet fld(187) = Newtbl.CreateField(\"MyStringField187\", DB_TEXT, 75)\nNewtbl.fields.append fld(187)\nSet fld(188) = Newtbl.CreateField(\"MyStringField188\", DB_TEXT, 75)\nNewtbl.fields.append fld(188)\nSet fld(189) = Newtbl.CreateField(\"MyStringField189\", DB_TEXT, 75)\nNewtbl.fields.append fld(189)\nSet fld(190) = Newtbl.CreateField(\"MyStringField190\", DB_TEXT, 75)\nNewtbl.fields.append fld(190)\nSet fld(191) = Newtbl.CreateField(\"MyStringField191\", DB_TEXT, 75)\nNewtbl.fields.append fld(191)\nSet fld(192) = Newtbl.CreateField(\"MyStringField192\", DB_TEXT, 75)\nNewtbl.fields.append fld(192)\nSet fld(193) = Newtbl.CreateField(\"MyStringField193\", DB_TEXT, 75)\nNewtbl.fields.append fld(193)\nSet fld(194) = Newtbl.CreateField(\"MyStringField194\", DB_TEXT, 75)\nNewtbl.fields.append fld(194)\nSet fld(195) = Newtbl.CreateField(\"MyStringField195\", DB_TEXT, 75)\nNewtbl.fields.append fld(195)\nSet fld(196) = Newtbl.CreateField(\"MyStringField196\", DB_TEXT, 75)\nNewtbl.fields.append fld(196)\nSet fld(197) = Newtbl.CreateField(\"MyStringField197\", DB_TEXT, 75)\nNewtbl.fields.append fld(197)\nSet fld(198) = Newtbl.CreateField(\"MyStringField198\", DB_TEXT, 75)\nNewtbl.fields.append fld(198)\nSet fld(199) = Newtbl.CreateField(\"MyStringField199\", DB_TEXT, 75)\nNewtbl.fields.append fld(199)\nSet fld(200) = Newtbl.CreateField(\"MyStringField200\", DB_TEXT, 75)\nNewtbl.fields.append fld(200)\nSet fld(201) = Newtbl.CreateField(\"MyStringField201\", DB_TEXT, 75)\nNewtbl.fields.append fld(201)\nSet fld(202) = Newtbl.CreateField(\"MyStringField202\", DB_TEXT, 75)\nNewtbl.fields.append fld(202)\nSet fld(203) = Newtbl.CreateField(\"MyStringField203\", DB_TEXT, 75)\nNewtbl.fields.append fld(203)\nSet fld(204) = Newtbl.CreateField(\"MyStringField204\", DB_TEXT, 75)\nNewtbl.fields.append fld(204)\nSet fld(205) = Newtbl.CreateField(\"MyStringField205\", DB_TEXT, 75)\nNewtbl.fields.append fld(205)\nSet fld(206) = Newtbl.CreateField(\"MyStringField206\", DB_TEXT, 75)\nNewtbl.fields.append fld(206)\nSet fld(207) = Newtbl.CreateField(\"MyStringField207\", DB_TEXT, 75)\nNewtbl.fields.append fld(207)\nSet fld(208) = Newtbl.CreateField(\"MyStringField208\", DB_TEXT, 75)\nNewtbl.fields.append fld(208)\nSet fld(209) = Newtbl.CreateField(\"MyStringField209\", DB_TEXT, 75)\nNewtbl.fields.append fld(209)\nSet fld(210) = Newtbl.CreateField(\"MyStringField210\", DB_TEXT, 75)\nNewtbl.fields.append fld(210)\nSet fld(211) = Newtbl.CreateField(\"MyStringField211\", DB_TEXT, 75)\nNewtbl.fields.append fld(211)\nSet fld(212) = Newtbl.CreateField(\"MyStringField212\", DB_TEXT, 75)\nNewtbl.fields.append fld(212)\nSet fld(213) = Newtbl.CreateField(\"MyStringField213\", DB_TEXT, 75)\nNewtbl.fields.append fld(213)\nSet fld(214) = Newtbl.CreateField(\"MyStringField214\", DB_TEXT, 75)\nNewtbl.fields.append fld(214)\nSet fld(215) = Newtbl.CreateField(\"MyStringField215\", DB_TEXT, 75)\nNewtbl.fields.append fld(215)\nSet fld(216) = Newtbl.CreateField(\"MyStringField216\", DB_TEXT, 75)\nNewtbl.fields.append fld(216)\nSet fld(217) = Newtbl.CreateField(\"MyStringField217\", DB_TEXT, 75)\nNewtbl.fields.append fld(217)\nSet fld(218) = Newtbl.CreateField(\"MyStringField218\", DB_TEXT, 75)\nNewtbl.fields.append fld(218)\nSet fld(219) = Newtbl.CreateField(\"MyStringField219\", DB_TEXT, 75)\nNewtbl.fields.append fld(219)\nSet fld(220) = Newtbl.CreateField(\"MyStringField220\", DB_TEXT, 75)\nNewtbl.fields.append fld(220)\nSet fld(221) = Newtbl.CreateField(\"MyStringField221\", DB_TEXT, 75)\nNewtbl.fields.append fld(221)\nSet fld(222) = Newtbl.CreateField(\"MyStringField222\", DB_TEXT, 75)\nNewtbl.fields.append fld(222)\nSet fld(223) = Newtbl.CreateField(\"MyStringField223\", DB_TEXT, 75)\nNewtbl.fields.append fld(223)\nSet fld(224) = Newtbl.CreateField(\"MyStringField224\", DB_TEXT, 75)\nNewtbl.fields.append fld(224)\nSet fld(225) = Newtbl.CreateField(\"MyStringField225\", DB_TEXT, 75)\nNewtbl.fields.append fld(225)\nSet fld(226) = Newtbl.CreateField(\"MyStringField226\", DB_TEXT, 75)\nNewtbl.fields.append fld(226)\nSet fld(227) = Newtbl.CreateField(\"MyStringField227\", DB_TEXT, 75)\nNewtbl.fields.append fld(227)\nSet fld(228) = Newtbl.CreateField(\"MyStringField228\", DB_TEXT, 75)\nNewtbl.fields.append fld(228)\nSet fld(229) = Newtbl.CreateField(\"MyStringField229\", DB_TEXT, 75)\nNewtbl.fields.append fld(229)\nSet fld(230) = Newtbl.CreateField(\"MyStringField230\", DB_TEXT, 75)\nNewtbl.fields.append fld(230)\nSet fld(231) = Newtbl.CreateField(\"MyStringField231\", DB_TEXT, 75)\nNewtbl.fields.append fld(231)\nSet fld(232) = Newtbl.CreateField(\"MyStringField232\", DB_TEXT, 75)\nNewtbl.fields.append fld(232)\nSet fld(233) = Newtbl.CreateField(\"MyStringField233\", DB_TEXT, 75)\nNewtbl.fields.append fld(233)\nSet fld(234) = Newtbl.CreateField(\"MyStringField234\", DB_TEXT, 75)\nNewtbl.fields.append fld(234)\nSet fld(235) = Newtbl.CreateField(\"MyStringField235\", DB_TEXT, 75)\nNewtbl.fields.append fld(235)\nSet fld(236) = Newtbl.CreateField(\"MyStringField236\", DB_TEXT, 75)\nNewtbl.fields.append fld(236)\nSet fld(237) = Newtbl.CreateField(\"MyStringField237\", DB_TEXT, 75)\nNewtbl.fields.append fld(237)\nSet fld(238) = Newtbl.CreateField(\"MyStringField238\", DB_TEXT, 75)\nNewtbl.fields.append fld(238)\nSet fld(239) = Newtbl.CreateField(\"MyStringField239\", DB_TEXT, 75)\nNewtbl.fields.append fld(239)\nSet fld(240) = Newtbl.CreateField(\"MyStringField240\", DB_TEXT, 75)\nNewtbl.fields.append fld(240)\nSet fld(241) = Newtbl.CreateField(\"MyStringField241\", DB_TEXT, 75)\nNewtbl.fields.append fld(241)\nSet fld(242) = Newtbl.CreateField(\"MyStringField242\", DB_TEXT, 75)\nNewtbl.fields.append fld(242)\nSet fld(243) = Newtbl.CreateField(\"MyStringField243\", DB_TEXT, 75)\nNewtbl.fields.append fld(243)\nSet fld(244) = Newtbl.CreateField(\"MyStringField244\", DB_TEXT, 75)\nNewtbl.fields.append fld(244)\nSet fld(245) = Newtbl.CreateField(\"MyStringField245\", DB_TEXT, 75)\nNewtbl.fields.append fld(245)\nSet fld(246) = Newtbl.CreateField(\"MyStringField246\", DB_TEXT, 75)\nNewtbl.fields.append fld(246)\nSet fld(247) = Newtbl.CreateField(\"MyStringField247\", DB_TEXT, 75)\nNewtbl.fields.append fld(247)\nSet fld(248) = Newtbl.CreateField(\"MyStringField248\", DB_TEXT, 75)\nNewtbl.fields.append fld(248)\nSet fld(249) = Newtbl.CreateField(\"MyStringField249\", DB_TEXT, 75)\nNewtbl.fields.append fld(249)\nSet fld(250) = Newtbl.CreateField(\"MyStringField250\", DB_TEXT, 75)\nNewtbl.fields.append fld(250)\nSet fld(251) = Newtbl.CreateField(\"MyStringField251\", DB_TEXT, 75)\nNewtbl.fields.append fld(251)\nSet fld(252) = Newtbl.CreateField(\"MyStringField252\", DB_TEXT, 75)\nNewtbl.fields.append fld(252)\nSet fld(253) = Newtbl.CreateField(\"MyStringField253\", DB_TEXT, 75)\nNewtbl.fields.append fld(253)\nSet fld(254) = Newtbl.CreateField(\"MyStringField254\", DB_TEXT, 75)\nNewtbl.fields.append fld(254)\n\nTDB.TableDefs.append Newtbl\n\n'Create an index for our table.  Need to use a new tabledef\n'object for the table or it doesn't work\n\nTDB.Close\n    \nExitCT:\n    Exit Function\nErrCT:\n    If err <> 91 Then TDB.Close\n    TestFNTbl = False\n    Resume ExitCT\nEnd Function\n\n\n\nFunction acg_CreateTable(strTable As String) As Integer\n'-------------------------\n'Purpose:  Creates A new table and sets field format\n'Accepts:  strTable, the name of the new table\n'Returns:  True (-1) on success, False on failure\n'-------------------------\n'When you are creating a table using code you may want to set a field's format\n'or number of decimal places.\n'Alternately if you run a make table query using already formated fields as an\n'input, you will find that the new table does not carry over the formatting of\n'your input fields. Therefore in each situation, you need to set the format for\n'the field.\n'\n'The format and decimal places properties of a field do not exist until they are\n'created, so if you query a field's \"format\" property before it is created, you'll\n'get an error saying there is no such property. So here's some code which creates\n'a simple table, and then sets the format and decimal places properties for a couple\n'of fields. You can strip out the code for the format section to create a new\n'function for setting the format for a table after running a make table query.\n\n'Function provided by ATTAC Consulting Group, Ann Arbor, MI  USA\n\nOn Error GoTo ErrCT\n\nDim TDB As DAO.Database\n\n\nDim fld1 As field, fld2 As field, fld3 As field\nDim fFormat2 As Property, fFormat3 As Property, fFormat4 As Property\nDim idxTbl As Index\nDim idxFld As field\nDim Newtbl As TableDef\nDim Newtbl2 As TableDef\n\nacg_CreateTable = True\n\n'First Create the table\n\nSet TDB = CurrentDb()\nSet Newtbl = TDB.CreateTableDef(strTable)\nSet fld1 = Newtbl.CreateField(\"MyStringField\", DB_TEXT, 75)\nNewtbl.fields.append fld1\nSet fld2 = Newtbl.CreateField(\"MyNumberField\", DB_SINGLE)\nNewtbl.fields.append fld2\nSet fld3 = Newtbl.CreateField(\"MyDateTimeField\", DB_DATE)\nNewtbl.fields.append fld3\nTDB.TableDefs.append Newtbl\n\n'Create an index for our table.  Need to use a new tabledef\n'object for the table or it doesn't work\n\nSet Newtbl2 = TDB.TableDefs(strTable)\nSet idxTbl = Newtbl2.CreateIndex(\"PrimaryKey\")\nidxTbl.Primary = -1\nidxTbl.Unique = -1\nSet idxFld = idxTbl.CreateField(\"MyStringField\")\nidxTbl.fields.append idxFld\nNewtbl2.indexes.append idxTbl\n\n'Format the single field to have two decimal places\n'and the datetime field to be a medium time.\n'Note that decimal places has no space in the name\n\nSet fld2 = Newtbl2.fields(\"MyNumberField\")\nSet fFormat2 = fld2.CreateProperty(\"DecimalPlaces\", DB_BYTE, 2)\nfld2.Properties.append fFormat2\nSet fld3 = Newtbl2.fields(\"MyDateTimeField\")\nSet fFormat3 = fld3.CreateProperty(\"Format\", DB_TEXT, \"Medium Time\")\nfld3.Properties.append fFormat3\n\n' To add any comment to a field (\"Beschreibung\" hinzufügen)\n\nSet fFormat4 = fld1.CreateProperty(\"Description\", DB_TEXT, \" Field 1 Description bla bla\")\nfld1.Properties.append fFormat4\nSet fFormat4 = fld2.CreateProperty(\"Description\", DB_TEXT, \" Field 2 Description bla bla\")\nfld2.Properties.append fFormat4\nSet fFormat4 = fld3.CreateProperty(\"Description\", DB_TEXT, \" Field 3 Description bla bla\")\nfld3.Properties.append fFormat4\n\nTDB.Close\n    \nExitCT:\n    Exit Function\nErrCT:\n    If err <> 91 Then TDB.Close\n    acg_CreateTable = False\n    Resume ExitCT\nEnd Function\n \n\nFunction FeldFuellen(MaxFeldLen As Integer, Inhalt As String, _\nFuellZeichen As String, Ausrichtung As Boolean) As String\n\n'Art.Nr.: D29890\n'\n'Frage:\n'\n'Ich möchte Kundendaten in eine Textdatei mit fester Feldlänge exportieren.\n'Das Exportformat gibt einen bestimmten Feldaufbau vor. So muß es z.B. möglich\n'sein, die Ausrichtung des Feldinhaltes zu bestimmen und es muß möglich sein,\n'die Zeichen festzulegen, mit welchen der Feldinhalt aufgefüllt werden soll,\n'falls dieser nicht den ganzen Feldbereich beansprucht.\n'Wie kann ich vorgehen?\n'\n'Antwort:\n'\n'Diese Anforderungen übersteigen die Möglichkeiten der Format()-Funktion,\n'aber Sie können das Problem über eine ACCESS BASIC Prozedur lösen.\n'\n'Schreiben Sie dazu folgenden Funktion in ein globales Modul Ihrer ACCESS-Anwendung:\n'\n'Anmerkung:\n'In den folgenden Codebeispielen wird der Unterstrich (_) als\n'Zeilenfortsetzungszeichen benutzt. Löschen Sie den Unterstrich und den\n'folgenden Zeilenumbruch, wenn Sie den Code in einem Modul eingeben.\n'\n'Die Funktion erwartet folgende Parameter:\n'\n'MaxFeldLen Gibt die Länge des Feldes an\n'Inhalt Stellt den Feldinhalt dar\n'FuellZeichen Zeichen, mit welchem aufgefüllt werden soll\n'Ausrichtung Gibt die Ausrichtung des Feldinhaltes an\n'\n'\n'Der Aufruf dieser Funktion könnte beispielsweise als Ausdruck in einer Abfrage\n'erfolgen.\n'\n'Ausdruck1: FeldFuellen(11;[Einzelpreis];\"0\";\"Rechts\")\n'\n'Dieser Ausdruck liefert einen Text-String, der auf eine Länge von 11 Zeichen\n'mit führenden Nullen aufgefüllt wird. Der Inhalt wird rechtsbündig angeordnet.\n'\n'Alternativ könnten Sie als Füllzeichen das Leerzeichen (\" \") oder den\n'Stern (\"*\" ) verwenden.\n\nDim Rest As Integer\n\nRest = IIf(MaxFeldLen - Len(Trim(Inhalt)) < 0, 0, _\nMaxFeldLen - Len(Trim(Inhalt)))\n\nIf UCase(Ausrichtung) = \"RECHTS\" Then\nFeldFuellen = String(Rest, FuellZeichen) & Trim(Inhalt)\nElse ' Links\nFeldFuellen = Trim(Inhalt) & String(Rest, FuellZeichen)\nEnd If\n\nEnd Function\n\n\nFunction RecordNumber(pstrPreFix As String, pFrm As Form) As String\n\n'How do I emulate the \"Record X of Y\" that Access displays in the navigation buttons\n'\n' The following function will do this for a form, just send any string and the form\n' object as the parameters, e.g. in a ControlSource use\n'\n'=RecordNumber(\"Item\",[Form])\n'\n'For code, use:\n'strVariable = RecordNumber(\"Item\", Me)\n'or\n'strVariable = RecordNumber(\"Item\", Forms!MyForm)\n'\n'This will return something like \"Item 4 of 899\", if the form is on a new record it\n'will return the string \"New Record\".\n\n    On Error GoTo RecordNumber_Err\n    Dim rst As DAO.Recordset\n    Dim lngNumRecords As Long\n    Dim lngCurrentRecord As Long\n    Dim strTmp As String\n    \n    Set rst = pFrm.RecordsetClone\n    rst.MoveLast\n    rst.Bookmark = pFrm.Bookmark\n    lngNumRecords = rst.RecordCount\n    lngCurrentRecord = rst.AbsolutePosition + 1\n    strTmp = pstrPreFix & \" \" & lngCurrentRecord & \" von \" & lngNumRecords\nRecordNumber_Exit:\n    On Error Resume Next\n    RecordNumber = strTmp\n    rst.Close\n    Set rst = Nothing\n    Exit Function\nRecordNumber_Err:\n    Select Case err\n        Case 3021\n            strTmp = \"New Record\"\n            Resume RecordNumber_Exit\n        Case Else\n            strTmp = \"#\" & Error\n            Resume RecordNumber_Exit\n    End Select\nEnd Function\n \n\n'To produce a tabular report with alternating shaded/not shaded rows:\n'\n'Create a Tabular Report (using the Wizard if necessary)\n'\n'In the Detail Section of the Report, create a textbox:\n'Name:                  txtRowCount\n'        ControlSource: =1\n'RunningSum:            Over All\n'Visible:               No\n'Hide txtRowCount behind another control by using Format/Send to Back\n'\n'Set the Detail Section's OnFormat property to: =MusicRule([txtRowCount])\n\n'Paste the following function into a module:\n\n'Kommentar von Stefan Wirrer VOLKE_EE@csi.com dazu:\n'###################\n'Zu 'Wie hinterlege ich jede 2. Zeile beim Druck eines Berichts grau ?'\n'(Function MusicRule) hätte ich eine Verbesserung.\n'Der Titel ist etwas irreführend, da nicht der Detailbereich grau hinterlegt\n'wird, sondern nur die Steuerelemente im Detailbereich (was nicht besonders\n'schön aussieht). Daher meine Verbesserung:\n'Statt\n'For intN = 0 To rpt.Count - 1\n'    If rpt(intN).section = 0 Then\n'        rpt(intN).BackColor = lngC\n'    End If\n'Next\n'ist es schöner mit\n'rpt.section(acDetail).BackColor = lngC\n'###################\n\nFunction MusicRule(ctl As control)\n\nDim lngC As Long\nDim intN As Integer\nDim rpt As Report\nSet rpt = Screen.ActiveReport\n'\nIf (ctl Mod 2) = 0 Then\n    lngC = &HC0C0C0  'light grey on even numbered lines\nElse\n    lngC = &HFFFFFF  'white on odd numbered lines\nEnd If\n'\nOn Error GoTo MusicRule_Exit\nFor intN = 0 To rpt.Count - 1\n    If rpt(intN).Section = 0 Then\n        rpt(intN).backColor = lngC\n    End If\nNext\n\nMusicRule_Exit:\n\nEnd Function\n\n\n'--------------------------------------------------------------------------------\n'Extracting Words or Parameters From a String of Text\n'S. Boban Dragojlovic of Los Angeles, California USA.\n'\n'This isn 't a \"hidden trick\" of Access, but it is a very useful function\n'(for me, anyway).\n'\n'I often need to extract \"words\" or parameters from a string of text, and\n'I wrote this routine for such occasions.\n'\n'For example, extracting each whole word from\n'\"The quick brown fox? It jumps over the lazy dog.\"\n'(in this example, strDelims would be \".;'?! \")\n'\n'Or, looking at each POSITIONAL paramter in\n'\"ALPHA,,,DELTA,GAMMA,,PI,,\"\n'(in this example, strDelims would be \",\" and fCountDupes would be TRUE)\n'\n'This function parses out all words from a string (strFrom), and places each of\n'them into a seperate element of raWords().\n'\n'    INPUT\n'    strFrom  the string to parse\n'    raWords()        the dynamic array where the words will be placed\n'    strDelims        a string of single-character delimiters\n'    fCountDupes      a flag.  If TRUE, then consecutive delimiters will\n'                     count individually.  If FALSE, then consecutive\n'                     delimiters will be treated as a single delimiter.\n'For example, in the string \"A,,,B\" (assuming that the comma is the delimiter).\n'fCountDupes=TRUE will interpret this string as having 2 words: \"A\" & \"B\".\n'fCountDupes=FALSE will interpret this string as having 4\n'words: \"A\" & \"\" & \"\" & \"B\"\n'    OUTPUT\n'    raWords() will contain the individual words\n'    The function itself returns the number of words found.\n'NOTE: A trailing delimiter (e.g. \"A,B,\") signifies that another word follows\n'(albeit that word is blank) and this function will return 3 in this example.\n\nFunction ExtractWords(ByVal strFrom As String, raWords() As String, strDelims _\nAs String, fCountDupes As Integer) As Integer\n\n    Dim intWC As Integer, intX As Integer, intLen As Integer\n    Dim strWord As String\n\n\n    ExtractWords = 0\n    intLen = Len(strFrom)\n\n    If (intLen = 0) Then\n        Exit Function\n    End If\n\n    strWord = \"\"\n\n    intWC = 1\n    ReDim raWords(intWC)\n\n    intX = 1\n    Do While (intX <= intLen)\n        If (InStr(strDelims, Mid$(strFrom, intX, 1)) > 0) Then\n            \n         ' current char is a delimiter\n\n            raWords(intWC) = strWord\n             intWC = intWC + 1\n            ReDim Preserve raWords(intWC)\n            strWord = \"\"\n\n            If Not fCountDupes Then\n              ' skip contiguous delimiters\n                Do Until (intX > intLen) _\n                     Or (InStr(strDelims, Mid$(strFrom, intX, 1)) = 0)\n                    intX = intX + 1\n                Loop\n                If (intX <= intLen) Then\n                    strWord = Mid$(strFrom, intX, 1)\n                End If\n            End If\n\n        Else    ' current char is NOT a delimiter\n\n            strWord = strWord + Mid$(strFrom, intX, 1)\n\n        End If\n\n        intX = intX + 1\n    Loop\n\n    raWords(intWC) = strWord\n    ExtractWords = intWC\n\nEnd Function\n\nFunction TstWd()\n'ExtractWords im Direktfenster testen\nDim TestArray() As String, AnzWd, i\nAnzWd = ExtractWords(\"Hugo;Caesar;;Anton;Berta;Meier;;Müller\", TestArray(), \";\", True)\nDebug.Print\nDebug.Print \"---------------------\"\nDebug.Print \"  Test ExtractWords  \"\nDebug.Print \"---------------------\"\nDebug.Print\nDebug.Print \"Input Teststring: \" & \"Hugo;Caesar;;Anton;Berta;Meier;;Müller\"\nDebug.Print \"Input Delimiter:  \" & \";\"\nDebug.Print\n\nDebug.Print \"fCountDupes True \"\nDebug.Print \"Anzahl gefundene Teilstrings: \" & AnzWd\nDebug.Print \"Lbound \" & LBound(TestArray)\nDebug.Print \"Ubound \" & UBound(TestArray)\nFor i = LBound(TestArray) To UBound(TestArray)\n    Debug.Print \"   String \" & i & \" : \" & TestArray(i)\nNext i\n\nDebug.Print\nDebug.Print \"---------------------\"\nDebug.Print\n\nAnzWd = ExtractWords(\"Hugo;Caesar;;Anton;Berta;Meier;;Müller\", TestArray(), \";\", False)\nDebug.Print \"fCountDupes False \"\nDebug.Print \"Anzahl gefundene Teilstrings: \" & AnzWd\nDebug.Print \"Lbound \" & LBound(TestArray)\nDebug.Print \"Ubound \" & UBound(TestArray)\nFor i = LBound(TestArray) To UBound(TestArray)\n    Debug.Print \"   String \" & i & \" : \" & TestArray(i)\nNext i\n\nDebug.Print\nDebug.Print \"---------------------\"\n\nEnd Function\n\nFunction fCreateAutoNumberField( _\n                ByVal strTableName As String, _\n                ByVal strFieldName As String) _\n                As Boolean\n'\n' Autor: Dev Ashish\n'\n'Creating an AutoNumber field from code\n'\n'There are two methods to create an AutoNumber field from code.  One requires you to run a\n'SQL DDL \"Create Table\" statement, and the other uses VBA to append dbAutoIncrField flag to a\n'new field's Attributes property.\n'\n'To create the field using SQL DDL statements, refer to this Knowledge Base article:\n'\n' Article ID Q116145\n'ACC: Create and Drop Tables and Relationships Using SQL DDL\n'\n'To create the field using VBA and DAO,  you can use this function.\n\n'   Creates an Autonumber field with name=strFieldName\n'   in table strTableName.\n'   Accepts\n'       strTableName:   Name of table in which to create the field\n'       strFieldName:    Name of the new field\n'   Returns True on success, false otherwise\n'\n\nOn Error GoTo ErrHandler\nDim db As DAO.Database\nDim fld As DAO.field\nDim tdf As DAO.TableDef\n\n    Set db = Application.CurrentDb\n    Set tdf = db.TableDefs(strTableName)\n    '   First create a field with datatype = Long Integer\n    Set fld = tdf.CreateField(strFieldName, dbLong)\n    With fld\n        '   Appending dbAutoIncrField to Attributes\n        '   tells Jet that it's an Autonumber field\n        .attributes = .attributes Or dbAutoIncrField\n    End With\n    With tdf.fields\n        .append fld\n        .Refresh\n    End With\n    \n    fCreateAutoNumberField = True\n    \nExitHere:\n    Set fld = Nothing\n    Set tdf = Nothing\n    Set db = Nothing\n    Exit Function\nErrHandler:\n    fCreateAutoNumberField = False\n    With err\n        MsgBox \"Error \" & .Number & vbCrLf & .description, _\n            vbOKOnly Or vbCritical, \"CreateAutonumberField\"\n    End With\n    Resume ExitHere\nEnd Function\n\n\nFunction fTableWithHyperlink(stTablename As String) As Boolean\n'---Posted by Dev Ashish---\n'\n'Create Hyperlink Field from code\n'(Q)    I'm unable to create a Hyperlink Field in a table from code.   What are the steps that\n'       I need to take or is this possible?\n'\n'(A)    To create a Hyperlink field, you need to set the Attributes to dbHyperlinkField.\n'\n'    Try this function as an example.\n'\n   On Local Error GoTo fTableWithHyperlink_Err\nDim msg As String ' for error handling\nDim db As DAO.Database\nDim tdf As TableDef\nDim fld As field\n    Set db = CurrentDb\n    Set tdf = db.CreateTableDef(stTablename)\n    Set fld = tdf.CreateField(\"HyperlinkTest\", dbMemo)\n    fld.attributes = dbHyperlinkField\n    tdf.fields.append fld\n    tdf.fields.Refresh\n    db.TableDefs.append tdf\n    db.TableDefs.Refresh\n    Set fld = Nothing\n    Set tdf = Nothing\n    Set db = Nothing\n   \n    fTableWithHyperlink = True\n\nfTableWithHyperlink_End:\n   Exit Function\n\nfTableWithHyperlink_Err:\n   fTableWithHyperlink = False\n   msg = \"Error Information...\" & vbCrLf & vbCrLf\n   msg = msg & \"Function: fTableWithHyperlink\" & vbCrLf\n   msg = msg & \"Description: \" & err.description & vbCrLf\n   msg = msg & \"Error #: \" & Format$(err.Number) & vbCrLf\n   MsgBox msg, vbInformation, \"fTableWithHyperlink\"\n   Resume fTableWithHyperlink_End\nEnd Function\n\nSub SavTxt(frmName As String, Dateiname As String, Optional ByVal AcArt As Long = acForm)\n\n'Application.SaveAsText acForm, \"frmWinWord aufrufen\", \"C:\\frmxx.txt\"\nApplication.SaveAsText AcArt, frmName, Dateiname\n\n'\nEnd Sub\n'\nSub LodTxt(frmName As String, Dateiname As String, Optional AcArt As Long = acForm)\n\n'Application.LoadFromText acForm, \"Testform\", \"D:\\Basic\\Zip\\Csetxlat\\Frmcnvt.frm\"\nApplication.LoadFromText AcArt, frmName, Dateiname\n\nEnd Sub\n\n\nFunction NullTrim(ByVal XString As String, Optional AllNum As Integer = 3) As String\n\n'AllNum = 1 Ltrim\n'AllNum = 2 RTrim\n'AllNum = 3 LTrim und RTrim\n\nDim Xlng As Integer, i As Integer\nDim Vgl1 As Integer\n\nXString = Nz(XString)\nXlng = Len(XString)\n\n'Übergebener String > 0\nIf Xlng = 0 Then\n    NullTrim = \"\"\n    Exit Function\nEnd If\n\nIf AllNum < 1 Or AllNum > 3 Then AllNum = 3\n\nIf AllNum = 1 Or AllNum = 3 Then\n    'Enthält der linke Teil eines Strings Hex(0)\n    Vgl1 = 0\n    For i = 1 To Xlng\n        If Mid(XString, i, 1) = Chr(0) Then\n            Vgl1 = i\n        Else\n            Exit For\n        End If\n    Next i\n    'Wenn Ja, entfernen\n    If Vgl1 > 0 Then\n        XString = Mid(XString, Vgl1 + 1)\n    End If\nEnd If\n\nXlng = Len(XString)\nIf AllNum = 2 Or AllNum = 3 Then\n    'Enthält der rechte Teil eines Strings Hex(0)\n    Vgl1 = 0\n    For i = Xlng To 1 Step -1\n        If Mid(XString, i, 1) = Chr(0) Then\n            Vgl1 = i\n        Else\n            Exit For\n        End If\n    Next i\n    'Wenn Ja, entfernen\n    If Vgl1 > 0 Then\n        XString = Left(XString, Vgl1 - 1)\n    End If\nEnd If\n\nNullTrim = XString\n\nEnd Function\n\nFunction NullTrimTest()\nDim X As String\n\n\nX = \"Keine Nullen\"\nDebug.Print \"!\" & X & \"!\"\nDebug.Print \"!\" & NullTrim(X) & \"!\"\n\nX = Chr(0) & Chr(0) & Chr(0) & \"Hat Nullen\" & Chr(0) & Chr(0) & Chr(0)\nDebug.Print \"!\" & X & \"!\"\nDebug.Print \"!\" & NullTrim(X) & \"!\"\n\nEnd Function\n\n\nFunction BinImport(tabelle As String, PfadDatei As String, BinaryFeld As String, Optional Kurztext As String, Optional ID As Long = 0)\n\n' Eine Datei als OLE-Object in ein Tabellenfeld importieren\n\n'Autor: Günther Ritter  www.ostfrieslandweb.de\n\n' tabelle    = Tabellenname, in die importiert werden soll\n' PfadDatei  = Dateiname incl. Pfad der zu importierenden Datei\n' BinaryFeld = Name des OLE-Object Feldes\n\n'Achtung, absolute Feldnamen: BytesAnz, DateiName, KurzText\n\n'Aufbau der Tabelle _tblPicture:\n'-----------------------------\n'ID         - Autowert\n'BytesAnz   - Zahl / Long Integer\n'DateiName  - Memo\n'Kurztext   - Text 100\n'LangText   - Memo\n'Picture    - OLE-Object\n\nDim db As DAO.Database, rs As DAO.Recordset, i As Long, Nr As Long, BinaryData() As Byte\n\nSet db = CurrentDb\nSet rs = db.OpenRecordset(tabelle)\n\nNr = FreeFile\n\n  Open PfadDatei For Binary As #Nr\n  \n  ReDim BinaryData(LOF(Nr))\n  \n  Get #Nr, , BinaryData()\n  \n  rs.AddNew\n  \nIf ID > 0 Then\n  rs(\"ID\") = ID\nEnd If\n  rs(\"BytesAnz\") = LOF(Nr)\n  rs(\"DateiName\") = PfadDatei\n  rs(\"KurzText\") = Nz(Kurztext)\n  rs(\"Erst_am\") = Now()\n  rs(\"Erst_von\") = atCNames(1)\n  rs(BinaryFeld).AppendChunk BinaryData\n  rs.update\n  Close #Nr\n  \n  Erase BinaryData\n  \n  rs.Close\n  db.Close\n  Set rs = Nothing\n  Set db = Nothing\n  \nEnd Function\n\n\nFunction BinExport(tabelle As String, PfadDatei As String, BinaryFeld As String, IDNr As Long) As Boolean\n\n' Ein OLE-Object eines Tabellenfeldes in eine Datei exportieren\n\n'Autor: Günther Ritter  www.ostfrieslandweb.de\n\n' tabelle    = Tabellenname\n' PfadDatei  = Dateiname incl. Pfad\n' BinaryFeld = Name des OLE-Object Feldes\n' IDNr       = ID-Nummer des Datensatzes der Tabelle\n\n'Achtung, absolute Feldnamen: ID\n\n'Aufbau der Tabelle _tblPicture:\n'-----------------------------\n'ID         - Autowert\n'BytesAnz   - Zahl / Long Integer\n'DateiName  - Memo\n'Kurztext   - Text 100\n'LangText   - Memo\n'Picture    - OLE-Object\n\nDim db As DAO.Database, rs As DAO.Recordset, i As Long, Nr As Long, BinaryData() As Byte\n\nOn Error GoTo xxerr\n\nSet db = CurrentDb\nSet rs = db.OpenRecordset(\"select \" & BinaryFeld & \" from \" & tabelle & \" where id=\" & IDNr)\n\nNr = FreeFile\n\n  Open PfadDatei For Binary As #Nr\n  \n    rs.MoveFirst\n  \n    ReDim BinaryData(rs(BinaryFeld).FieldSize)\n     \n    BinaryData() = rs(BinaryFeld).GetChunk(0, rs(BinaryFeld).FieldSize)\n    Put #Nr, , BinaryData()\n    \n  Close #Nr\n   \nxxend:\n  On Error Resume Next\n  Erase BinaryData\n   \n  rs.Close\n  db.Close\n  Set rs = Nothing\n  Set db = Nothing\n  \n  BinExport = True\n  \n    Exit Function\n    \nxxerr:\n    \n    BinExport = False\n    MsgBox \"Fehler: \" & err.description & \" \" & err.Number & \" On BinExport (mdlSonstiges1)\"\n    err.clear\n    GoTo xxend\n\nEnd Function\n\n\nPublic Function KillABK(strDbName$, strSchalter$)\n'Autor: Harald Langer\n'Hebt AllowByPass in anderer DB wieder auf oder schaltet wieder ein\n\nDim db As DAO.Database\nSet db = DBEngine.Workspaces(0).OpenDatabase(strDbName)\n\nSelect Case strSchalter\n Case \"Aus\"\n  db.Properties!AllowByPassKey = True\n Case \"Ein\"\n  db.Properties!AllowByPassKey = False\nEnd Select\n\ndb.Close\n\nEnd Function\n"}
