{"id":"MOD_mdlSonstiges3","name":"mdlSonstiges3","kind":"standard","procedures":["Public Function ReferenzTest() As Integer","Function GetLast(ControlName As String)","Function Text2HTML(s As String) As String","Function Path_erzeugen(ByVal Pathnamen As String, Optional CreatWarn As Boolean = True, Optional WarnOnErr As Boolean = True) As Boolean","Function Asc2Num(XZeichen As String)","Function fEval(Status As String)","Private Function Eval_TestThis()","Private Function Eval_testThat()","Function Zeichen_lösch(Quellstr As String, Optional Leerz As String = \" \") As Variant","Function suchenStr(tabelle$)","Sub sOpenMDB(strInMDB As String)","Function fktHideMB()","Function AccessexePath() As String","Function DefValprf(XWert As Variant) As Variant","Public Function smsMakeMde(ByVal vstrDstMdbPath As String, _","Function Konv_MDE(strMDBFile As String, strMDEFile As String) As Integer","Function smsDisablePulldownMenuEntry(parMenuBarName As String, _","Sub AlterFieldType(tblname As String, fieldName As String, NewDataType As String)","Function ReverseString(MyString As String)","Function EnableControls(frm As Form, intSection As Integer, intState As Boolean) As Boolean","Function HideForm() As Integer","Function GetLineNumber(f As Form, KeyName As String, KeyValue)","Function RunSum(f As Form, KeyName As String, KeyValue, FieldToSum As String)","Function KillAllForms()","Function SAnzahl(s As String, a As String) As Integer","Function selektiere(ByVal s As String, ByVal i As Integer, ByVal a As String) As String","Public Function LetztZeilen(Ganz, LZeilen)","Sub ApplSetSub()","Function ReplaceStr(Textin, SearchStr, Replacement, Optional CompMode As Integer = 2)","Function CRtoASCII(Textin) As Variant","Function ASCIItoCR(Textin) As Variant","Function LFtoCRLF(Textin) As Variant","Public Function pfadkuerzen(pfad As String, Optional linksstart As Integer = 30, Optional rechtsstart As Integer = 40, Optional sTrenner As String = \"\\\") As String","Function Proper(X)","Function Uml2Win(ByVal X As String, ASC2WIN As Boolean) As Variant","Function HexStr(AscString As String) As String","Function UnHexStr(HexString As String) As String","Function DabaEinAus(Optional Einblenden As Boolean = True)","Function OpenMacro(macroName As String) As Boolean","Public Function SafeSQLString(Text As Variant) As Variant","Function SystemMdwPath() As String","Function RandomWert(Optional ByVal IPwd_lng As Byte = 10, Optional iTextTyp As Long = 0) As String","Function RandomPasswort(Optional ByVal IPwd_lng As Byte = 10, Optional Dummywert As Variant) As String","Function RndLongWert(Optional Untergrenze As Long = 0, Optional Obergrenze As Long = 6, Optional Dummywert As Variant) As Long","Public Function ValidFilename(Name As String, Optional char As String) As Boolean","Function mdbVersion(strDB_file As String) As String","Function GetGroup(Server As String)"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\n'   ReferenzTest       - Überprüft die References-Auflistung, killt Fehler\n'   GetLast            - Liefert den letzten Datensatz\n'   Text2HTML          - Wandelt Umlaute HTML-gerecht umx\n'   Path_erzeugen      - Erzeugt einen Path \"auf einen Rutsch\"\n'   Asc2Num            - Wandelt ein ASC-String in einen numerischen String um\n'   fEval              - Prozedurname als Variable übergeben\n'   Zeichen_lösch      - Löscht ein bestimmtes Zeichen\n'   suchenStr          - Diese Funktion sucht in einer Tabelle in beliebig vielen Feldern auch einen Teilstring\n'   sOpenMDB           - Aktuelle MDB schließen und andere MDB öffnen\n'   fktHideMB          - Verstecken aller Menü- und Symbolleisten\n'   AccessexePath      - Wie heißt der Path von MSACCESS.EXE\n'   DefValprf          - Mit dieser Funktion kann für DefaultValue der korrekte Wert zurückgegeben werden\n'   smsMakeMde         - MDE \"offiziell\" erzeugen\n'   Konv_MDE           - nicht dokumentierter Kurzaufruf um MDE zu erzeugen\n'   smsDisablePulldownMenuEntry\n'   AlterFieldType     - FeldTyp ändern\n'   ReverseString      - String rückwärts ausgeben, d.h. \"Neger\" als \"regeN\" ausgeben\n'   EnableControls     - Enable or disable controls in specified section of form\n'   HideForm           - Formular verstecken\n'   GetLineNumber      - Zeilennummer\n'   RunSum             - Running Sum eines Unterformulars im Hauptformular\n'   KillAllForms       - Alle Formulare lsöchen\n'   selektiere         - String-Parsing\n'   SAnzahl            - Wieviele Substrings gibt es (in selektiere verwendet)\n'   LetztZeilen        - Drucken der letzten 5-10 Zeilen eines Memofeldes\n'   ApplSetSub         - Options für Runtime-Umgebung setzen\n'   ReplaceStr         - Substrings in einem String ersetzen (aus dr Neatcd97.mdb)\n'   CRtoASCII          - CR LF durch Text \"CRLF\" ersetzen\n'   LFtoCRLF           - LF durch CR LF ersetzen\n'   ASCIItoCR          - Text \"CRLF\" durch CR LF ersetzen\n'   pfadkuerzen        - Pfad für Optik kürzen\n'   DatensatzIDZähler  - Ersatz für Autowert\n'   Proper             - Erstes Zeichen jedes Worts groß schreiben\n'   Uml2Win            - Funktion zu den Declares OEMtoANSI und ANSItoOEM (Umlaute Win <--> Dos)\n'   HexStr             - String als Hex ausgeben \"ÄÖÜ\" als \"C4 D6 DC\" ausgeben\n'   UnHexStr           - HexString als String ausgeben \"C4 D6 DC\" als \"ÄÖÜ\" ausgeben\n'   DabaEinAus         - Datenbank-Fenster ein / ausblenden\n'   OpenMacro          - Makro zum editieren öffnen\n'   SystemMdwPath      - Name und Pfad der aktiven \"system.mdw\"\n'   ValidFilename      - Prüft Filename auf Gültigkeit ...\n'   mdbVersion         - mdbVersion\n'   RandomPasswort     - Passwort generieren\n'   RandomWert         - Wert generieren\n\n'**********************************************************************************\n' Deklarationen für MakePath in einem Befehl\n'**********************************************************************************\nDeclare PtrSafe Function MakePath Lib \"imagehlp.dll\" Alias _\n    \"MakeSureDirectoryPathExists\" (ByVal lpPath As String) As Long\n'\n'**********************************************************************************\n' Deklarationen für Umlaute umsetzen\n' PC -- > Ansi (Win)\n'**********************************************************************************\n  Declare PtrSafe Function OemToChar Lib \"user32\" Alias \"OemToCharA\" (ByVal lpszSrc As String, ByVal lpszDst As String) As Long\n\n'**********************************************************************************\n' Deklarationen für Umlaute umsetzen\n' Ansi (Win) --> PC\n'**********************************************************************************\n  Declare PtrSafe Function CharToOem Lib \"user32\" Alias \"CharToOemA\" (ByVal lpszSrc As String, ByVal lpszDst As String) As Long\n\n\nPublic Function ReferenzTest() As Integer\n'Überprüft die References-Auflistung, killt ggf. ungültige Verweise\n'Erstellt von: Hendrik Lindemann <Hendrick@gmx.de>\n'Geändert am 14.01.1999 - Fehlerbehandlung verbessert, Rückgabe als Integer\nOn Error GoTo Err_ReferenzTest\nDim ref As Reference\nDim strMldg As String\n\nConst conStrErrMldg1 As String = \"Kritischer Fehler: Typbibliothek(en) nicht\" & _\n\"gefunden oder nicht verwendbar.\"\nConst conStrErrMldg2 As String = \"Die Anwendung wird unter Umständen nicht \" & _\n\"korrekt funktionieren.\"\nstrMldg = \"\"\nWith Application\nFor Each ref In .References\n    If ref.IsBroken Then\n        On Error Resume Next                'Fehlerbehandlung aus\n        strMldg = strMldg & \"Pfad:\" & vbTab & ref.FullPath & vbCrLf\n        strMldg = strMldg & \"Version:\" & vbTab & ref.Major & \".\" & _\n                    ref.Minor & vbCrLf & vbCrLf\n        On Error GoTo Err_ReferenzTest      'und wieder ein\n        If ref.BuiltIn Then\n            MsgBox conStrErrMldg1, vbCritical\n            ReferenzTest = False\n        Else\n            Select Case MsgBox(conStrErrMldg1 & \"@\" & strMldg & \"@\" & _\n                        conStrErrMldg2, vbAbortRetryIgnore + vbCritical)\n            Case vbIgnore\n                .References.Remove ref\n            Case vbAbort\n                 Exit Function\n            End Select\n        End If\n    End If\nNext ref\nEnd With\n\nExit_ReferenzTest:\n    ReferenzTest = True\nExit Function\n\nErr_ReferenzTest:\n    MsgBox \"Fehler-Nr. \" & err.Number & \" in der Funktion 'Referenztest'.@Beschreibung: \" & _\n    err.description & \"@Bitte überprüfen Sie im Entwurfsansicht eines Moduls im Menü \" & _\n    \"'Extras -> Verweise' auf evtl. fehlende Verweise und löschen Sie diese manuell. \" & _\n    \"Versuchen Sie dann erneut diese Verweise einzubinden.\", vbCritical, err.Source\nEnd Function\n\nFunction GetLast(ControlName As String)\n' Newsgroup Harald Langer, übernommen von MS (Nordwind)\nDim f As Form\nDim ds As DAO.Recordset\n\nSet f = Screen.ActiveForm\nSet ds = f.RecordsetClone\nds.MoveLast\nGetLast = ds(ControlName)\nds.Close\nEnd Function\n\nFunction Text2HTML(s As String) As String\n' von Sascha Wostmann\n' Gibt's im Access97 eine VB-Prozedur, die es ermöglicht, dass ein\n' \"normaler\" String in einen String umgewandelt wird, indem die\n' HTML-Sonderzeichen umgewandelt werden (\"ö\" => \"&ouml;\")?\n' Gunther Engelmann (8.1.2000):\n' Zeichenliste erweitert (vollständig??)\n\nDim ret As String\nDim i As Integer\n\n  ret = \"\"\n\n  For i = 1 To Len(s)\n    Select Case Mid$(s, i, 1)\n    Case \"­\":      ret = ret & \"&shy;\"\n    Case \"\"\"\":     ret = ret & \"&quot;\"\n    Case \"&\":      ret = ret & \"&amp;\"\n    Case \"¡\":      ret = ret & \"&iexcl;\"\n    Case \"¦\":      ret = ret & \"&brvbar;\"\n    Case \"¨\":      ret = ret & \"&uml;\"\n    Case \"¯\":      ret = ret & \"&macr;\"\n    Case \"´\":      ret = ret & \"&acute;\"\n    Case \"¿\":      ret = ret & \"&iquest;\"\n    Case \"<\":      ret = ret & \"&lt;\"\n    Case \">\":      ret = ret & \"&gt;\"\n    Case \"±\":      ret = ret & \"&plusmn;\"\n    Case \"«\":      ret = ret & \"&laquo;\"\n    Case \"»\":      ret = ret & \"&raquo;\"\n    Case \"×\":      ret = ret & \"&times;\"\n    Case \"÷\":      ret = ret & \"&divide;\"\n    Case \"¢\":      ret = ret & \"&cent;\"\n    Case \"£\":      ret = ret & \"&pound;\"\n    Case \"¤\":      ret = ret & \"&curren;\"\n    Case \"¥\":      ret = ret & \"&yen;\"\n    Case \"§\":      ret = ret & \"&sect;\"\n    Case \"©\":      ret = ret & \"&copy;\"\n    Case \"¬\":      ret = ret & \"&not;\"\n    Case \"®\":      ret = ret & \"&reg;\"\n    Case \"°\":      ret = ret & \"&deg;\"\n    Case \"µ\":      ret = ret & \"&micro;\"\n    Case \"¶\":      ret = ret & \"&para;\"\n    Case \"·\":      ret = ret & \"&middot;\"\n    Case \"¼\":      ret = ret & \"&frac14;\"\n    Case \"½\":      ret = ret & \"&frac12;\"\n    Case \"¾\":      ret = ret & \"&frac34;\"\n    Case \"¹\":      ret = ret & \"&sup1;\"\n    Case \"²\":      ret = ret & \"&sup2;\"\n    Case \"³\":      ret = ret & \"&sup3;\"\n    Case \"á\":      ret = ret & \"&aacute;\"\n    Case \"Á\":      ret = ret & \"&Aacute;\"\n    Case \"â\":      ret = ret & \"&acirc;\"\n    Case \"Â\":      ret = ret & \"&Acirc;\"\n    Case \"à\":      ret = ret & \"&agrave;\"\n    Case \"À\":      ret = ret & \"&Agrave;\"\n    Case \"å\":      ret = ret & \"&aring;\"\n    Case \"Å\":      ret = ret & \"&Aring;\"\n    Case \"ã\":      ret = ret & \"&atilde;\"\n    Case \"Ã\":      ret = ret & \"&Atilde;\"\n    Case \"ä\":      ret = ret & \"&auml;\"\n    Case \"Ä\":      ret = ret & \"&Auml;\"\n    Case \"ª\":      ret = ret & \"&ordf;\"\n    Case \"æ\":      ret = ret & \"&aelig;\"\n    Case \"Æ\":      ret = ret & \"&AElig;\"\n    Case \"ç\":      ret = ret & \"&ccedil;\"\n    Case \"Ç\":      ret = ret & \"&Ccedil;\"\n    Case \"Ð\":      ret = ret & \"&ETH;\"\n    Case \"ð\":      ret = ret & \"&eth;\"\n    Case \"é\":      ret = ret & \"&eacute;\"\n    Case \"É\":      ret = ret & \"&Eacute;\"\n    Case \"ê\":      ret = ret & \"&ecirc;\"\n    Case \"Ê\":      ret = ret & \"&Ecirc;\"\n    Case \"è\":      ret = ret & \"&egrave;\"\n    Case \"È\":      ret = ret & \"&Egrave;\"\n    Case \"ë\":      ret = ret & \"&euml;\"\n    Case \"Ë\":      ret = ret & \"&Euml;\"\n    Case \"í\":      ret = ret & \"&iacute;\"\n    Case \"Í\":      ret = ret & \"&Iacute;\"\n    Case \"î\":      ret = ret & \"&icirc;\"\n    Case \"Î\":      ret = ret & \"&Icirc;\"\n    Case \"ì\":      ret = ret & \"&igrave;\"\n    Case \"Ì\":      ret = ret & \"&Igrave;\"\n    Case \"ï\":      ret = ret & \"&iuml;\"\n    Case \"Ï\":      ret = ret & \"&Iuml;\"\n    Case \"ñ\":      ret = ret & \"&ntilde;\"\n    Case \"Ñ\":      ret = ret & \"&Ntilde;\"\n    Case \"ó\":      ret = ret & \"&oacute;\"\n    Case \"Ó\":      ret = ret & \"&Oacute;\"\n    Case \"ô\":      ret = ret & \"&ocirc;\"\n    Case \"Ô\":      ret = ret & \"&Ocirc;\"\n    Case \"ò\":      ret = ret & \"&ograve;\"\n    Case \"Ò\":      ret = ret & \"&Ograve;\"\n    Case \"º\":      ret = ret & \"&ordm;\"\n    Case \"ø\":      ret = ret & \"&oslash;\"\n    Case \"Ø\":      ret = ret & \"&Oslash;\"\n    Case \"õ\":      ret = ret & \"&otilde;\"\n    Case \"Õ\":      ret = ret & \"&Otilde;\"\n    Case \"ö\":      ret = ret & \"&ouml;\"\n    Case \"Ö\":      ret = ret & \"&Ouml;\"\n    Case \"ß\":      ret = ret & \"&szlig;\"\n    Case \"þ\":      ret = ret & \"&thorn;\"\n    Case \"Þ\":      ret = ret & \"&THORN;\"\n    Case \"ú\":      ret = ret & \"&uacute;\"\n    Case \"Ú\":      ret = ret & \"&Uacute;\"\n    Case \"û\":      ret = ret & \"&ucirc;\"\n    Case \"Û\":      ret = ret & \"&Ucirc;\"\n    Case \"ù\":      ret = ret & \"&ugrave;\"\n    Case \"Ù\":      ret = ret & \"&Ugrave;\"\n    Case \"ü\":      ret = ret & \"&uuml;\"\n    Case \"Ü\":      ret = ret & \"&Uuml;\"\n    Case \"ý\":      ret = ret & \"&yacute;\"\n    Case \"Ý\":      ret = ret & \"&Yacute;\"\n    Case \"ÿ\":      ret = ret & \"&yuml;\"\n    Case Else\n      ret = ret & Mid$(s, i, 1)\n\n    End Select\n  Next\n\n  Text2HTML = ret\n\nEnd Function\n\n\n\nFunction Path_erzeugen(ByVal Pathnamen As String, Optional CreatWarn As Boolean = True, Optional WarnOnErr As Boolean = True) As Boolean\n' Path mit mehreren Subs auf einmal erzeugen\n' Idee aus VB-Tips & Tricks in der BasicWorld\n' www.basicworld.com\n' Der optionale Parameter NoWarnOnErr wird als \"False\" interpretiert, wenn nicht vorhanden.\n' Wenn WarnOnErr = False, dann wird keine Fehlermeldungs-Messagebox ausgegeben\n' Wenn CreatWarn = True, dann wird gefragt, ob das Directory erzeugt werden soll, wenn es nicht existiert.\n' Wenn versucht wird, ein Directory anzulegen, das bereits existiert, so erfolgt keine Fehlermeldung\n\n' Declare PtrSafe Function MakePath Lib \"imagehlp.dll\" Alias _\n'    \"MakeSureDirectoryPathExists\" (ByVal lpPath As String) As Long\n\n  \nDim nix\n  \n'Pfadnamen muß immer mit einem \"\\\" enden\nIf Right(Pathnamen, 1) <> \"\\\" Then\n    Pathnamen = Pathnamen & \"\\\"\nEnd If\n\nnix = Dir(Pathnamen, vbDirectory)\n\nIf CreatWarn And Len(Nz(nix)) = 0 Then ' Pfad existiert nicht und Warnungs-MsgBox on\n    nix = MsgBox(\"Verzeichnis existiert nicht, soll es erstellt werden ?\", vbQuestion + vbYesNo, _\n                  Pathnamen)\n    If nix = vbNo Then 'Abbruch der Funktion\n        Path_erzeugen = False\n        Exit Function\n    End If\nEnd If\n        \n'Pfad erstellen\nIf MakePath(Pathnamen) = 0 Then\n    Path_erzeugen = False\n    If WarnOnErr Then\n        MsgBox \"Verzeichnis konnte nicht erstellt werden.\", vbCritical, Pathnamen\n    End If\nElse\n    Path_erzeugen = True\nEnd If\n\n    \nEnd Function\n    \n\n\nFunction Asc2Num(XZeichen As String)\n'Wandelt einen Chr-String in eine Zahl (bzw. eine numerische Zeichenfolge) um.\n'Für jeden Chr werden 3 Zeichen benötigt.\n'Autor: Klaus Oberdalhoff\n\nDim i As Integer\nDim TAsc\n\nIf Len(Nz(XZeichen)) < 1 Then\n    Exit Function\nEnd If\n\nFor i = 1 To Len(Nz(XZeichen))\n    TAsc = Asc(Mid(XZeichen, i, 1))\n    Asc2Num = Asc2Num & Right(\"000\" & TAsc, 3)\nNext i\n\nEnd Function\n\n'How can I call a Function by using a variable instead of Function Name?\n'\n' Use the Eval Function. If you pass to the Eval function a string that contains the name of a function,\n'the Eval function returns the return value of the function. For example, Eval(\"Chr$(65)\") returns \"A\".\n'\n'So for example, in the following code,  if you call fEval with \"A\" as parameter, you should get the\n'result \"Test That\", else \"Test This\".\n\n'*******Code Start*******\nFunction fEval(Status As String)\n'---Posted by Dev Ashish---\nDim strFunctionName As String\nDim X\n    If Status = \"A\" Then\n        strFunctionName = \"Eval_TestThat()\"\n    Else\n        strFunctionName = \"Eval_TestThis()\"\n    End If\n\n    fEval = Eval(strFunctionName)\nEnd Function\n\n'Testfunktion für fEval\nPrivate Function Eval_TestThis()\n    Debug.Print \"Test This\"\nEnd Function\n\n'Testfunktion für fEval\nPrivate Function Eval_testThat()\n    Debug.Print \"Test That\"\nEnd Function\n'*******Code End**********\n\n\nFunction Zeichen_lösch(Quellstr As String, Optional Leerz As String = \" \") As Variant\n'von Klaus Oberdalhoff KObd@gmx.de\n\nDim X As String, Y As String\nDim i As Integer\nDim pos1 As Integer\n\nIf Leerz = \" \" Then\n    X = Trim(Nz(Quellstr))\nElse\n    X = Nz(Quellstr)\nEnd If\n\nY = \"\"\n\nIf Len(X) > 0 Then\n    \n    For i = 1 To Len(X) Step Len(Leerz)\n        If Mid(X, i, Len(Leerz)) <> Leerz Then\n            Y = Y & Mid(X, i, Len(Leerz))\n        End If\n    Next i\nEnd If\n\nZeichen_lösch = Y\n        \nEnd Function\n\n\nFunction suchenStr(tabelle$)\n\n'diese Funktion sucht in einer Tabelle in beliebig vielen Feldern auch einen Teilstring\n'Eingabe in die Inputbox ohne Sternchen und ohne \"\n'Günther Ritter  gritter@ gmx.de\n'http://www.ostfrieslandweb.de/ kostenlose ACCESS-Beispiele\n\nDim db As DAO.Database\nDim rs As DAO.Recordset\nDim FeldCnt%, i%, strSQL$, begriff$\n\nbegriff = InputBox(\"Bitte Eingabe\")\nIf begriff = \"\" Then Exit Function\nSet db = CurrentDb\nSet rs = db.OpenRecordset(tabelle)\n\nstrSQL = \"select \" _\n    & rs.fields(0).Name _\n    & \" from \" & tabelle & \" where \" _\n    & rs.fields(0).Name _\n    & \" like '*\" & begriff & \"*'\"\n\nFor i = 1 To rs.fields.Count - 1\n    strSQL = strSQL & \" or \" & rs.fields(i).Name _\n    & \" like '*\" & begriff & \"*'\"\nNext\nrs.Close\n\nSet rs = db.OpenRecordset(strSQL, dbOpenSnapshot)\n\nIf rs.RecordCount = 1 Then\n    MsgBox \"Treffer\"\nElse\n    MsgBox \"Kein Treffer\"\nEnd If\n\nrs.Close\n\nSet db = Nothing\n\nEnd Function\n\nSub sOpenMDB(strInMDB As String)\n'--Posted by Dev Ashish---\n'\n'(Q)    How do I open another database without quitting Access?\n'\n'(A)    The best way at present is to use SendKeys for this.  Pass the new\n'mdb filename to this sub.\n\n'************ Code Start **********\n\n'This code was originally written by Dev Ashish.\n'It is not to be altered or distributed,\n'except as part of an application.\n'You are free to use it in any application,\n'provided the copyright notice is left unchanged.\n\n'============================================================\n'ACHTUNG: Es darf nichts offen sein, sonst klappt´s nicht ...\n'============================================================\n'\n'Code Courtesy of\n'Dev Ashish\n\n    On Error Resume Next\n\n'    SendKeys \"%FO\" & strInMDB & \"~\"\n'   In deutscher Version\n    SendKeys \"%Df\" & strInMDB & \"~\"\n\nEnd Sub\n\n'************ Code End **********\n\nFunction fktHideMB()\n' Gibt es eigentlich in Access die Möglichkeit, für Bildschirmpräsentationen auf\n' eine komplette Vollbild-Anzeige (ohne jegliche Access-Menüleiste oder -Titelzeile\n' umzuschalten?\n'\n'\n'Ja!\n'Die beiligende Funktion mußt du z.B. bei Aktualisierung des Forms aufrufen.\n'Durch sie werden alle Menüleisten (1) und Symbolleisten (0) versteckt.\n'!!!! Voraussetzungen beachten, sonst erscheint der Laufzeitfehler:\n'-2147467259 (80004005) ;-)\n'Was immer mir MS damit auch sagen will.\n'\n'Autor: Arndt Schönberg\n\n' Versteckt alle Befehlszeilen\n\n' Voraussetzungen:\n' 1) Jedes Formular muß eine benutzerdefinierte Menüleiste haben (die wird auch ausgeblendet)\n' 2) Beim Aufruf aus einem Makro darf KEIN Filter/Bedingung übergeben werden\n' Wenn 1+2 nicht erfüllt sind, erscheint ein (wilder) Laufzeitfehler\n\n' Wenn Filter benötigt, muß dieser durch AnwendenFilter nach dem öffnen realisiert werden\n\n' 29.10.98 Arndt Schönberg (schoenberg@offis.uni-oldenburg.de)\n\nDim befehlsLeiste\n\nFor Each befehlsLeiste In CommandBars\n  Debug.Print befehlsLeiste.Name, befehlsLeiste.Type, befehlsLeiste.BuiltIn\n  If befehlsLeiste.Type = 1 Or befehlsLeiste.Type = 0 Then\n    befehlsLeiste.Visible = False\n  End If\nNext befehlsLeiste\n\nEnd Function\n\n\nFunction AccessexePath() As String\n    AccessexePath = SysCmd(acSysCmdAccessDir)\nEnd Function\n\nFunction DefValprf(XWert As Variant) As Variant\n'Sofern man einer Variablen einen Defaultwert zuweist, und dieser Default-Wert ist eine Funktion, so wird\n'fälschlicherweise diese Funktion nicht ausgeführt, sondern z.B. Date() zurückgegeben.\n'Die Funktion Eval jedoch klappt nicht bei einem Leerwert ...\n'Mit dieser Funktion kann für DefaultValue der korrekte Wert zurückgegeben werden.\nIf Len(Trim(Nz(XWert))) > 0 Then\n    DefValprf = Eval(XWert)\nElse\n    DefValprf = \"\"\nEnd If\nEnd Function\n\n'Making MDE Files From Within MS Access 97\n' Written by Shamil Salakhetdinov\n' e-mail: shamil@marta.darts.spb.ru\n' Shamil M. Salakhetdinov, Darts Ltd. of St. Petersburg RU.\n'*-\n\nPublic Function smsMakeMde(ByVal vstrDstMdbPath As String, _\n                            ByVal vstrDstFileName As String, _\n                            Optional ByRef robjAcc As Access.Application = Nothing) As Boolean\n    \n    On Error GoTo smsMakeMde_Err\n\n    smsMakeMde = False\n\n    Dim objAcc As Access.Application\n\n    If Not robjAcc Is Nothing Then\n        Set objAcc = robjAcc\n    Else\n        Set objAcc = New Access.Application\n    End If\n\n    objAcc.RefreshTitleBar\n\n    DoEvents\n\n    objAcc.Visible = True\n    DoEvents\n\n    SendKeys vstrDstMdbPath & vstrDstFileName & \".mdb\"\n    SendKeys \"{Enter}\"\n    SendKeys vstrDstMdbPath & vstrDstFileName\n    SendKeys \"{Enter}\"\n\n    objAcc.DoCmd.RunCommand acCmdMakeMDEFile\n    DoEvents\n    objAcc.Visible = False\n\n    smsMakeMde = True\n\nsmsMakeMde_exit:\n    If robjAcc Is Nothing Then\n       objAcc.Quit\n    End If\n    Set objAcc = Nothing\n    Exit Function\nsmsMakeMde_Err:\n    MsgBox \"smsMakeMde: \" & err.Number & \" - \" & err.description\n    Resume smsMakeMde_exit\nEnd Function\n\n\n\nFunction Konv_MDE(strMDBFile As String, strMDEFile As String) As Integer\n'Beachte:\n'Voller Pfad für MDB und MDE, Name kann gleich sein.\n'Es funktioniert NICHT aus der MDB selbst, Du musst das Modul extra in\n'eine DB schreiben, damit das \"von aussen\" geschieht.\n'Ausführung im Testfenster.\n\n'Making MDE Files From Within MS Access 97\n'Undocumented function, use carefully and at your own risc !!!\n'Karsten Brocksieper, IMG mbH of Hannover DE.\n    ' Error Handling\n    On Error GoTo Err_Konv_MDE\n\n    ' Compile\n    SysCmd 603, strMDBFile, strMDEFile\n\n    ' No Error !\n    Konv_MDE = True\n\nExit_Konv_MDE:\n\n   Exit Function\n\nErr_Konv_MDE:\n\n    ' Error !!!\n    Konv_MDE = False\n    MsgBox err.description\n    Resume Exit_Konv_MDE\n\nEnd Function\n\n\nFunction smsDisablePulldownMenuEntry(parMenuBarName As String, _\nparEntryName As String) As Integer\n' Written by Shamil Salakhetdinov\n' e-mail: shamil@marta.darts.spb.ru\n'Shamil M. Salakhetdinov, Darts Ltd. of St. Petersburg RU.\n\nOn Error GoTo smsDisablePulldownMenuEntry_Err\n    CommandBars(\"Menu Bar (custom)\").controls(parMenuBarName). _\n    CommandBar.controls(parEntryName).Enabled = False\n    \n    smsDisablePulldownMenuEntry = True\n\nsmsDisablePulldownMenuEntry_Done:\n    Exit Function\n\nsmsDisablePulldownMenuEntry_Err:\n    Resume smsDisablePulldownMenuEntry_Done\n    \nEnd Function\n\n\nSub AlterFieldType(tblname As String, fieldName As String, NewDataType As String)\n' The AlterFieldType Sub procedure requires three string\n' parameters. The first string specifies the name of the table\n' containing the field to be changed. The second string specifies\n' the name of the field to be changed. The third string specifies\n' the new data type for the field.\n'gefunden in der CRSOFT mdb\nDim db As DAO.Database\nDim qdf As QueryDef\nSet db = CurrentDb()\n' Create a dummy QueryDef object.\nSet qdf = db.CreateQueryDef(\"\", \"Select * from PROD1\")\n' Add a temporary field to the table.\nqdf.sql = \"ALTER TABLE [\" & tblname & \"] ADD COLUMN AlterTempField \" & NewDataType\nqdf.Execute\n' Copy the data from old field into the new field.\nqdf.sql = \"UPDATE DISTINCTROW [\" & tblname & \"] SET_AlterTempField = [\" & fieldName & \"]\"\nqdf.Execute\n' Delete the old field.\nqdf.sql = \"ALTER TABLE [\" & tblname & \"] DROP COLUMN [\" & fieldName & \"]\"\nqdf.Execute\n' Rename the temporary field to the old field's name.\ndb.TableDefs(\"[\" & tblname & \"]\").fields(\"AlterTempField\").Name = fieldName\n' Clean up.\nEnd Sub\n\nFunction ReverseString(MyString As String)\n'gefunden in der CRSOFT mdb\n' \"Regen\" wird als \"negeR\" ausgegeben\nDim StringReversed As String\nDim MyStringLength As Integer, X\nMyStringLength = Len(MyString)\nFor X = 1 To MyStringLength\n    StringReversed = Mid(MyString, X, 1) & StringReversed\nNext X\nReverseString = StringReversed\nEnd Function\n\n\nFunction EnableControls(frm As Form, intSection As Integer, intState As Boolean) As Boolean\n'  Enable or disable controls in specified section of form.\n'  Use the Form object, section constant and state arguments\n'  passed to the EnableControls procedure.\n'gefunden in der CRSOFT mdb\n'\n'Section Konstante          Beschreibung\n'\n'0   acDetail               Formulardetailbereich oder Berichtsdetailbereich\n'1   acHeader               Formular- oder Berichtskopfbereich\n'2   acFooter               Formular- oder Berichtsfußbereich\n'3   acPageHeader           Formular- oder Berichtsseitenkopfbereich\n'4   acPageFooter           Formular- oder Berichtsseitenfußbereich\n'5   acGroupLevel1Header    Gruppenebene 1 Kopfbereich (nur Berichte)\n'6   acGroupLevel1Footer    Gruppenebene 1 Fußbereich (nur Berichte)\n'7   acGroupLevel2Header    Gruppenebene 2 Kopfbereich (nur Berichte)\n'8   acGroupLevel2Footer    Gruppenebene 2 Fußbereich (nur Berichte)\n'\nDim ctl As control\n'  Set intState for all controls in specified section.\nFor Each ctl In frm.controls\n    If ctl.Section = intSection Then\n    On Error Resume Next\n    ctl.Enabled = intState\n    err = 0\n    End If\nNext ctl\nEnableControls = True\nEnd Function\n\nFunction HideForm() As Integer\n'gefunden in der CRSOFT MDB\nOn Error GoTo HideForm_Err\n' Hide current form\nScreen.ActiveForm.Visible = False\nExitHideForm:\n    Exit Function\nHideForm_Err:\n    MsgBox \"HideForm: \" & err & \" - \" & err.description, vbInformation\n    Resume ExitHideForm\nEnd Function\n\nFunction GetLineNumber(f As Form, KeyName As String, KeyValue)\n' The following function is used by the subfrmLineNumber form\n'gefunden in der CRSOFT MDB\nDim rs As DAO.Recordset\nDim CountLines\nOn Error GoTo Err_GetLineNumber\nSet rs = f.RecordsetClone\n' Find the current record.\nSelect Case rs.fields(KeyName).Type\n' Find using numeric data type key value?\nCase DB_INTEGER, DB_LONG, DB_CURRENCY, DB_SINGLE, DB_DOUBLE, DB_BYTE\n    rs.FindFirst \"[\" & KeyName & \"] = \" & KeyValue\n    ' Find using date data type key value?\nCase DB_DATE\n    rs.FindFirst \"[\" & KeyName & \"] = #\" & KeyValue & \"#\"\n    ' Find using text data type key value?\nCase DB_TEXT\n    rs.FindFirst \"[\" & KeyName & \"] = '\" & KeyValue & \"'\"\nCase Else\n    MsgBox \"ERROR: Invalid key field data type!\"\nExit Function\nEnd Select\n' Loop backward, counting the lines.\nDo Until rs.BOF\nCountLines = CountLines + 1\nrs.MovePrevious\nLoop\nBye_GetLineNumber:\n    ' Return the result.\n    GetLineNumber = CountLines\n    Exit Function\nErr_GetLineNumber:\n    CountLines = 0\n    Resume Bye_GetLineNumber\nEnd Function\n\n\nFunction RunSum(f As Form, KeyName As String, KeyValue, FieldToSum As String)\n'gefunden in der CRSOFT MDB\n' FUNCTION: RunSum()\n' PURPOSE:  Compute a running sum on a form.\n' PARAMETERS:\n'    F        - The form containing the previous value to\n'               retrieve.\n'    KeyName  - The name of the form's unique key field.\n'    KeyValue - The current record's key value.\n'    FieldToSum - The name of the field in the previous\n'                 record containing the value to retrieve.\n' RETURNS:  A running sum of the field FieldToSum.\n' EXAMPLE:  =RunSum(Form,\"ID\",[ID],\"Amount\")\nDim rs As DAO.Recordset\nDim result\nOn Error GoTo Err_RunSum\n' Get the form Recordset.\nSet rs = f.RecordsetClone\n' Find the current record.\nSelect Case rs.fields(KeyName).Type\n' Find using numeric data type key value?\nCase DB_INTEGER, DB_LONG, DB_CURRENCY, DB_SINGLE, DB_DOUBLE, DB_BYTE\n    rs.FindFirst \"[\" & KeyName & \"] = \" & KeyValue\n' Find using date data type key value?\nCase DB_DATE\n    rs.FindFirst \"[\" & KeyName & \"] = #\" & KeyValue & \"#\"\n' Find using text data type key value?\nCase DB_TEXT\n    rs.FindFirst \"[\" & KeyName & \"] = '\" & KeyValue & \"'\"\nCase Else\n    MsgBox \"ERROR: Invalid key field data type!\"\n    GoTo Bye_RunSum\nEnd Select\n' Compute the running sum.\nDo Until rs.BOF\n    result = result + rs(FieldToSum)\n    ' Move to the previous record.\n    rs.MovePrevious\nLoop\nBye_RunSum:\n    RunSum = result\n    Exit Function\nErr_RunSum:\n         Resume Bye_RunSum\nEnd Function\n\n'-------------------------------\n'von Karl Donaubauer\nFunction KillAllForms()\n\nDim db As DAO.Database\nDim doc As Document\nSet db = CurrentDb\n\nFor Each doc In db.Containers!Forms.Documents\n    DoCmd.DeleteObject acForm, doc.Name\nNext\n\nEnd Function\n'-------------------------------\n\nFunction SAnzahl(s As String, a As String) As Integer\n'\n'               Funktion von Sascha Wostmann, s.w@gmx.de\n'\n' zählt die Vorkommen von A in S und liefert die Anzahl zurück\n' Diese Funktion wird von \"selektiere\" (s.u.) aufgerufen, also\n' nicht löschen, wenn selektiere benutzt wird!\n'\n' z.B.\n'      SAnzahl(\"abc-def-ghi-jkl\",\"-\") = 3\n'      SAnzahl(\"Saschas Spass\",\"as\") = 3\n'\nDim ret As Integer\nDim t As String\n\n    ret = 0\n    t = s\n    Do While InStr(t, a)\n        ret = ret + 1\n        t = Mid$(t, InStr(t, a) + 1)\n    Loop\n    \n    SAnzahl = ret\nEnd Function\n\n\nFunction selektiere(ByVal s As String, ByVal i As Integer, ByVal a As String) As String\n'\n'               Funktion von Sascha Wostmann, s.w@gmx.de\n'\n' Selektiert im String S den i-ten Teil. Trennzeichen ist in A.\n' Bei Fehlern (z.B. nicht genug Trennzeichen im String) wird \"\"\n' geliefert\n'\n' z.B.\n' String mit Trennzeichen\n' (\"suche den zweiten Teil, wenn '-' die Teile trennt\")\n'      selektiere(\"abc-def-ghi-jkl\",2,\"-\") = \"def\"\n'      selektiere(\"abc-def,ghi-jkl\",2,\"-\") = \"def,ghi\"\n'\n' Suche vom Ende nach vorne\n' (\"suche den zweitletzten Teil\")\n'      selektiere(\"abc-def-ghi-jkl\",-2,\"-\") = \"ghi\"\n'\n' mehrere Trennzeichen\n' (\"suche den zweiten Teil, wenn der String ', ' die Teile trennt\")\n'      selektiere(\"Bonn, Köln, Bremen, Düsseldorf\",2,\", \") = \"Köln\"\n'\nDim ret As String\n\nDim s1 As Integer\nDim s2 As Integer   ' Stellen, an denen der String getrennt wird\n\n    selektiere = \"\"\n    ' Sonderfall i<0 bedeutet, ich will den i.letzten Teilstring\n    If i < 0 Then\n        i = SAnzahl(s, a) + i + 2\n    End If\n    \n    ' i muß (nach obiger Anpassung) größer als Null sein\n    If i <= 0 Then Exit Function\n    s2 = -Len(a) + 1\n    Do\n        s1 = s2 + Len(a)\n        s2 = InStr(s1, s, a)\n        \n        ' InStr gibt Null zurück, wenn Suchstring nicht gefunden wird\n        If s2 = 0 Then s2 = Len(s) + 1\n        i = i - 1\n    Loop Until i = 0\n\n    ' s1 ist dann größer als s2, wenn ein Teil selektiert\n    ' werden soll, der gar nicht mehr in der Zeile existiert\n    ' (z.B. das 5. von 4 Feldern)\n    If s1 > s2 Then Exit Function\n    \n    ' Rückgabewert ist der Teilstring zwischen s1 und s2\n    ret = Mid$(s, s1, s2 - s1)\n    If Left$(ret, 1) = Chr$(34) Then ret = Mid$(ret, 2)\n    If Right$(ret, 1) = Chr$(34) Then ret = Left$(ret, Len(ret) - 1)\n    \n    selektiere = ret\nEnd Function\n\nPublic Function LetztZeilen(Ganz, LZeilen)\n'In einem Bericht sollen immer die letzten 5-10 Zeilen von einem Memofeld\n'gedruckt werden. Wie kann ich dies einfach anstellen.\n\n'Vielleicht geht 's ja einfacher, aber ich würde es mit einer Funktion lösen.\n\n'In der Abfrage, die als Datenherkunft deines Berichtes dient,\n'schreibst du in eine Spalte den Aufruf:\n'\n'LetztZeilen([DeinFeld];5)\n'\n'Damit bekommst du z.B. die letzten 5 Zeilen des Feldes.\n\n'Achtung, wenn der Anwender kein \"hartes\" <Return> eingegeben hat, wird\n'der ganze Schmonzes zurückgegeben.\n'******************** CODE START **********************\n' gibt die letzten LZeilen eines Feldes zurück\n' von Karl Donaubauer 2.1.1999\n\nIf IsNull(Ganz) Or IsNull(LZeilen) Then Exit Function\nDim i As Integer, j As Integer\ni = 1\nDo Until InStr(i, Ganz, vbCrLf) = 0\n    i = InStr(i, Ganz, vbCrLf) + 1\n    j = j + 1\nLoop\nIf j >= LZeilen Then\n    i = 1\n    For j = 0 To j - LZeilen\n        i = InStr(i, Ganz, vbCrLf) + 1\n    Next j\n    LetztZeilen = Mid(Ganz, i + 1)\nElse\n    LetztZeilen = Ganz\nEnd If\nEnd Function\n'******************** CODE ENDE **********************\n\nSub ApplSetSub()\n'Options für Runtime-Umgebung setzen\n\n    Application.SetOption \"Confirm Record Changes\", False\n    Application.SetOption \"Confirm Document Deletions\", False\n    Application.SetOption \"Confirm Action Queries\", False\n    Application.SetOption \"Show Hidden Objects\", False\n    Application.SetOption \"Show System Objects\", False\n    Application.SetOption \"Show Status Bar\", True\n    Application.SetOption \"Arrow Key Behavior\", 1\n    Application.SetOption \"Move After Enter\", 1\n    Application.SetOption \"Cursor Stops at First/Last Field\", True\n    Application.SetOption \"Default Record Locking\", 0\n    Application.SetOption \"Default Open Mode for Databases\", 0\n    Application.SetOption \"Ignore DDE Requests\", True\n\nEnd Sub\n\n\nFunction ReplaceStr(Textin, SearchStr, Replacement, Optional CompMode As Integer = 2)\n'\n' Replaces the SearchStr string with Replacement string in the TextIn string.\n' Uses CompMode to determine comparison mode\n' Aus der Neatcd97.mdb Microsoft\n'\nDim WorkText As String, Pointer As Integer\n  If IsNull(Textin) Then\n    ReplaceStr = Null\n  Else\n    WorkText = Textin\n    Pointer = InStr(1, WorkText, SearchStr, CompMode)\n    Do While Pointer > 0\n      WorkText = Left(WorkText, Pointer - 1) & Replacement & Mid(WorkText, Pointer + Len(SearchStr))\n      Pointer = InStr(Pointer + Len(Replacement), WorkText, SearchStr, CompMode)\n    Loop\n    ReplaceStr = WorkText\n  End If\nEnd Function\n\nFunction CRtoASCII(Textin) As Variant\n' Ersetzen aller CRLF durch den String $%&CRLF%&\n'Rückgabe als Variant, um einen NullString übergeben zu können, im Falle\n'\"AllowZeroLength\" auf False gesetzt ist\n    Dim suche As String\n    On Error Resume Next\n    CRtoASCII = Null\n    If Len(Trim(Nz(Textin))) > 0 Then\n        suche = CStr(Chr(13) & Chr(10))\n        CRtoASCII = Nz(ReplaceStr(Nz(Textin), suche, \"$%&CRLF%&\"))\n    End If\nEnd Function\n\nFunction ASCIItoCR(Textin) As Variant\n' Ersetzen aller Strings $%&CRLF%& durch CRLF\n'Rückgabe als Variant, um einen NullString übergeben zu können, im Falle\n'\"AllowZeroLength\" auf False gesetzt ist\n    Dim Erse As String\n    On Error Resume Next\n    ASCIItoCR = Null\n    If Len(Trim(Nz(Textin))) > 0 Then\n        Erse = CStr(Chr(13) & Chr(10))\n        ASCIItoCR = ReplaceStr(Nz(Textin), \"$%&CRLF%&\", Erse)\n    End If\nEnd Function\n\n\nFunction LFtoCRLF(Textin) As Variant\n    Dim Erse As String\n    On Error Resume Next\n    LFtoCRLF = Null\n    If Len(Trim(Nz(Textin))) > 0 Then\n        LFtoCRLF = ReplaceStr(Nz(Textin), Chr(10), Chr(13) & Chr(10))\n    End If\nEnd Function\n\n\nPublic Function pfadkuerzen(pfad As String, Optional linksstart As Integer = 30, Optional rechtsstart As Integer = 40, Optional sTrenner As String = \"\\\") As String\n'Autor: Thomas Klahr - www.freeaccess.de - klahr@freeaccess.de\nDim temp\nDim sTrennPkt As String\nDim links, rechts As String\n'linksstart = 30 ' Gibt an ab welchem Zeichen er von links nach / sucht, und kürzt danach\n'rechtsstart = 40 ' Gibt an ab welchem Zeichen er von rechts nach / sucht, und kürzt davor\n'Die Länge des resultierenden Strings beträgt also im Mittel\n'linksstart + rechtsstart + 4(für den Platzhalter \".../\")\n\nsTrennPkt = \"...\" & sTrenner\n\nIf Len(Nz(pfad, \"\")) < (linksstart + rechtsstart + 4) Then\n    pfadkuerzen = pfad\n    Exit Function\nElse\n    Do Until InStr(linksstart, pfad, sTrenner) <> 0\n        linksstart = linksstart + 1\n    Loop\n    Do Until InStr(Len(pfad) - rechtsstart, pfad, sTrenner) <> 0\n        rechtsstart = rechtsstart + 1\n    Loop\n    links = Left$(pfad, InStr(linksstart, pfad, sTrenner))\n    'Pfad = Right$(Pfad, Len(Pfad) - InStr(linksstart, Pfad, sTrenner))\n    rechts = Right$(pfad, Len(pfad) - InStr(Len(pfad) - rechtsstart, pfad, sTrenner))\n    pfadkuerzen = links & sTrennPkt & rechts\nEnd If\nEnd Function\n\nFunction Proper(X)\n' Funktion aus der Neatcd97.mdb von MS\n'  Capitalize first letter of every word in a field.\n'  Use in an event procedure in AfterUpdate of control;\n'  for example, [Last Name] = Proper([Last Name]).\n'  Names such as O'Brien and Wilson-Smythe are properly capitalized,\n'  but MacDonald is changed to Macdonald, and van Buren to Van Buren.\n'  Note: For this function to work correctly, you must specify\n'  Option Compare Database in the Declarations section of this module.\n'\n'  See Also: StrConv Function in the Microsoft Access 97 online Help.\n\nDim temp$, c$, OldC$, i As Integer\n  If IsNull(X) Then\n    Exit Function\n  Else\n    temp$ = CStr(LCase(X))\n    '  Initialize OldC$ to a single space because first\n    '  letter needs to be capitalized but has no preceding letter.\n    OldC$ = \" \"\n    For i = 1 To Len(temp$)\n      c$ = Mid$(temp$, i, 1)\n      If c$ >= \"a\" And c$ <= \"z\" And (OldC$ < \"a\" Or OldC$ > \"z\") Then\n        Mid$(temp$, i, 1) = UCase$(c$)\n      End If\n      OldC$ = c$\n    Next i\n    Proper = temp$\n  End If\nEnd Function\n\n\n\nFunction Uml2Win(ByVal X As String, ASC2WIN As Boolean) As Variant\n''**********************************************************************************\n'' Deklarationen\n''**********************************************************************************\n' ' PC (DOS) --> Ansi (Win)\n'  Declare PtrSafe Function OemToChar Lib \"user32\" Alias \"OemToCharA\" (ByVal lpszSrc As String, ByVal lpszDst As String) As Long\n' ' Ansi (Win) --> PC (DOS)\n'  Declare PtrSafe Function CharToOem Lib \"user32\" Alias \"CharToOemA\" (ByVal lpszSrc As String, ByVal lpszDst As String) As Long\n''**********************************************************************************\n'' Aufruf:\n''  DOS --> Win\n''  Ergebnis = Uml2Win(DeinString, True)\n''  Win --> DOS\n''  Ergebnis = Uml2Win(DeinString, False)\n\nDim nix, xx As String\nUml2Win = Null\nIf Len(Trim(Nz(X))) > 0 Then\n    X = X & Chr(0)\n    xx = Space(Len(X))\n    If ASC2WIN = True Then\n        nix = OemToChar(X, xx)\n    Else\n        nix = CharToOem(X, xx)\n    End If\n    If Right(xx, 1) = Chr(0) Then\n        Uml2Win = Left(xx, Len(xx) - 1)\n    Else\n        Uml2Win = xx\n    End If\nEnd If\nEnd Function\n\n\nFunction HexStr(AscString As String) As String\n'Ausgabe \"ÄÖÜ\" als \"C4 D6 DC\"\nDim i As Integer\nHexStr = \"\"\nIf Len(Trim(Nz(AscString))) = 0 Then Exit Function\nFor i = 1 To Len(AscString)\n    HexStr = HexStr & Hex(Asc(Mid(AscString, i, 1))) & \" \"\nNext i\nHexStr = Trim(HexStr)\nEnd Function\n\nFunction UnHexStr(HexString As String) As String\n'Ausgabe \"C4 D6 DC\" als \"ÄÖÜ\" - HexStr rückwärts ...\nDim i As Integer\nUnHexStr = \"\"\nIf Len(Trim(Nz(HexString))) = 0 Then Exit Function\nFor i = 1 To Len(HexString) Step 3\n    UnHexStr = UnHexStr & Chr$(\"&H\" & Trim(Mid(HexString, i, 3)))\nNext i\nEnd Function\n\nFunction DabaEinAus(Optional Einblenden As Boolean = True)\n'Datenbankfenster ein/ausblenden\n'Autor: Karl Donaubauer (FAQ)\n'Rückgabe True / False, True bei erfolgreicher Ausführung der Function\nOn Error GoTo DabaEinAus_err\nDabaEinAus = True\nIf Einblenden Then\n    'Einblenden:\n    DoCmd.SelectObject acTable, , True\nElse\n    'Ausblenden:\n    DoCmd.SelectObject acTable, , True\n    RunCommand acCmdWindowHide\nEnd If\nExit Function\nDabaEinAus_err:\nDabaEinAus = False\nEnd Function\n\n\nFunction OpenMacro(macroName As String) As Boolean\n'Autoren: Christa Schwanke UND Karl Donaubauer\nOn Error GoTo OpenMacro_Err\n\nIf Len(Trim(Nz(macroName))) = 0 Then\n    OpenMacro = False\n    Exit Function\nEnd If\nDoCmd.SelectObject acMacro, macroName, True\n'Geht leider nicht anders\nSendKeys \"^~\", True\nOpenMacro = True\nExit Function\n\nOpenMacro_Err:\nOpenMacro = False\n\nEnd Function\n\nPublic Function SafeSQLString(Text As Variant) As Variant\nOn Error GoTo Err_SafeSQLString\n    Const Quote = \"\"\"\"      ' That's 4 quotation marks in a row.\n          \n    If IsNull(Text) Then\n        SafeSQLString = Quote & Quote\n    Else\n        If Not (Left(Text, 1) = \"\"\"\" And Right(Text, 1) = \"\"\"\") Then\n            SafeSQLString = Quote & ReplaceStr(Text, Quote, Quote & Quote) & Quote\n        Else\n            SafeSQLString = Text\n        End If\n    End If\n          \nExit_SafeSQLString:\n    Exit Function\n          \nErr_SafeSQLString:\n    SafeSQLString = \"\"\n    Resume Exit_SafeSQLString\n          \nEnd Function\n\n\nFunction SystemMdwPath() As String\n    SystemMdwPath = DBEngine.SystemDB\nEnd Function\n\n\nFunction RandomWert(Optional ByVal IPwd_lng As Byte = 10, Optional iTextTyp As Long = 0) As String\n'Texttyp = 0 Alle (33 bis 126)\n'Texttyp = 1 Nur Zahl (48 - 57)\n'Texttyp = 2 Nur Großbuchstaben (65 - 90)\n'Texttyp = 3 Nur Kleinbuchstaben (97 - 122)\n\nDim Obergrenze As Integer\nDim Untergrenze As Integer\nDim Wert1 As Integer\n\nDim i As Integer\nDim strx As String\nstrx = \"\"\n\n' Verwenden Sie die folgende Formel, um ganzzahlige Zufallszahlen innerhalb eines bestimmten\n' Bereichs zu erzeugen:\n' Wert1 = Int((Obergrenze - Untergrenze + 1) * Rnd + Untergrenze)\n' Obergrenze steht hier für die größte Zahl des Bereichs und Untergrenze für die kleinste Zahl des Bereichs.\n\nSelect Case iTextTyp\n\n    Case 1\n        Untergrenze = 48\n        Obergrenze = 57\n\n    Case 2\n        Untergrenze = 65\n        Obergrenze = 90\n\n    Case 3\n        Untergrenze = 97\n        Obergrenze = 122\n\n    Case Else\n        Untergrenze = 33 ' Ascii-Wert 33\n        Obergrenze = 126 ' Ascii-Wert 126\n\nEnd Select\n\n'Es werden alle Zeichen zwischen Dec. 33 und 126 wahlfrei erzeugt\nRandomize\n\nFor i = 1 To IPwd_lng\n    Wert1 = Int((Obergrenze - Untergrenze + 1) * Rnd + Untergrenze)\n    strx = strx & Chr$(Wert1)\nNext i\n\nRandomWert = strx\n\nEnd Function\n\nFunction RandomPasswort(Optional ByVal IPwd_lng As Byte = 10, Optional Dummywert As Variant) As String\n\nDim Obergrenze As Integer\nDim Untergrenze As Integer\nDim Wert1 As Integer\n\n' Bei Abfragen immer die ID des Datensatzes als Dummy mit übergeben, da nur dann der\n' Access-Optimierer (überlistet wird und) die Abfrage für jede Zeile widerholt ausführt\n\nIf IPwd_lng < 5 Or IPwd_lng > 12 Then IPwd_lng = 10\n\nDim i As Integer\nDim strx As String\nstrx = \"\"\n\n'Dim Obergrenze As Integer\n'Dim Untergrenze As Integer\n\n' Verwenden Sie die folgende Formel, um ganzzahlige Zufallszahlen innerhalb eines bestimmten Bereichs zu erzeugen:\n' Wert1 = Int((Obergrenze - Untergrenze + 1) * Rnd + Untergrenze)\n' Obergrenze steht hier für die größte Zahl des Bereichs und Untergrenze für die kleinste Zahl des Bereichs.\n\nObergrenze = 126 ' Ascii-Wert 126\nUntergrenze = 33 ' Ascii-Wert 33\n\n'Es werden alle Zeichen zwischen Dec. 33 und 127 wahlfrei erzeugt\nRandomize\n\nFor i = 1 To IPwd_lng\n    Wert1 = Int((Obergrenze - Untergrenze + 1) * Rnd + Untergrenze)\n    strx = strx & Chr$(Wert1)\nNext i\n\nRandomPasswort = strx\n\nEnd Function\n\nFunction RndLongWert(Optional Untergrenze As Long = 0, Optional Obergrenze As Long = 6, Optional Dummywert As Variant) As Long\n\n' Bei Abfragen immer die ID des Datensatzes als Dummy mit übergeben, da nur dann der\n' Access-Optimierer (überlistet wird und) die Abfrage für jede Zeile widerholt ausführt\n\n'Dim Obergrenze As Integer\n'Dim Untergrenze As Integer\n\n' Verwenden Sie die folgende Formel, um ganzzahlige Zufallszahlen innerhalb eines bestimmten Bereichs zu erzeugen:\n' Wert1 = Int((Obergrenze - Untergrenze + 1) * Rnd + Untergrenze)\n' Obergrenze steht hier für die größte Zahl des Bereichs und Untergrenze für die kleinste Zahl des Bereichs.\n\n'Obergrenze = 126 ' Ascii-Wert 126\n'Untergrenze = 33 ' Ascii-Wert 33\n\n'Es werden alle Zeichen zwischen Dec. 33 und 127 wahlfrei erzeugt\n\nRandomize\n\nRndLongWert = Int((Obergrenze - Untergrenze + 1) * Rnd + Untergrenze)\n\nEnd Function\n\n\n\nPublic Function ValidFilename(Name As String, Optional char As String) As Boolean\n    On Error Resume Next\n    Dim NotAllowed\n    NotAllowed = Array(\"<\", \">\", \":\", \"/\", \"\\\", \"|\", Chr(34), \"'\", \"CON\", _\n        \"PRN\", \"AUX\", \"CLOCK$\", \"NUL\", \"COM1\", \"COM2\", \"COM3\", \"COM4\", \"COM5\", _\n        \"COM6\", \"COM7\", \"COM8\", \"COM9\", \"LPT1\", \"LPT2\", \"LPT3\", \"LPT4\", _\n        \"LPT5\", \"LPT6\", \"LPT7\")\n    ValidFilename = True\n    Dim i As Integer\n    Dim s As String\n    For i = 0 To 7\n        If InStr(Name, NotAllowed(i)) Then\n            ValidFilename = False\n            char = NotAllowed(i)\n            Exit Function\n        End If\n    Next i\n    i = InStrRev(Name, \".\")\n    s = Mid(Name, 1, i - 1)\n    For i = 8 To 28\n        If NotAllowed(i) = UCase(s) Or UCase(Name) = NotAllowed(i) Then\n            ValidFilename = False\n            char = NotAllowed(i)\n            Exit Function\n        End If\n    Next i\n\nEnd Function\n\nFunction mdbVersion(strDB_file As String) As String\n\n' Currentdb.Properties(\"AccessVersion\")\n' liefert ebenfalls die Access-Version der MDB\n\n    Const VERSION_STRING_SIZE As Integer = 24\n    Const JET_2_VERSION_NUMBER_START As Integer = 1\n    Const JET_VERSION_NUMBER_START As Integer = 21\n    Const Length As Integer = 1\n\n    Dim lngSource As Integer\n    Dim strData As String\n    \n    If Len(Trim(Nz(strDB_file))) > 0 Then\n        If Len(Dir(strDB_file)) = 0 Then\n            mdbVersion = \"no valid File\"\n            Exit Function\n        End If\n    Else\n        mdbVersion = \"no File\"\n        Exit Function\n    End If\n        \n    lngSource = FreeFile\n    Open strDB_file For Binary As lngSource\n    strData = Space(VERSION_STRING_SIZE)\n    Get #lngSource, , strData\n    Close lngSource\n    \n    If Chr(1) = Mid(strData, JET_2_VERSION_NUMBER_START, _\n       Length) Then\n        mdbVersion = \"Access 2\"\n    ElseIf Chr(0) = Mid(strData, JET_VERSION_NUMBER_START, _\n       Length) Then\n        mdbVersion = \"Access 97\"\n    ElseIf Chr(1) = Mid(strData, JET_VERSION_NUMBER_START, _\n       Length) Then\n        mdbVersion = \"Access 2000/2002\"\n    Else\n        mdbVersion = \"Unknown\"\n    End If\n                \nEnd Function\n\n'**************************************\n' Name: [Ace] WinzipIT\n' Description:Simple code to zip/unzip w\n'     ith Winzip\n' By: renyi[ace]\n'\n' Inputs:'Example:\n'source = app.path & \"source.exe\"\n'target = app.path & \"target.zip\"\n'zip = true (compress)\n'zip = false(uncompress)\n'\n' Assumes:that you have winzip, :)\n'\n' Side Effects:'I'm having problem with\n'     windows path.\n'winzip doesn't recognize spaces, :(\n'anyone got ideas ? pls mail me.........\n'     .\n'\n'This code is copyrighted and has' limited warranties.Please see http://w\n'     ww.Planet-Source-Code.com/xq/ASP/txtCode\n'     Id.14063/lngWId.1/qx/vb/scripts/ShowCode\n'     .htm'for details.'**************************************\n\n'---------\n'WinZipIT\n'---------\n\n\n'Function winZipit(ByVal source As String, ByVal target As String, ByVal Zip As Boolean)\n'    zipIT = App.Path & \"winzip32 -a\"\n'    unzipIT = App.Path & \"winzip32 -e \"\n'\n'\n'    If Zip = True Then\n'        Shell (zipIT & target & source)\n'    Else: Shell (unzipIT & target & source)\n'    End If\n'End Function\n\n\n''**************************************\n'' Name: About the \"Compressing Files thr\n''     u VB(w/WinZip)\"\n'' Description:this is actually not a cod\n''     e but this is just a list of parameters\n''     to use WinZip in VB.. I hope this will h\n''     elp those who are interested in my previ\n''     ous posting namely: \"Compressing Files t\n''     hru VB(w/WinZip)\"\n'' By: Jaeger\n''\n'' Assumes:you have read my previous post\n''     ing.. the \"Compressing Files thru VB(w/W\n''     inZip)\"\n''\n''This code is copyrighted and has' limited warranties.Please see http://w\n''     ww.Planet-Source-Code.com/xq/ASP/txtCode\n''     Id.4696/lngWId.1/qx/vb/scripts/ShowCode.\n''     htm'for details.'**************************************\n'\n'Adding Files:\n'The command format is:\n'winzip[32].exe [-min] action [options] filename[.zip] files\n'where:\n'-min specifies that WinZip should run minimized. If -min is specified,\n'it must be the first command line parameter.\n'Action\n'-a For add, -f for freshen, -u for update, and -m for move. These\n'actions correspond To the actions described In the section titled\n'\"Adding files To an Archive\" in the online manual.\n'Options\n'-r and -p correspond To the \"Recurse Directories\" and \"Save Extra\n'Directory Info\" checkboxes in the Add and Drop dialog boxes. -ex, -en,\n'-ef, -es, and -e0 options determine the compression method: eXtra,\n'Normal, Fast, Super fast, and no compression. The default is \"Normal\".\n'-s allows specification of a password. The password can be enclosed\n'In quotes, For example, -s\"Secret Password\". Note that passwords are\n'case-sensitive.\n'-hs option allows hidden and system files To be included.\n'FileName.zip\n'Specifies the name of the ZIP involved. Be sure To use the full\n'filename (including the directory).\n'Files\n'Is a list of one or more files, or the @ character followed by the\n'filename containing a list of files To add, one filename per line.\n'Wildcards (e.g. *.bak) are allowed.\n'Extracting Files:\n'The command format is:\n'winzip[32].exe -e [options] filename[.zip] directory\n'where:\n'-e Is required.\n'Options\n'-o and -j stand For \"Overwrite existing files without prompting\" and\n'\"Junk pathnames\", respectively. Unless -j is specified, directory\n'information is used.\n'-s allows specification of a password. The password can be enclosed\n'In quotes, For example, -s\"Secret Password\". Note that passwords are\n'case-sensitive.\n'FileName.zip\n'Specifies the name of the ZIP involved. Be sure To specify the full\n'filename (including the directory).\n'directory\n'Is the name of the directory to which the files are extracted. If the\n'directory does Not exist it is created.\n'Notes:\n'* VERY IMPORTANT: Always specify complete filenames, including the full\n'path name and drive letter, For all file IDs.\n'* To run WinZip in a minimized inactive icon use the \"-min\" option.\n'When specified this option must be the first option.\n'* Only operations involving the built-in zip and unzip are supported.\n'* Enclose Long filenames on the command line in quotes.\n'* NO leading or trailing blanks, or blank lines For readability, are\n'allowed In list (\"@\") files.\n'* The action and Each option on the command line must be separated\n'from the others by at least one space.\n'* WinZip can be used To compress files With cc:Mail . Change the\n'compress= line in the [cc:Mail] section of the appropriate WMAIL.INI\n'files To specify the full path For WinZip followed by \"-a %1 @%2\".\n'\n'\n'For example, If WinZip is installed in your c:\\winzip directory,\n'    specify\n'    compress=c:\\winzip\\winzip.exe -a %1 @%2\n\n\n\nFunction GetGroup(Server As String)\n  ' von Christian Janik\n  ' leicht modifiziert von Mark Doerbandt\n  Dim wmi, wql, result, entry\n'  server = \"Servername\" ' anpassen\n  Set wmi = GetObject(\"winmgmts:\\\\\" & Server)\n  If err.Number <> 0 Then\n    MsgBox \"wmi nicht einsatzbereit.\"\n  Else\n    wql = \"select * from win32_Group\"\n    Set result = wmi.ExecQuery(wql)\n    For Each entry In result\n      MsgBox entry.Sid\n    Next\n  End If\nEnd Function\n"}
