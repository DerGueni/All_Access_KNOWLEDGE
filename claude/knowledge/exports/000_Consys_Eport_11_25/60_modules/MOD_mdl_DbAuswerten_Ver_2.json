{"id":"MOD_mdl_DbAuswerten_Ver_2","name":"mdl_DbAuswerten_Ver_2","kind":"standard","procedures":["Function ModList() As String","Function Create_qrymdb_Queries()","Private Function CreateQuery(strSQL As String, Optional queryName As String = \"qrySorting\") As Boolean","Private Function ObjectExists(strObjectType As String, strObjectName As String) As Boolean","Function Form_Mdl()","Function Report_Mdl()","Function Add_Label_To_Table(O_Typ As String, O_Formname As String, C_ControlType As Long, C_Visible As Boolean, C_Name As String, C_Caption As String)","Private Function f_ctrlType(ictrl As Long) As String","Function Func_SubsInModule(strModulname As String, MBF As Boolean) As Long","Private Function strgTest(strTemp As String, PrivJN As Boolean, funcName As String) As Integer","Public Function FunctNamesCreate(modName As String, Funct As String, XMBF As Boolean) As Boolean","Sub GetProzName(ModulName As String)","Function ModArt(modName As String)","Function RestIns(Optional ByVal XLoesch As Boolean = True)","Function FuncTableCreate(strTable As String) As Boolean","Function FuncTableCreate_Qry(strTable As String) As Boolean","Function TblInfo_AllTab()","Function TableInfoCreate(strTableName As String)","Function DescTableCreate(strTable As String) As Boolean","Private Function fieldType(n) As String","Private Function AccessEigenschaftEinstellen(obj As Object, StrName As String, _","Private Function table_exist(tableName As String) As Boolean","Private Function ArrFill_DAO_Acc(ByVal recsetSQL As String, ByRef iZLMax As Long, ByRef iColMax As Long, ByRef DAOARRAY) As Boolean","Function Auswert2()","Function qry_QueryMain_Fill()"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\nConst Const_Eigenes_Modul As String = \"mdl_DbAuswerten_Ver_2\"\n\nDim ictrlAr\nDim strctrlAr\nDim JUcntAnz As Long\nDim db As DAO.Database\nDim rst As DAO.Recordset\n\n\n' Es werden die Abfragen \"qrymdb*\" erzeugt\n' Es werden die Tabellen \"_int_tblObjektNamen\", \"_tblAlleFormularFelder\", \"_int_tblObjektNamen\" erzeugt\n' Zum Auswerten einfach dieses Modul in eine fremde Datenbank kopieren\n' WICHTIG: Beim Kopieren Modulnamen beibehalten, oder die Konstante im Kopf ändern, sonst klappt's nicht\n\n' Im Direktbereich\n\n'  ?ModList()\n\n'ausführen. Die kann bei größeren Datenbanken bis zu 15 Min dauern ...\n' Im Direktbereich wird es angezeigt, wenn alles OK, dann entsprechende Meldung\n\n'Danach enthält die Abfrage \"qrymdb_Anzahl_Objekte\" eine Summary der Objekte.\n'Die Tabellen enthalten:\n\n'Die Haupttabelle \"_int_tblObjektNamen\" enthält alle Objekte sowie alle Funktionen \"Function und Sub etc\" auch der Fornulare / Reports\n' Die Zusatztabelle \"_tblAlleFormularFelder\" enthält alle Felder von Formularen und Reports\n' Die Zusatztabelle \"_int_tblObjektNamen\" enthält alle Felder aller Tabellen\n\n'Siehe auch Datenbank \"Auswertung_fuer_Angebote.accdb\" -- diese enthält eine Summary wenn mehrere mdb Verwendung finden\n\n' Autor: Klaus Oberdalhoff\n'##########################\n'\n'Untere Schmiedgasse 8\n'D-90403 Nürnberg\n'Germany\n'\n'Tel  : +49(0911)2369666\n'Handy: 0152 33854642\n'Fax  : +49(03212)1154718\n'Skype: klaus.oberdalhoff\n'email: kobd@ gmx.de\n'Web:  http://www.sql-insider.de\n'AboutMe: http://about.me/klaus_oberdalhoff\n'LinkedIn: http://de.linkedin.com/in/klausoberdalhoff\n'XING: https://www.xing.com/profile/Klaus_Oberdalhoff\n'Ich unterstütze SQL PASS Deutschland e.V. (http://www.sqlpass.de)\n\n\nFunction ModList() As String\n\n    Dim tmp As String\n    Dim cnt As Container, doc As Document\n    Dim i As Integer, j As Integer, X, nix, tblname As String\n    Dim strSQL As String\n    \n    Set db = CurrentDb()\n    tmp = \"\"\n    \n'Dim ictrlAr\n'Dim strctrlAr\n'Dim JUcntAnz As Long\n    strctrlAr = Array(\"acBoundObjectFrame\", \"acCheckBox\", \"acComboBox\", \"acCommandButton\", \"acCustomControl\", \"acImage\", \"acLabel\", \"acLine\", \"acListBox\", \"acObjectFrame\", \"acOptionButton\", \"acOptionGroup\", \"acPage\", \"acPageBreak\", \"acRectangle\", \"acSubform\", \"acTabCtl\", \"acTextBox\", \"acToggleButton\")\n    ictrlAr = Array(acBoundObjectFrame, acCheckBox, acComboBox, acCommandButton, acCustomControl, acImage, acLabel, acLine, acListBox, acObjectFrame, acOptionButton, acOptionGroup, acPage, acPageBreak, acRectangle, acSubform, acTabCtl, acTextBox, acToggleButton)\n    JUcntAnz = UBound(strctrlAr)\n\n    Debug.Print \"Start part 1 - Objektnamen \" & Now()\n\n    If Not table_exist(\"_int_tblObjektNamen\") Then\n        nix = FuncTableCreate(\"_int_tblObjektNamen\")\n    End If\n\n    If Not table_exist(\"_int_tblQueryMain\") Then\n        nix = FuncTableCreate_Qry(\"_int_tblQueryMain\")\n    End If\n    \n    If Not table_exist(\"_int_tblTabellenBeschreibung\") Then\n        nix = DescTableCreate(\"_int_tblTabellenBeschreibung\")\n    End If\n   \n    If Not table_exist(\"_int_tblFrmFeldnamen\") Then\n    \n        strSQL = \"CREATE TABLE _int_tblFrmFeldnamen (frmTyp CHAR, frmName CHAR, ControlName CHAR, ControlTypeID INT, ControlType CHAR, IsVisible BIT, ControlCaption MEMO);\"\n        CurrentDb.Execute (strSQL)\n        strSQL = \"CREATE INDEX PK_int_tblFrmFeldnamen ON _int_tblFrmFeldnamen (frmTyp, frmName, ControlName) WITH PRIMARY;\"\n        CurrentDb.Execute (strSQL)\n    End If\n\n    CurrentDb.Execute (\"DELETE * FROM _int_tblObjektNamen;\")\n    CurrentDb.Execute (\"DELETE * FROM _int_tblQueryMain;\")\n    CurrentDb.Execute (\"DELETE * FROM _int_tblFrmFeldnamen;\")\n    CurrentDb.Execute (\"DELETE * FROM _int_tblTabellenBeschreibung;\")\n\n    Call Create_qrymdb_Queries\n\n    DoCmd.Echo False\n            \n'   RestIns(False) = Bestehende Infos werden nicht gelöscht (nur hinzufügen)\n'   RestIns(True) = Bestehende Infos werden vorher gelöscht\n    Call RestIns(True)   ' Tabellen, Makros, Reports, Forms, Abfragen\n\n    Debug.Print \"Start part 2 - Modul Funktionen\" & Now()\n    'Module\n'    DoCmd.Echo True\n    DoCmd.Echo False\n    For i = 0 To db.Containers.Count - 1\n        Set cnt = db.Containers(i)\n        For j = 0 To cnt.Documents.Count - 1\n            Set doc = cnt.Documents(j)\n '           Debug.Print doc.Container\n            If doc.Container = \"Modules\" Then\n                If doc.Name <> Const_Eigenes_Modul Then\n                    X = Func_SubsInModule(doc.Name, False)\n                End If\n    '            tmp = tmp & doc.Name & SEMICOLON\n            End If\n        Next\n        DoEvents\n    Next\n\n'    ModList = tmp\n    \n    \n    Debug.Print \"Start part 3 - Forms Module \" & Now()\n    Set rst = db.OpenRecordset(\"SELECT TOP 1 * FROM _int_tblFrmFeldnamen;\")\n\n    X = Form_Mdl()      ' Module behind Forms\n\n        Debug.Print \"Start part 4 - Report Module \" & Now()\n\n    X = Report_Mdl()    ' Module behind Reports\n    \n    rst.Close\n    Set rst = Nothing\n\n    Debug.Print \"Start part 5 - Tabellen \" & Now()\n\n    X = TblInfo_AllTab()\n    \n    Set rst = Nothing\n    Set db = Nothing\n    \n    Debug.Print \"Start part 6 - Abfragen SQL \" & Now()\n\n    CurrentDb.Execute (\"UPDATE _int_tblObjektNamen SET [_int_tblObjektNamen].FunktionsParam = Null WHERE ((([_int_tblObjektNamen].Art)='Abfragen' Or ([_int_tblObjektNamen].Art)='Interne Abfragen'));\")\n\n    qry_QueryMain_Fill\n    \n    CurrentDb.Execute (\"UPDATE _int_tblQueryMain INNER JOIN _int_tblObjektNamen ON [_int_tblQueryMain].Qry_Name = [_int_tblObjektNamen].ModulName SET [_int_tblObjektNamen].FunktionsParam = [qry_SQL] WHERE ((([_int_tblObjektNamen].Art)='Abfragen' Or ([_int_tblObjektNamen].Art)='Interne Abfragen'));\")\n    \n    DoEvents\n    \n    DoCmd.Echo True\n    Debug.Print \"End of function now \" & Now()\n\nEnd Function\n\n\n\nFunction Create_qrymdb_Queries()\n\nDim strSQL As String\n\n'The queries to create in beforehand: ' Tested up until Version Access 2013\n\n''qrymdbForm\nstrSQL = \"SELECT MSysObjects.Name as ObjName FROM MSysObjects WHERE (((MSysObjects.flags) = 0 Or (MSysObjects.flags) = 8) And ((MSysObjects.Type) = -32768) And ((Left([Name], 1)) <> \" & Chr$(34) & \"~\" & Chr$(34) & \")) ORDER BY MSysObjects.Name;\"\nCall CreateQuery(strSQL, \"qrymdbForm\")\n'\n''qrymdbReport\nstrSQL = \"SELECT MSysObjects.Name as ObjName FROM MSysObjects WHERE (((MSysObjects.flags) = 0 Or (MSysObjects.flags) = 8) And ((MSysObjects.Type) = -32764) And ((Left([Name], 1)) <> \" & Chr$(34) & \"~\" & Chr$(34) & \")) ORDER BY MSysObjects.Name;\"\nCall CreateQuery(strSQL, \"qrymdbReport\")\n'\n''qrymdbModul\nstrSQL = \"SELECT MSysObjects.Name as ObjName FROM MSysObjects WHERE (((MSysObjects.Type) = -32761) And ((MSysObjects.flags) = 0 Or (MSysObjects.flags) = 256 Or (MSysObjects.flags) = 8)) ORDER BY MSysObjects.Name;\"\nCall CreateQuery(strSQL, \"qrymdbModul\")\n'\n''qrymdbMacro\nstrSQL = \"SELECT MSysObjects.Name as ObjName FROM MSysObjects WHERE (((MSysObjects.Type)=-32766) AND ((MSysObjects.Flags=0) OR (MSysObjects.Flags=8))) ORDER BY MSysObjects.Name;\"\nCall CreateQuery(strSQL, \"qrymdbMacro\")\n'\n''qrymdbQuery\nstrSQL = \"SELECT MSysObjects.Name as ObjName FROM MSysObjects WHERE (((MSysObjects.flags) <> 3) And ((MSysObjects.Type) = 5)) ORDER BY MSysObjects.Flags, MSysObjects.Name;\"\nCall CreateQuery(strSQL, \"qrymdbQuery\")\n'\n''qrymdbQueryIntern\nstrSQL = \"SELECT MSysObjects.Name as ObjName FROM MSysObjects WHERE (((MSysObjects.Type) = 5) And ((MSysObjects.flags) = 3)) ORDER BY MSysObjects.Name;\"\nCall CreateQuery(strSQL, \"qrymdbQueryIntern\")\n'\n''qrymdbTable  'Type 1 = internal,  4 = SQL Server, 6 = Access External\nstrSQL = \"SELECT MSysObjects.Name AS ObjName, MSysObjects.Database, MSysObjects.Type FROM MSysObjects WHERE (((MSysObjects.Type) = 1) And ((MSysObjects.flags) = 0) And ((Left([Name], 1)) <> \" & Chr$(34) & \"~\" & Chr$(34) & \")) Or (((MSysObjects.Type) = 4) And ((MSysObjects.flags) = 1048576) And ((Left([Name], 1)) <> \" & Chr$(34) & \"~\" & Chr$(34) & \")) Or (((MSysObjects.Type) = 6) And ((MSysObjects.flags) = 2097152) And ((Left([Name], 1)) <> \" & Chr$(34) & \"~\" & Chr$(34) & \")) ORDER BY MSysObjects.Type, MSysObjects.[Name];\"\nCall CreateQuery(strSQL, \"qrymdbTable\")\n\n''qrymdb_InfoMsysObjects\nstrSQL = \"SELECT MSysObjects.* FROM MSysObjects;\"\nCall CreateQuery(strSQL, \"qrymdb_InfoMsysObjects\")\n\nDoEvents\n\nEnd Function\n\n\nPrivate Function CreateQuery(strSQL As String, Optional queryName As String = \"qrySorting\") As Boolean\n\nDim dbs As DAO.Database\nDim qdf As DAO.QueryDef\n\n   On Error GoTo CreateQuery_Error\n\nSet dbs = CurrentDb\nIf ObjectExists(\"Query\", queryName) Then\n    DoCmd.DeleteObject acQuery, queryName\nEnd If\nSet qdf = dbs.CreateQueryDef(queryName, strSQL)\n\nDoEvents\n\n   CreateQuery = True\n   On Error GoTo 0\n   Exit Function\n\nCreateQuery_Error:\n\n'    MsgBox \"Error \" & Err.Number & \" (\" & Err.Description & \") in procedure CreateQuery of Modul DataFunctions\"\nCreateQuery = False\n\nEnd Function\n\n\nPrivate Function ObjectExists(strObjectType As String, strObjectName As String) As Boolean\n' Pass the Object type: Table, Query, Form, Report, Macro, or Module\n' Pass the Object Name\n     Dim db As DAO.Database\n     Dim tbl As DAO.TableDef\n     Dim QRY As DAO.QueryDef\n     Dim i As Integer\n     \n     Set db = CurrentDb()\n     ObjectExists = False\n     \n     If strObjectType = \"Table\" Then\n          For Each tbl In db.TableDefs\n               If tbl.Name = strObjectName Then\n                    ObjectExists = True\n                    Set db = Nothing\n                    Exit Function\n               End If\n          Next tbl\n     ElseIf strObjectType = \"Query\" Then\n          For Each QRY In db.QueryDefs\n               If QRY.Name = strObjectName Then\n                    ObjectExists = True\n                    Set db = Nothing\n                    Exit Function\n               End If\n          Next QRY\n     ElseIf strObjectType = \"Form\" Or strObjectType = \"Report\" Or strObjectType = \"Module\" Then\n          For i = 0 To db.Containers(strObjectType & \"s\").Documents.Count - 1\n               If db.Containers(strObjectType & \"s\").Documents(i).Name = strObjectName Then\n                    ObjectExists = True\n                    Set db = Nothing\n                    Exit Function\n               End If\n          Next i\n     ElseIf strObjectType = \"Macro\" Then\n          For i = 0 To db.Containers(\"Scripts\").Documents.Count - 1\n               If db.Containers(\"Scripts\").Documents(i).Name = strObjectName Then\n                    ObjectExists = True\n                    Set db = Nothing\n                    Exit Function\n               End If\n          Next i\n     Else\n          MsgBox \"Invalid Object Type passed, must be Table, Query, Form, Report, Macro, or Module\"\n     End If\n\nSet db = Nothing\n     \nEnd Function\n\n\n\nFunction Form_Mdl()\n        \n        Dim db As DAO.Database, X, Y As String\n        Dim rst As DAO.Recordset\n        Dim frm As Form, O_Typ As String\n        Dim i As Long, Anz As Long, c As control\n        Dim strCaption As String\n\n        O_Typ = \"frm\"\n        Set db = CurrentDb\n'        Set rst = db.OpenRecordset(\"SELECT * FROM qrymdbFormModul;\", dbOpenDynaset)\n        Set rst = db.OpenRecordset(\"SELECT * FROM qrymdbForm\", dbOpenDynaset)\n                   \n            Do While Not rst.EOF\n                        \n'                rst.Edit\n                Y = rst.fields(0)\n                DoCmd.OpenForm Y, acDesign\n                If Forms(Y).HasModule = True Then\n                    X = Func_SubsInModule(\"Form_\" & rst.fields(0), True)\n                End If\n                \n                Set frm = Forms(Y)\n                Anz = frm.controls.Count ' liefert die Anzahl Steuerelemente im Formular\n                If Anz > 0 Then\n                    For i = 0 To Anz - 1\n                        Set c = frm.controls(i)\n                        strCaption = \"\"\n                        On Error Resume Next\n                            strCaption = Nz(c.caption, \" \")\n                        On Error GoTo 0\n                '        If C.ControlType = acLabel Or C.ControlType = acCommandButton Then  ' wenn's n Label oder button ist\n                '             Call Add_Label_To_Table(O_Typ, Y, C.ControlType, C.Visible, C.Name, strCaption)\n                '        End If\n                    Next i\n                End If\n    \n                DoCmd.Close acForm, Y, acSaveNo\n                rst.MoveNext\n                If rst.EOF Then Exit Do    ' für den Fall, daß wir uns auf dem letzten Datensatz befinden\n '               Stop\n                DoEvents\n            Loop\n            \n            rst.Close\n        Set db = Nothing\n        Set rst = Nothing\n\nEnd Function\n\nFunction Report_Mdl()\n        \n        Dim db As DAO.Database, X, Y As String\n        Dim rst As DAO.Recordset\n        Dim frm As Report, O_Typ As String\n        Dim i As Long, Anz As Long, c As control\n        Dim strCaption As String\n\n        O_Typ = \"rpt\"\n        Set db = CurrentDb\n'        Set rst = db.OpenRecordset(\"SELECT * FROM qrymdbReportModul;\", dbOpenDynaset)\n        Set rst = db.OpenRecordset(\"SELECT * FROM qrymdbReport;\", dbOpenDynaset)\n                   \n            Do While Not rst.EOF\n                        \n'                rst.Edit\n                Y = rst.fields(0)\n                DoCmd.OpenReport Y, acDesign\n                If Reports(Y).HasModule = True Then\n                    X = Func_SubsInModule(\"Report_\" & rst.fields(0), True)\n                End If\n                \n                Set frm = Reports(Y)\n                Anz = frm.controls.Count ' liefert die Anzahl Steuerelemente im Formular\n                If Anz > 0 Then\n                    For i = 0 To Anz - 1\n                        Set c = frm.controls(i)\n                        strCaption = \"\"\n                        On Error Resume Next\n                            strCaption = Nz(c.caption, \" \")\n                        On Error GoTo 0\n                        \n                        If c.ControlType = acLabel Or c.ControlType = acCommandButton Then  ' wenn's n Label oder button ist\n                             Call Add_Label_To_Table(O_Typ, Y, c.ControlType, c.Visible, c.Name, strCaption)\n                        End If\n                    Next i\n                End If\n    \n                DoCmd.Close acReport, Y, acSaveNo\n                rst.MoveNext\n                If rst.EOF Then Exit Do    ' für den Fall, daß wir uns auf dem letzten Datensatz befinden\n '               Stop\n                DoEvents\n            Loop\n            rst.Close\n        Set db = Nothing\n        Set rst = Nothing\n\nEnd Function\n\n\nFunction Add_Label_To_Table(O_Typ As String, O_Formname As String, C_ControlType As Long, C_Visible As Boolean, C_Name As String, C_Caption As String)\n\nWith rst\n'        strSQL = \"CREATE TABLE _int_tblFrmFeldnamen (frmTyp CHARACTER, frmName CHARACTER, ControlName CHARACTER, ControlTypeID INTEGER, ControlType CHARACTER, \" & _\n'                 \"IsVisible BIT, ControlCaption CHARACTER);\"\n    .AddNew\n        .fields(\"frmTyp\").Value = O_Typ\n        .fields(\"frmName\").Value = O_Formname\n        .fields(\"ControlName\").Value = C_Name\n        .fields(\"ControlTypeID\").Value = C_ControlType\n        .fields(\"ControlType\").Value = f_ctrlType(C_ControlType)\n        .fields(\"IsVisible\").Value = C_Visible\n        .fields(\"ControlCaption\").Value = C_Caption\n    .update\nEnd With\n\nEnd Function\n\nPrivate Function f_ctrlType(ictrl As Long) As String\n\n'Name des ControlTypes des Formulars / Reports ermitteln\n\nDim i As Long\n\n'Dim ictrlAr\n'Dim strctrlAr\n'Dim JUcntAnz As Long\n'    strctrlAr = Array(\"acBoundObjectFrame\", \"acCheckBox\", \"acComboBox\", \"acCommandButton\", \"acCustomControl\", \"acImage\", \"acLabel\", \"acLine\", \"acListBox\", \"acObjectFrame\", \"acOptionButton\", \"acOptionGroup\", \"acPage\", \"acPageBreak\", \"acRectangle\", \"acSubform\", \"acTabCtl\", \"acTextBox\", \"acToggleButton\")\n'    ictrlAr = Array(acBoundObjectFrame, acCheckBox, acComboBox, acCommandButton, acCustomControl, acImage, acLabel, acLine, acListBox, acObjectFrame, acOptionButton, acOptionGroup, acPage, acPageBreak, acRectangle, acSubform, acTabCtl, acTextBox, acToggleButton)\n'    JUcntAnz = ucount(strctrlAr)\n\nf_ctrlType = \"\"\nFor i = 0 To JUcntAnz\n    If ictrlAr(i) = ictrl Then\n        f_ctrlType = strctrlAr(i)\n        Exit For\n    End If\nNext i\n\nEnd Function\n\n\nFunction Func_SubsInModule(strModulname As String, MBF As Boolean) As Long\n\n    ' Fehlerbehandlung\n    On Error GoTo Error_Func_SubsInModule\n\n    ' Variablendimensionierung\n    Dim mdl As Module, strTemp As String, i As Integer, funcnam As String, funcArt As Integer, nix\n    Dim FuncxNam As String\n    Dim ModulAnzahl As Integer\n\n    ' Verweis auf \"Module\"-Objekt zurückgeben.\n    DoCmd.OpenModule (strModulname)\n    Set mdl = Modules(strModulname)\n\n    ' Zahl der Zeilen des Moduls zurückgeben.\n    Func_SubsInModule = mdl.CountOfLines\n\n    ' Schleife\n    ModulAnzahl = 0\n    For i = 1 To Func_SubsInModule\n        strTemp = Trim(mdl.lines(i, 1))\n        \n   '     Sub Function Property erkennen\n'         funcArt = strgTest(strTemp, False, FuncxNam)\n         funcArt = strgTest(strTemp, True, FuncxNam)\n         If funcArt > 0 Then\n          '  Debug.Print \"strtemp: \" & strtemp\n            funcnam = strTemp\n            ' Folgezeilen auch mit ausgeben\n            Do While Right(Trim(strTemp), 1) = \"_\"\n                funcnam = Left(Trim(funcnam), Len(funcnam) - 1)\n                i = i + 1\n                strTemp = Trim(mdl.lines(i, 1))\n              '  Debug.Print \"strtemp: \" & strtemp\n                funcnam = funcnam & \" \" & strTemp\n            Loop\n   '         Debug.Print \"funcnam: \" & funcnam & \", \" & funcArt\n'Public Function FunctNamesCreate(TableName As String, Modname As String, Funct As String, funcArt As Integer) As Boolean\n            nix = FunctNamesCreate(strModulname, funcnam, MBF)\n            ModulAnzahl = ModulAnzahl + 1\n        End If\n    \n    Next\n    If ModulAnzahl = 0 Then\n        nix = FunctNamesCreate(strModulname, \"Sub Keine()\", MBF)\n    End If\n    \nExit_Func_SubsInModule:\n\n    DoCmd.Close acModule, strModulname, acSaveNo\n    Exit Function\n\nError_Func_SubsInModule:\n\n    If err.Number = 3022 Then ' Existiert bereits\n        Resume Next\n    Else\n        If err.Number = 3015 Then\n            Func_SubsInModule = 0\n            Exit Function\n        Else\n            MsgBox err & \": \" & err.description\n            Func_SubsInModule = -1\n            Resume Exit_Func_SubsInModule\n        End If\n    End If\n\nEnd Function\n\nPrivate Function strgTest(strTemp As String, PrivJN As Boolean, funcName As String) As Integer\n'Hilfsfunktion zum Erkennen der Funktionsköpfe (Auch Klassenmodule)\n'Private Functions werden nur erkannt, wenn PrivJN = True\n'Rückgabe 1 - 5 für 1=sub, 2=function, 3=Property Let, 4=Property Get, 5=Property Set\n'Rückgabe 101 - 105 für private 1=sub, 2=function, 3=Property Let, 4=Property Get, 5=Property Set\n\n    '\"Sub\"\n    '\"Function\"\n    '\"Property Let\"\n    '\"Property Get\"\n    '\"Property Set\"\n    '\n    '\"Public Sub\"\n    '\"Public Function\"\n    '\"Public Property Let\"\n    '\"Public Property Get\"\n    '\"Public Property Set\"\n    '\n    '\"Private Sub\"\n    '\"Private Function\"\n    '\"Private Property Let\"\n    '\"Private Property Get\"\n    '\"Private Property Set\"\n\nDim st1 As String, Priv As Boolean\n    \n    Priv = False\n    strgTest = 0\n\n    'Leerzeichen löschen\n    st1 = Trim(strTemp)\n        \n    'Das Wort \"Private\" löschen, wenn PrivJN = True\n    If PrivJN = True Then\n        If Left(st1, 7) = \"Private\" Then\n            st1 = Right(st1, Len(st1) - 8)\n            Priv = True\n        End If\n    End If\n    \n    'Das Wort \"Public\" löschen\n    If Left(st1, 7) = \"Public \" Then\n        st1 = Right(st1, Len(st1) - 7)\n        strgTest = 0\n    End If\n    \n        If Left(st1, 4) = \"Sub \" Then\n            strgTest = strgTest + 1\n            st1 = Right(st1, Len(st1) - 4)\n        End If\n                        \n        If Left(st1, 9) = \"Function \" Then\n            strgTest = strgTest + 2\n            st1 = Right(st1, Len(st1) - 9)\n        End If\n    \n        If Left(st1, 13) = \"Property Let \" Then\n            strgTest = strgTest + 3\n        End If\n    \n        If Left(st1, 13) = \"Property Get \" Then\n            strgTest = strgTest + 4\n        End If\n    \n        If Left(st1, 13) = \"Property Set \" Then\n            strgTest = strgTest + 5\n        End If\n        If strgTest > 0 And Priv = True Then strgTest = strgTest + 100\n    funcName = st1\nEnd Function\n\n\nPublic Function FunctNamesCreate(modName As String, Funct As String, XMBF As Boolean) As Boolean\n\nOn Error GoTo Err_FunctNamesCreate\n    \n    Dim db As DAO.Database\n    Dim rst As DAO.Recordset\n    Dim mdlModulname As Module\n    Dim fname As String\n    Dim FParam As String\n    Dim FRueck As String, i, j, k, xx\n    Dim funcArt As String\n    Dim ModTyp As String\n    Dim funcPriv As Boolean\n    funcPriv = False\n    i = InStr(1, Funct, \"(\")\n    fname = Left(Funct, i - 1)\n    For k = Len(Funct) To 1 Step -1\n        If Mid$(Funct, k, 1) = \")\" Then\n        j = k\n        Exit For\n      End If\n    Next k\n    If k = 1 Then\n        j = 0\n        i = 0\n        FRueck = \"(keine)\"\n        FParam = \"(keine)\"\n    Else\n        If j > i + 1 Then\n            FParam = Mid(Funct, i + 1, (j - i - 1)) & \"\"\n        Else\n            FParam = \"(keine)\"\n        End If\n        If Len(Funct) > j Then\n              FRueck = Mid(Funct, j + 1)\n        Else\n              FRueck = \"(keine)\"\n        End If\n    End If\n\n    Set db = CurrentDb\n    Set rst = db.OpenRecordset(\"SELECT * FROM _int_tblObjektNamen;\", dbOpenDynaset)\n      \n    fname = Trim(fname)\n    If Left(fname, 7) = \"Public \" Then\n        fname = Right(fname, Len(fname) - 7)\n    End If\n    \n    If Left(fname, 7) = \"Private\" Then\n        fname = Right(fname, Len(fname) - 8)\n        funcPriv = True\n    End If\n    \n    fname = Trim(fname)\n    \n    If Left(fname, 4) = \"Sub \" Then\n        funcArt = \"Sub\"\n        fname = Right(fname, Len(fname) - 4)\n    End If\n                    \n    If Left(fname, 9) = \"Function \" Then\n        funcArt = \"Function\"\n        fname = Right(fname, Len(fname) - 9)\n    End If\n        \n    If Left(fname, 13) = \"Property Let \" Then\n        funcArt = \"Property Let\"\n        fname = Right(fname, Len(fname) - 13)\n    End If\n\n    If Left(fname, 13) = \"Property Get \" Then\n        funcArt = \"Property Get\"\n        fname = Right(fname, Len(fname) - 13)\n    End If\n\n    If Left(fname, 13) = \"Property Set \" Then\n        funcArt = \"Property Set\"\n        fname = Right(fname, Len(fname) - 13)\n    End If\n    \n    Set mdlModulname = Modules(modName)\n    If mdlModulname.Type = acClassModule Then\n        ModTyp = \"Module Fct Class\"\n    Else\n        ModTyp = \"Module Fct Norm\"\n    End If\n            \n    With rst\n            'Neuen Datensatz einfügen\n            .AddNew\n                !ModulName = Trim(modName)\n                !Art = Trim(ModTyp)\n                !FunktionsName = Trim(fname)\n                !FunktionsParam = Trim(FParam)\n                !FunktionsRueck = Trim(FRueck)\n                !FunktionsArt = Trim(funcArt)\n                !Priv = funcPriv\n                !MBF = XMBF\n            .update\n            \n '       .Close\n    End With\n       \nExit_FunctNamesCreate:\n    Exit Function\n\nErr_FunctNamesCreate:\n    If err.Number = 3022 Then ' Existiert bereits\n        Resume Next\n    Else\n        MsgBox \"FunctNamesCreate \" & err & \": \" & err.description\n        Resume Exit_FunctNamesCreate\n    End If\n\nEnd Function\n\nSub GetProzName(ModulName As String)\n    \n    Dim lngAnzahlZeilenModul As Long            ' Anzahl der Zeilen im Modul\n    Dim lngAnzahlZeilenDeklaration As Long      ' Anzahl der Zeilen im Deklarationsabschnitt\n    Dim lngAktuelleZeile As Long                ' Aktuelle Zeile bei Programmdurchlauf\n    Dim strProzName As String                   ' Name der Prozedur\n    Dim lngProzTyp  As Long                     ' Typ der Prozedur (Rückgabe als Zahl)\n    Dim lngZeileProzDefinition As Long          ' Zeile in der die Definition der Prozedur steht\n    Dim mdlModulname As Module\n    \n    '***** Modul öffnen und Objektvariable setzen\n    DoCmd.OpenModule ModulName\n    Set mdlModulname = Modules(ModulName)\n        \n    '***** Die Anzahl der Zeilen des Moduls ermitteln\n    lngAnzahlZeilenModul = mdlModulname.CountOfLines\n    '***** Die Anzahl der Zeilen des Deklarationsabschnitts des Moduls ermitteln.\n    lngAnzahlZeilenDeklaration = mdlModulname.CountOfDeclarationLines\n    '***** aktuelle Zeile hinter den Deklarationsabschnitt setzen\n    lngAktuelleZeile = lngAnzahlZeilenDeklaration + 1\n    \n    '***** Modul durchlaufen\n    Do\n        '***** Namen der Prozedur ermitteln\n        strProzName$ = mdlModulname.ProcOfLine(lngAktuelleZeile, lngProzTyp)\n                        \n        '***********************\n        Debug.Print strProzName$ '*************** Ausgabe\n        '***********************\n        \n        '***** aktuelle Zeile auf nächste Prozedur setzen\n        lngAktuelleZeile = lngAktuelleZeile + mdlModulname.ProcCountLines(strProzName$, lngProzTyp)\n    Loop While (lngAktuelleZeile < lngAnzahlZeilenModul)\n\n    '***** Modul schließen\n    DoCmd.Close acModule, ModulName\n    \nEnd Sub\n\nFunction ModArt(modName As String)\n    Dim mdlModulname As Module\n    \n    DoCmd.Echo False\n    DoCmd.OpenModule modName\n    Set mdlModulname = Modules(modName)\n    If mdlModulname.Type = acClassModule Then\n        ModArt = \"Class Module\"\n    Else\n        ModArt = \"Module\"\n    End If\n    DoCmd.Close acModule, modName, acSaveNo\n    DoCmd.Echo True\n\nEnd Function\n\n'Form Makro Report Form Tabelle\n\nFunction RestIns(Optional ByVal XLoesch As Boolean = True)\n'XLoesch = True - Bestehende Tabelle wird vorher gelöscht\n'XLoesch = False - Bestehende Einträge werden nicht verändert (nur hinzufügen)\n\nDim Krit As String, nix\n\n    If Not table_exist(\"_int_tblObjektNamen\") Then\n        nix = FuncTableCreate(\"_int_tblObjektNamen\")\n    End If\n  \nIf XLoesch Then\n    Krit = \"DELETE * FROM _int_tblObjektNamen;\"\n    CurrentDb.Execute (Krit)\nEnd If\n  \n    Krit = \"INSERT INTO _int_tblObjektNamen ( ModulName, Art, FunktionsArt, FunktionsName, MBF ) \"\n    Krit = Krit & \" SELECT qrymdbForm.ObjName, 'Formulare' AS Ausdr1, ' ' AS Ausdr2, ' ' AS Ausdr3, False AS Ausdr4 \"\n    Krit = Krit & \" FROM qrymdbForm;\"\n    CurrentDb.Execute (Krit)\n    \n    Krit = \"INSERT INTO _int_tblObjektNamen ( ModulName, Art, FunktionsArt, FunktionsName, MBF ) \"\n    Krit = Krit & \" SELECT qrymdbMacro.ObjName, 'Makros' AS Ausdr1, ' ' AS Ausdr2, ' ' AS Ausdr3, False AS Ausdr4 \"\n    Krit = Krit & \" FROM qrymdbMacro;\"\n    CurrentDb.Execute (Krit)\n    \n    Krit = \"INSERT INTO _int_tblObjektNamen ( ModulName, Art, FunktionsArt, FunktionsName, MBF ) \"\n    Krit = Krit & \" SELECT qrymdbQuery.ObjName, 'Abfragen' AS Ausdr1, ' ' AS Ausdr2, ' ' AS Ausdr3, False AS Ausdr4 \"\n    Krit = Krit & \" FROM qrymdbQuery;\"\n    CurrentDb.Execute (Krit)\n    \n    Krit = \"INSERT INTO _int_tblObjektNamen ( ModulName, Art, FunktionsArt, FunktionsName, MBF ) \"\n    Krit = Krit & \" SELECT qrymdbReport.ObjName, 'Berichte' AS Ausdr1, ' ' AS Ausdr2, ' ' AS Ausdr3, False AS Ausdr4 \"\n    Krit = Krit & \" FROM qrymdbReport;\"\n    CurrentDb.Execute (Krit)\n    \n    Krit = \"INSERT INTO _int_tblObjektNamen ( ModulName, Art, FunktionsArt, FunktionsName, MBF ) \"\n    Krit = Krit & \" SELECT qrymdbTable.ObjName, 'Tabellen' AS Ausdr1, Nz(qrymdbTable.Database, ' ') AS Ausdr2, ' ' AS Ausdr3, False AS Ausdr4 \"\n    Krit = Krit & \" FROM qrymdbTable;\"\n    CurrentDb.Execute (Krit)\n\n    Krit = \"INSERT INTO _int_tblObjektNamen ( ModulName, Art, FunktionsArt, FunktionsName, MBF ) \"\n    Krit = Krit & \" SELECT qrymdbModul.ObjName, 'Module' AS Ausdr1, ' ' AS Ausdr2, ' ' AS Ausdr3, False AS Ausdr4 \"\n    Krit = Krit & \" FROM qrymdbModul;\"\n    CurrentDb.Execute (Krit)\n\n    Krit = \"INSERT INTO _int_tblObjektNamen ( ModulName, Art, FunktionsArt, FunktionsName, MBF ) \"\n    Krit = Krit & \" SELECT qrymdbQueryIntern.ObjName, 'Interne Abfragen' AS Ausdr1, ' ' AS Ausdr2, ' ' AS Ausdr3, False AS Ausdr4 \"\n    Krit = Krit & \" FROM qrymdbQueryIntern;\"\n    CurrentDb.Execute (Krit)\n    \n    ''qrymdb_Anzahl_Objekte\n    Krit = \"SELECT [_int_tblObjektNamen].Art, Count([_int_tblObjektNamen].ID) AS AnzahlvonID FROM _int_tblObjektNamen GROUP BY [_int_tblObjektNamen].Art;\"\n    Call CreateQuery(Krit, \"qrymdb_Anzahl_Objekte\")\n\nEnd Function\n\n\nFunction FuncTableCreate(strTable As String) As Boolean\n'-------------------------\n'Purpose:  Creates A new table and sets field format\n'Accepts:  strTable, the name of the new table\n'Returns:  True (-1) on success, False on failure\n'-------------------------\n\n'Function provided by ATTAC Consulting Group, Ann Arbor, MI  USA\n\nOn Error GoTo ErrCT\n\nDim TDB As DAO.Database\nDim fld(18) As field\nDim fFormat2 As Property, fFormat3 As Property, fFormat4 As Property\nDim idxTbl As Index\nDim idxFld As field\nDim Newtbl As TableDef\nDim Newtbl2 As TableDef\n\nFuncTableCreate = True\n\n'First Create the table\n\nSet TDB = CurrentDb()\nSet Newtbl = TDB.CreateTableDef(strTable)\n\n'                                           FeldTyp        Feldattribute\n'Tabellenname        Feldname           FldNr         FeldTypNr   Feldgroesse   Feldbeschreibung\n'_int_tblObjektNamen   ID                 1   Long Integer    4   17  4           Autowert und Primary Key\n'_int_tblObjektNamen   Art                2   Text            10  2   50\n'_int_tblObjektNamen   ModulName          3   Text            10  2   250\n'_int_tblObjektNamen   FunktionsArt       4   Text            10  2   50\n'_int_tblObjektNamen   FunktionsName      5   Text            10  2   250\n'_int_tblObjektNamen   FunktionsParam     6   Memo            12  2   0\n'_int_tblObjektNamen   FunktionsRueck     7   Text            10  2   250\n'_int_tblObjektNamen   Priv               8   Yes/No          1   1   1\n'_int_tblObjektNamen   Tabelle1           9   Text            10  2   50\n'_int_tblObjektNamen   Tabelle2           10  Text            10  2   50\n'_int_tblObjektNamen   bspFormular        11  Text            10  2   50\n'_int_tblObjektNamen   Frage              12  Text            10  2   250\n'_int_tblObjektNamen   Beschreibung       13  Text            10  2   255\n'_int_tblObjektNamen   Herkunft           14  Text            10  2   50\n'_int_tblObjektNamen   VersionsNr         15  Text            10  2   10\n'_int_tblObjektNamen   MBF                16  Yes/No          1   1   1\n'_int_tblObjektNamen   DemoFormName       17  Text            10  2   250\n'_int_tblObjektNamen   VerDatum           18  Date/Time       8   1   8\n\n'ID\nSet fld(1) = Newtbl.CreateField(\"ID\", dbLong)\nfld(1).attributes = fld(1).attributes Or dbAutoIncrField\nNewtbl.fields.append fld(1)\n\n'Art\nSet fld(2) = Newtbl.CreateField(\"Art\", dbText, 50)\nNewtbl.fields.append fld(2)\n\n'ModulName\nSet fld(3) = Newtbl.CreateField(\"ModulName\", dbText, 250)\nNewtbl.fields.append fld(3)\n\n'FunktionsArt\nSet fld(4) = Newtbl.CreateField(\"FunktionsArt\", dbText, 50)\nNewtbl.fields.append fld(4)\n\n'FunktionsName\nSet fld(5) = Newtbl.CreateField(\"FunktionsName\", dbText, 250)\nNewtbl.fields.append fld(5)\n\n'FunktionsParam\nSet fld(6) = Newtbl.CreateField(\"FunktionsParam\", dbMemo)\nNewtbl.fields.append fld(6)\n\n'FunktionsRueck\nSet fld(7) = Newtbl.CreateField(\"FunktionsRueck\", dbText, 250)\nNewtbl.fields.append fld(7)\n\n'Priv\nSet fld(8) = Newtbl.CreateField(\"Priv\", dbBoolean)\nNewtbl.fields.append fld(8)\n\n'Tabelle1\nSet fld(9) = Newtbl.CreateField(\"Tabelle1\", dbText, 50)\nNewtbl.fields.append fld(9)\n\n'Tabelle2\nSet fld(10) = Newtbl.CreateField(\"Tabelle2\", dbText, 50)\nNewtbl.fields.append fld(10)\n\n'bspFormular\nSet fld(11) = Newtbl.CreateField(\"bspFormular\", dbText, 50)\nNewtbl.fields.append fld(11)\n\n'Frage\nSet fld(12) = Newtbl.CreateField(\"Frage\", dbText, 250)\nNewtbl.fields.append fld(12)\n\n'Beschreibung\nSet fld(13) = Newtbl.CreateField(\"Beschreibung\", dbMemo)\nNewtbl.fields.append fld(13)\n\n'Herkunft\nSet fld(14) = Newtbl.CreateField(\"Herkunft\", dbText, 50)\nNewtbl.fields.append fld(14)\n\n'VersionsNr\nSet fld(15) = Newtbl.CreateField(\"VersionsNr\", dbText, 10)\nNewtbl.fields.append fld(15)\n\n'MBF\nSet fld(16) = Newtbl.CreateField(\"MBF\", dbBoolean)\nNewtbl.fields.append fld(16)\n\n'DemoFormName\nSet fld(17) = Newtbl.CreateField(\"DemoFormName\", dbText, 250)\nNewtbl.fields.append fld(17)\n\n'VerDatum\nSet fld(18) = Newtbl.CreateField(\"VerDatum\", dbDate)\nNewtbl.fields.append fld(18)\n\nTDB.TableDefs.append Newtbl\n\n'Create an index for our table.  Need to use a new tabledef\n'object for the table or it doesn't work\n\nSet Newtbl2 = TDB.TableDefs(strTable)\nSet idxTbl = Newtbl2.CreateIndex(\"PrimaryKey\")\nidxTbl.Primary = -1\nidxTbl.Unique = -1\nSet idxFld = idxTbl.CreateField(\"Art\")\nidxTbl.fields.append idxFld\nSet idxFld = idxTbl.CreateField(\"ModulName\")\nidxTbl.fields.append idxFld\nSet idxFld = idxTbl.CreateField(\"FunktionsArt\")\nidxTbl.fields.append idxFld\nSet idxFld = idxTbl.CreateField(\"FunktionsName\")\nidxTbl.fields.append idxFld\n\nNewtbl2.indexes.append idxTbl\n\nTDB.Close\nSet TDB = Nothing\n    \nExitCT:\n    Exit Function\nErrCT:\n    If err <> 91 Then\n        MsgBox \"Fehler Nr: \" & err.Number & \" \" & err.description\n        TDB.Close\n    End If\n    FuncTableCreate = False\n    Resume ExitCT\nEnd Function\n\n\nFunction FuncTableCreate_Qry(strTable As String) As Boolean\n\n'-------------------------\n'Purpose:  Creates A new table and sets field format\n'Accepts:  strTable, the name of the new table\n'Returns:  True (-1) on success, False on failure\n'-------------------------\n\n'Function provided by ATTAC Consulting Group, Ann Arbor, MI  USA\n\nOn Error GoTo ErrCT\n\nDim TDB As DAO.Database\nDim fld(18) As field\nDim fFormat2 As Property, fFormat3 As Property, fFormat4 As Property\nDim idxTbl As Index\nDim idxFld As field\nDim Newtbl As TableDef\nDim Newtbl2 As TableDef\n\nFuncTableCreate_Qry = True\n\n'First Create the table\n\nSet TDB = CurrentDb()\nSet Newtbl = TDB.CreateTableDef(strTable)\n\n'                                           FeldTyp        Feldattribute\n'Tabellenname        Feldname           FldNr         FeldTypNr   Feldgroesse   Feldbeschreibung\n'_int_tblObjektNamen   ID                 1   Long Integer    4   17  4           Autowert und Primary Key\n'_int_tblObjektNamen   Art                2   Text            10  2   50\n'_int_tblObjektNamen   ModulName          3   Text            10  2   250\n'_int_tblObjektNamen   FunktionsArt       4   Text            10  2   50\n'_int_tblObjektNamen   FunktionsName      5   Text            10  2   250\n'_int_tblObjektNamen   FunktionsParam     6   Memo            12  2   0\n'_int_tblObjektNamen   FunktionsRueck     7   Text            10  2   250\n'_int_tblObjektNamen   Priv               8   Yes/No          1   1   1\n'_int_tblObjektNamen   Tabelle1           9   Text            10  2   50\n'_int_tblObjektNamen   Tabelle2           10  Text            10  2   50\n'_int_tblObjektNamen   bspFormular        11  Text            10  2   50\n'_int_tblObjektNamen   Frage              12  Text            10  2   250\n'_int_tblObjektNamen   Beschreibung       13  Text            10  2   255\n'_int_tblObjektNamen   Herkunft           14  Text            10  2   50\n'_int_tblObjektNamen   VersionsNr         15  Text            10  2   10\n'_int_tblObjektNamen   MBF                16  Yes/No          1   1   1\n'_int_tblObjektNamen   DemoFormName       17  Text            10  2   250\n'_int_tblObjektNamen   VerDatum           18  Date/Time       8   1   8\n\n\n'Qry_Name\nSet fld(1) = Newtbl.CreateField(\"Qry_Name\", dbText, 250)\nNewtbl.fields.append fld(1)\n\n'FunktionsParam\nSet fld(2) = Newtbl.CreateField(\"qry_SQL\", dbMemo)\nNewtbl.fields.append fld(2)\n\nTDB.TableDefs.append Newtbl\n\n'Create an index for our table.  Need to use a new tabledef\n'object for the table or it doesn't work\n\nSet Newtbl2 = TDB.TableDefs(strTable)\nSet idxTbl = Newtbl2.CreateIndex(\"PrimaryKey\")\nidxTbl.Primary = -1\nidxTbl.Unique = -1\nSet idxFld = idxTbl.CreateField(\"Qry_Name\")\nidxTbl.fields.append idxFld\n\nNewtbl2.indexes.append idxTbl\n\nTDB.Close\nSet TDB = Nothing\n\nExitCT:\n    Exit Function\nErrCT:\n    If err <> 91 Then\n        MsgBox \"Fehler Nr: \" & err.Number & \" \" & err.description\n        TDB.Close\n    End If\n    FuncTableCreate_Qry = False\n    Resume ExitCT\nEnd Function\n\nFunction TblInfo_AllTab()\n\nDim db As DAO.Database\nDim rst As DAO.Recordset\nDim tblname As String, nix\n\nSet db = CurrentDb\nSet rst = db.OpenRecordset(\"SELECT ModulName FROM _int_tblObjektNamen WHERE (Art='Tabellen');\", dbOpenDynaset)\n\nWith rst\n    .MoveFirst\n    \n    Do While Not .EOF\n  '      .Edit\n\n        tblname = Nz(.fields(0))\n        nix = TableInfoCreate(tblname)\n\n        .MoveNext\n    Loop\n    \n    .Close\nEnd With\n\nSet rst = Nothing\nSet db = Nothing\n\nEnd Function\n\n\nFunction TableInfoCreate(strTableName As String)\n   ' Alison Brown / geändert: KObd\n   ' Purpose: Print in the immediate window the field names, types, and sizes for any table.\n   ' Argument: name of a table in the current database.\n   Dim db As DAO.Database, tdf As TableDef, i As Integer, j As Integer\n   Dim fldnam As String, fldtyp As String, fldtypNr As Integer, fldsiz As Integer, flddes As String\n   Dim Krit As String, fldatt As String\n   Dim prp As Properties, nix, rst\n   Dim idxLoop As Index, idxFld As field\n    \n   On Error GoTo TableInfoErr1\n   \n   Set db = DBEngine(0)(0)\n   Set tdf = db.TableDefs(strTableName)\n                \n'   If Not AccessEigenschaftEinstellen(tdf, \"Description\", dbText, False) Then\n'       MsgBox \"Adding Description Property to tables did not work\"\n'       Exit Function\n'   End If\n   \n    Krit = \"DELETE * \"\n    Krit = Krit & \" From _int_tblTabellenBeschreibung\"\n    Krit = Krit & \" WHERE (Tabellenname= '\" & strTableName & \"');\"\n    \n    Set rst = db.CreateQueryDef(\"\", Krit)\n    rst.Execute\n   \n    Set rst = Nothing\n    Set rst = db.OpenRecordset(\"SELECT * FROM _int_tblTabellenBeschreibung;\", dbOpenDynaset)\n         \n    For i = 0 To tdf.fields.Count - 1\n        \n        fldnam = tdf.fields(i).Name\n        fldtypNr = tdf.fields(i).Type\n        fldtyp = fieldType(tdf.fields(i).Type)\n        fldatt = Nz(tdf.fields(i).attributes)\n        fldsiz = tdf.fields(i).Size\n            On Error Resume Next\n            err.clear\n        flddes = \"\"\n        flddes = tdf.fields(i).Properties(\"Description\")\n            On Error GoTo TableInfoErr1\n        \n        rst.AddNew\n            rst.fields(\"Tabellenname\") = strTableName\n            rst.fields(\"Feldname\") = fldnam\n            rst.fields(\"FldNr\") = i + 1\n            rst.fields(\"IsIndex\") = False\n            rst.fields(\"FeldTyp\") = fldtyp\n            rst.fields(\"FeldTypNr\") = fldtypNr\n            rst.fields(\"Feldattribute\") = fldatt\n            rst.fields(\"Feldgroesse\") = fldsiz\n            If Len(Trim(Nz(flddes))) > 0 Then\n                rst.fields(\"Feldbeschreibung\") = flddes\n            End If\n        rst.update\n   \n   Next i\n   \n'No idea, what´s going wrong here ...\n\n'   For Each idxLoop In tdf.Indexes\n'      Debug.Print \"    \" & idxLoop.Name\n'\n'        J = 0\n'        For Each idxfld In idxLoop\n'              Debug.Print \"             \" & idxfld.Name\n'            J = J + 1\n'            rst.AddNew\n'                rst.Fields(\"Tabellenname\") = strTableName\n'                rst.Fields(\"Indexname\") = idxLoop.Name\n'                rst.Fields(\"IsIndex\") = True\n'                rst.Fields(\"Feldname\") = idxfld.Name\n'                rst.Fields(\"FldNr\") = J\n'            rst.Update\n'\n'        Next idxfld\n'\n'   Next idxLoop\n'\nTableInfoExit:\n\nrst.Close\ndb.Close\n   \nSet rst = Nothing\nSet db = Nothing\n      \n   Exit Function\n\nTableInfoErr1:\nSelect Case err\n   Case 3022    ' Tabelle / Feld existiert bereits\n        Resume Next\n   Case 3265   ' Supplied table name invalid\n       MsgBox strTableName & \" table doesn't exist\"\n       Resume TableInfoExit\n   Case Else\n       Debug.Print \"TableInfo() Error \" & err & \": \" & Error\n   End Select\n   End Function\n\n\nFunction DescTableCreate(strTable As String) As Boolean\n'-------------------------\n'Purpose:  Creates A new table and sets field format\n'Accepts:  strTable, the name of the new table\n'Returns:  True (-1) on success, False on failure\n'-------------------------\n'When you are creating a table using code you may want to set a field's format\n'or number of decimal places.\n'Alternately if you run a make table query using already formated fields as an\n'input, you will find that the new table does not carry over the formatting of\n'your input fields. Therefore in each situation, you need to set the format for\n'the field.\n'\n'The format and decimal places properties of a field do not exist until they are\n'created, so if you query a field's \"format\" property before it is created, you'll\n'get an error saying there is no such property. So here's some code which creates\n'a simple table, and then sets the format and decimal places properties for a couple\n'of fields. You can strip out the code for the format section to create a new\n'function for setting the format for a table after running a make table query.\n\n'Function provided by ATTAC Consulting Group, Ann Arbor, MI  USA\n\nOn Error GoTo ErrCT\n\nDim TDB As DAO.Database\nDim fld1 As field, fld2 As field, fld3 As field, fld4 As field, fld5 As field, fld6 As field, fld7 As field, fld8 As field, fld9 As field, fld10 As field\nDim fFormat2 As Property, fFormat3 As Property, fFormat4 As Property\nDim idxTbl As Index\nDim idxFld As field\nDim Newtbl As TableDef\nDim Newtbl2 As TableDef\n\nDescTableCreate = True\n\n'First Create the table\n\nSet TDB = CurrentDb()\nSet Newtbl = TDB.CreateTableDef(strTable)\n\n'Tabellenname\nSet fld2 = Newtbl.CreateField(\"Tabellenname\", dbText, 250)\nNewtbl.fields.append fld2\n\n'Feldname\nSet fld3 = Newtbl.CreateField(\"Feldname\", dbText, 250)\nNewtbl.fields.append fld3\n\n'Indexname\nSet fld9 = Newtbl.CreateField(\"Indexname\", dbText, 250)\nNewtbl.fields.append fld9\n\n'IsIndex\nSet fld10 = Newtbl.CreateField(\"IsIndex\", dbBoolean)\nNewtbl.fields.append fld10\n\n'FeldNr\nSet fld1 = Newtbl.CreateField(\"FldNr\", dbSingle)\n'fld1.Attributes = fld1.Attributes Or dbAutoIncrField\nNewtbl.fields.append fld1\n\n'Feldtyp\nSet fld4 = Newtbl.CreateField(\"FeldTyp\", dbText, 25)\nNewtbl.fields.append fld4\n\n'FeldtypNr\nSet fld7 = Newtbl.CreateField(\"FeldTypNr\", dbSingle)\nNewtbl.fields.append fld7\n\n'Feldattribute\nSet fld8 = Newtbl.CreateField(\"Feldattribute\", dbText, 50)\nNewtbl.fields.append fld8\n\n'Feldgröße\nSet fld5 = Newtbl.CreateField(\"Feldgroesse\", dbSingle)\nNewtbl.fields.append fld5\n\n'Feldbeschreibung\nSet fld6 = Newtbl.CreateField(\"Feldbeschreibung\", dbText, 250)\nNewtbl.fields.append fld6\n\nTDB.TableDefs.append Newtbl\n\n'Create an index for our table.  Need to use a new tabledef\n'object for the table or it doesn't work\n\nSet Newtbl2 = TDB.TableDefs(strTable)\nSet idxTbl = Newtbl2.CreateIndex(\"PrimaryKey\")\nidxTbl.Primary = -1\nidxTbl.Unique = -1\n'Set idxFld = idxTbl.CreateField(\"IDTbl\")\n'idxTbl.Fields.Append idxFld\nSet idxFld = idxTbl.CreateField(\"Tabellenname\")\nidxTbl.fields.append idxFld\nSet idxFld = idxTbl.CreateField(\"Feldname\")\nidxTbl.fields.append idxFld\n\nNewtbl2.indexes.append idxTbl\n\n' To add any comment to a field (\"Beschreibung\" hinzufügen)\n\nSet fFormat4 = fld1.CreateProperty(\"Description\", dbText, \"Autowert und Primary Key\")\nfld1.Properties.append fFormat4\nSet fFormat4 = fld2.CreateProperty(\"Description\", dbText, \"Tabellenname\")\nfld2.Properties.append fFormat4\nSet fFormat4 = fld3.CreateProperty(\"Description\", dbText, \"Feldname\")\nfld3.Properties.append fFormat4\nSet fFormat4 = fld4.CreateProperty(\"Description\", dbText, \"Feldtyp\")\nfld4.Properties.append fFormat4\nSet fFormat4 = fld5.CreateProperty(\"Description\", dbText, \"Feldgröße\")\nfld5.Properties.append fFormat4\nSet fFormat4 = fld6.CreateProperty(\"Description\", dbText, \"Feldbeschreibung\")\nfld6.Properties.append fFormat4\nSet fFormat4 = fld7.CreateProperty(\"Description\", dbText, \"Nr des Feldtyps\")\nfld7.Properties.append fFormat4\nSet fFormat4 = fld8.CreateProperty(\"Description\", dbText, \"Feldattribut\")\nfld8.Properties.append fFormat4\n\nTDB.Close\nSet TDB = Nothing\n    \nExitCT:\n    Exit Function\nErrCT:\n    If err <> 91 Then TDB.Close\n    DescTableCreate = False\n    Resume ExitCT\nEnd Function\n\nPrivate Function fieldType(n) As String\n   ' Korrigierte Version\n   ' Purpose: Converts the numeric results of DAO fieldtype to Text.\n   Select Case n\n   Case dbBoolean\n        fieldType = \"Yes/No\"        '1\n   Case dbByte\n        fieldType = \"Byte\"          '2\n   Case dbInteger\n      fieldType = \"Integer\"         '3\n   Case dbLong\n      fieldType = \"Long Integer\"    '4\n   Case dbCurrency\n      fieldType = \"Currency\"        '5\n   Case dbSingle\n      fieldType = \"Single\"          '6\n   Case dbDouble\n      fieldType = \"Double\"          '7\n    Case dbDate\n      fieldType = \"Date/Time\"       '8\n    Case dbText\n      fieldType = \"Text\"            '10\n    Case dbLongBinary\n      fieldType = \"OLE Object\"      '11\n    Case dbMemo\n      fieldType = \"Memo\"            '12\n    Case Else\n      fieldType = \"Unknown Type: \" & n\n   End Select\n   \n   End Function\n\nPrivate Function AccessEigenschaftEinstellen(obj As Object, StrName As String, _\n        intTyp As Integer, varEinstellung As Variant) As Boolean\n    Dim prp As Property\n    Const conEigNichtGef As Integer = 3270\n\n    On Error GoTo FehlerAccessEigenschaftEinstellen\n    ' Explizit auf die Auflistung \"Properties\" verweisen.\n    obj.Properties(StrName) = varEinstellung\n    obj.Properties.Refresh\n    AccessEigenschaftEinstellen = True\n            \nBeendenAccessEigenschaftEinstellen:\n    Exit Function\n\nFehlerAccessEigenschaftEinstellen:\n    If err = conEigNichtGef Then\n        ' Eigenschaft erstellen, Typ festlegen, Anfangswert einstellen.\n        Set prp = obj.CreateProperty(StrName, intTyp, varEinstellung)\n        ' Eigenschaft-Objekt an die Auflistung \"Properties\" anfügen.\n        obj.Properties.append prp\n        obj.Properties.Refresh\n        AccessEigenschaftEinstellen = True\n        Resume BeendenAccessEigenschaftEinstellen\n    Else\n        MsgBox err & \": \" & vbCrLf & err.description\n\nAccessEigenschaftEinstellen = False\n        Resume BeendenAccessEigenschaftEinstellen\n    End If\nEnd Function\n\nPrivate Function table_exist(tableName As String) As Boolean\n'**********************************************************************************\n'Function Table_Exist()\n'Prüft, ob die Tabelle in der MDB vorhanden ist\n'auch für eingebundene Tabellen oder Queries\n'\n'Rückgabe: TRUE, tbl ist vorhanden oder eingebunden\n'          FALSE, tbl ist nicht vorhanden\n'**********************************************************************************\n\nDim db As DAO.Database\nDim tbl As DAO.Recordset\nDim nix\n\nOn Error GoTo table_exist_error\n\n    Set db = CurrentDb\n    Set tbl = db.OpenRecordset(tableName)\n    table_exist = True\n    Set tbl = Nothing\n    Exit Function\n\ntable_exist_error:\n    table_exist = False\n    Set tbl = Nothing\n    Exit Function\n\nEnd Function\n\n'==========================================================================================================================================\n\nPrivate Function ArrFill_DAO_Acc(ByVal recsetSQL As String, ByRef iZLMax As Long, ByRef iColMax As Long, ByRef DAOARRAY) As Boolean\n\nDim db As DAO.Database\nDim rst As DAO.Recordset\nDim i As Long\n\n'Dim ArrFill_DAO_OK1 As Boolean, recsetSQL1 As String, iZLMax1 As Long, iColMax1 As Long, DAOARRAY1, iZl as long, iCol as long\n'recsetSQL1 = \"\"\n'ArrFill_DAO_OK1 = ArrFill_DAO_Acc(recsetSQL1,iZLMax1,iColMax1,DAOARRAY1)\n''Info:   'AccessArray(iSpalte,iZeile) <0, 0>\n'If ArrFill_DAO_OK1 Then\n'    For iZl = 0 To iZLMax1\n'\n'\n'\n'    Next iZl\n'    Set DAOARRAY1 = Nothing\n'End If\n\nArrFill_DAO_Acc = False\n\n    Set db = CurrentDb\n    Set rst = db.OpenRecordset(recsetSQL)\n    If rst.RecordCount <> 0 Then\n        rst.MoveLast\n        i = rst.RecordCount\n        rst.MoveFirst\n        DAOARRAY = rst.GetRows(i)\n\n    'Achtung Zeile und Spalte 0-basiert\n    'RowArray(iFldNr,iRecNr)\n    'RowArray(iSpalte,iZeile)\n        iZLMax = UBound(DAOARRAY, 2)\n        iColMax = UBound(DAOARRAY, 1)\n        ArrFill_DAO_Acc = True\n    End If\n    rst.Close\n    Set rst = Nothing\n\nEnd Function\n\n\nFunction Auswert2()\n\nDim ArrFill_DAO_OK1 As Boolean, recsetSQL1 As String, iZLMax1 As Long, iColMax1 As Long, DAOARRAY1, iZl As Long, iCol As Long\nDim dbpfadname As String\nDim dbname As String\nDim strSQL As String\n\nrecsetSQL1 = \"tblDBNamen\"\nArrFill_DAO_OK1 = ArrFill_DAO_Acc(recsetSQL1, iZLMax1, iColMax1, DAOARRAY1)\n''Info:   'AccessArray(iSpalte,iZeile) <0, 0>\nIf ArrFill_DAO_OK1 Then\n    CurrentDb.Execute (\"DELETE * FROM _int_tblFrmFeldnamen_Alle;\")\n    CurrentDb.Execute (\"DELETE * FROM _int_tblObjektNamen_Alle;\")\n    CurrentDb.Execute (\"DELETE * FROM _int_tblTabellenBeschreibung_Alle;\")\n    \n    For iZl = 0 To iZLMax1\n    \n    \n        dbpfadname = DAOARRAY1(1, iZl)\n        dbname = DAOARRAY1(2, iZl)\n        If table_exist(\"_int_tblFrmFeldnamen\") Then\n            DoCmd.DeleteObject acTable, \"_int_tblFrmFeldnamen\"\n        End If\n        If table_exist(\"_int_tblObjektNamen\") Then\n            DoCmd.DeleteObject acTable, \"_int_tblObjektNamen\"\n        End If\n        If table_exist(\"_int_tblTabellenBeschreibung\") Then\n            DoCmd.DeleteObject acTable, \"_int_tblTabellenBeschreibung\"\n        End If\n        \n        DoCmd.TransferDatabase acImport, \"Microsoft Access\", _\n            dbpfadname, acTable, \"_int_tblFrmFeldnamen\", \"_int_tblFrmFeldnamen\"\n        DoCmd.TransferDatabase acImport, \"Microsoft Access\", _\n            dbpfadname, acTable, \"_int_tblObjektNamen\", \"_int_tblObjektNamen\"\n        DoCmd.TransferDatabase acImport, \"Microsoft Access\", _\n            dbpfadname, acTable, \"_int_tblTabellenBeschreibung\", \"_int_tblTabellenBeschreibung\"\n                       \n        strSQL = \"\"\n        strSQL = \"INSERT INTO _int_tblFrmFeldnamen_Alle ( dbname, frmTyp, frmName, ControlName, ControlTypeID, ControlType, IsVisible, ControlCaption ) SELECT '\"\n        strSQL = strSQL & dbname\n        strSQL = strSQL & \"' AS Ausdr1, frmTyp, frmName, ControlName, ControlTypeID, ControlType , IsVisible, ControlCaption FROM _int_tblFrmFeldnamen;\"\n        If CreateQuery(strSQL, \"insFeldName\") Then\n            CurrentDb.Execute (\"insFeldName\")\n        End If\n        \n        strSQL = \"\"\n        strSQL = \"INSERT INTO _int_tblObjektNamen_Alle ( dbname, Art, ModulName, FunktionsArt, FunktionsName, FunktionsParam, FunktionsRueck, Priv, Tabelle1, Tabelle2, bspFormular, Frage, Beschreibung, Herkunft, VersionsNr, MBF, DemoFormName, VerDatum ) SELECT '\"\n        strSQL = strSQL & dbname\n        strSQL = strSQL & \"' AS Ausdr1, Art, ModulName, FunktionsArt, FunktionsName, FunktionsParam, FunktionsRueck, Priv, Tabelle1, Tabelle2, bspFormular, Frage, Beschreibung, Herkunft, VersionsNr, MBF, DemoFormName, VerDatum FROM _int_tblObjektNamen;\"\n        If CreateQuery(strSQL, \"insObjektnamen\") Then\n            CurrentDb.Execute (\"insObjektnamen\")\n        End If\n        \n        strSQL = \"\"\n        strSQL = \"INSERT INTO _int_tblTabellenBeschreibung_Alle ( dbname, Tabellenname, Feldname, Indexname, IsIndex, FldNr, FeldTyp, FeldTypNr ) SELECT '\"\n        strSQL = strSQL & dbname\n        strSQL = strSQL & \"' AS Ausdr1, Tabellenname, Feldname, Indexname, IsIndex, FldNr, FeldTyp, FeldTypNr FROM _int_tblTabellenBeschreibung;\"\n        If CreateQuery(strSQL, \"insTabellenBeschreibung\") Then\n            CurrentDb.Execute (\"insTabellenBeschreibung\")\n        End If\n    Next iZl\n    \n    If table_exist(\"_int_tblFrmFeldnamen\") Then\n        DoCmd.DeleteObject acTable, \"_int_tblFrmFeldnamen\"\n    End If\n    If table_exist(\"_int_tblObjektNamen\") Then\n        DoCmd.DeleteObject acTable, \"_int_tblObjektNamen\"\n    End If\n    If table_exist(\"_int_tblTabellenBeschreibung\") Then\n        DoCmd.DeleteObject acTable, \"_int_tblTabellenBeschreibung\"\n    End If\n    \n    Set DAOARRAY1 = Nothing\nEnd If\n\nEnd Function\n\nFunction qry_QueryMain_Fill()\nDim dbs As DAO.Database\nDim i As Integer\nDim j As Integer\nDim strPath As String\n\nDim rst As DAO.Recordset\nstrPath = DBPfad()\n\nCurrentDb.Execute (\"DELETE * FROM _int_tblQueryMain;\")\nDoEvents\n\nSet dbs = CurrentDb() ' use CurrentDb() to refresh Collections\n\nSet rst = dbs.OpenRecordset(\"SELECT * FROM _int_tblQueryMain;\")\n\n'Call Path_erzeugen(strPath & \"qry\\\")\n\nDebug.Print \"Anzahl Queries: \" & dbs.QueryDefs.Count\nFor i = 0 To dbs.QueryDefs.Count - 1\n    rst.AddNew\n        rst.fields(0) = dbs.QueryDefs(i).Name\n        rst.fields(1) = dbs.QueryDefs(i).sql\n    rst.update\n\n'' Um für jede Abfrage eine Text-Datei zu erzeugen\n''Abfrage wird in Dir Qry der Datenbank erzeugt\n''================================================\n'    Application.SaveAsText acQuery, Dbs.QueryDefs(I).Name, strPath & \"qry\\\" & Dbs.QueryDefs(I).Name & \".txt\"\n'    If I Mod 200 = 0 Then\n'        Debug.Print I\n'        DoEvents\n'    End If\n''################################################\nNext i\n\nrst.Close\nSet rst = Nothing\n\nEnd Function\n"}
