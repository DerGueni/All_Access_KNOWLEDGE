{"id":"MOD_FileDialog","name":"FileDialog","kind":"standard","procedures":["Private Function CountFiles(strSelection As String) As Integer","Private Function BuildFilter() As String","Private Sub CheckFlags(Intention As String)","Private Function ParseAuswahl(Optional strAuswahl As String = \"\", Optional blnInitial As Boolean = False)","Function ShowFolder() As String","Function ShowOpen() As String","Function ShowSave() As String","Private Sub Class_Initialize()"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"\n'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n'\n' 21.05.2010\n' erweitert von Gunter Avenius, http://www.avenius.com\n'\n' Hinzugekommen bzw. Änderungen:\n'\n' - Im Folder-Dialog kann der Button \"Neuer Ordner erstellen\" angezeigt werden.\n' - Der FileDialog funktioniert auch unter Win7 wenn mehr als ein Filter angegeben wird.\n' - Klassenmodul kompatibel ab A97 bis A2010 x64.\n'\n'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n'\n'This code was originally written by Karsten Pries.\n'It is not to be altered or distributed, except as part of an application.\n'You are free to use it in any application, provided the copyright notice is left unchanged.\n'\n'ShowFolder Code courtesy of Terry Kreft, please see original at http://www.mvps.org/access\n'\n'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' Für die Verwendung ausserhalb von Access (Excel, Word, VB, ...) alle 3 Zeilen mit\n' \"hWndAccessApp\" auskommentieren, sonst Laufzeitfehler.\n'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' Wrapper für Win-API:\n'   \"GetOpenFileNameA\"\n'   \"GetSaveFileNameA\"\n'\n' Aufruf des CommonDialog von Windows zur Auswahl einer Datei (öffnen/speichern)\n' ohne Verwendung des OCX\n'\n' ********************************************************************************\n' Verwendung (noch mehr dazu im Demoformular):\n'\n' Sub xx()\n'  Dim fd As New FileDialog\n'  Dim Dateiname as String\n\n' kurze Version:\n'    Dateiname = fd.ShowOpen           ' oder .ShowSave\n'    if Dateiname = \"\" then exit sub   ' Abbruch durch Benutzer\n'    .....\n'\n' ohne extra Variable:\n'    fd.ShowOpen                         ' oder .ShowSave\n'    if fd.FileName = \"\" then exit sub   ' Abbruch durch Benutzer\n'    sonst z.B.  Kill fd.FileName        ' ausgewählte Datei löschen\n'    .....\n'\n' ausführlich:\n'\n'   With fd\n'      .DialogTitle = \"Mein Titel\"\n'      .DefaultExt = \"TXT\"             'Standard-Endung wenn vom Benutzer nix anderes angegeben\n'      .DefaultDir = \"c:\\\"\n'      .Flags = OFN_FILEMUSTEXIST Or OFN_PATHMUSTEXIST Or OFN_READONLY\n'      .MultiSelect = True\n'      .Filter1Text = \"Text-Dateien\"\n'      .Filter1Suffix = \"*.txt\"\n'      .Filter2Text = \"Ascii-Dateien\"\n'      .Filter2Suffix = \"*.asc\"\n'      ... bis Filter5Text/Suffix ...\n'\n'      .ShowOpen                          ' oder .ShowSave\n'\n'      if fd.FileName = \"\" then exit sub   ' Abbruch durch Benutzer\n'      DateiName = fd.FileName\n'   End With\n' End Sub\n'\n'************************************************************************************\n'\n' Bemerkung: Die Property .Filter ist für die Abwärtskompatibilität und für Leute,\n'            die wissen was sie tun. Alle anderen sollen FilterXText/Suffix benutzen.\n'            Näheres im Code zu .Filter.\n'************************************************************************************\n'\n'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n' Bugs/Wünsche/Vorschläge bitte an pries@gmx.de\n'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\nOption Explicit\n\n' Konstanten\nPrivate Const LEN_FILENAME_NORMAL As Integer = 512     'Ist der zurückgegebene Name zu lang,\nPrivate Const LEN_FILENAME_MULTISELECT As Long = 2000  'gibts beim API-Aufruf einen Fehler und .FileName liefert \"\"\n\nPrivate Const OFN_FILEMUSTEXIST = &H1000\nPrivate Const OFN_PATHMUSTEXIST = &H800\nPrivate Const OFN_HIDEREADONLY = &H4\nPrivate Const OFN_READONLY = &H1\nPrivate Const OFN_OVERWRITEPROMPT = &H2\nPrivate Const OFN_ALLOWMULTISELECT = &H200\nPrivate Const OFN_EXPLORER = &H80000\n\n' Konstanten für Button \"Neuer Ordner\"\n'# 12.05.2010#\nPrivate Const BIF_NONEWFOLDERBUTTON = &H200\nPrivate Const BIF_NEWDIALOGSTYLE = &H40\n   \nPrivate Const BIF_RETURNONLYFSDIRS = &H1\n\n\n' interne Variablen, über Properties gesetzt/gelesen:\nPrivate strDialogTitle As String    ' Dialogtitel\nPrivate strFilter As String         ' Filter kann man sowohl wie gehabt definieren als\n                                    ' auch über die folgenden Paare Text/Suffix\nPrivate lngFlags As Long            ' Flags\nPrivate strDefaultExt As String     ' Standard-Endung\nPrivate strInitDir As String        ' Start-Verzeichnis\nPrivate blnMultiSelect As Boolean   ' Multiselect erlauben Ja/Nein\nPrivate intFileCount As Integer     ' Anzahl Dateien bei MultiSelect\nPrivate intExtCount As Integer      ' Anzahl der Extensions\nPrivate blnCreateFolder As Boolean  ' Button \"Neuer Ordner\"\n                                    ' optionale Filterparameter, ersparen die Mühe des Zusammenbaus\nPrivate strFilterText(5) As String  ' z.B. \"Text-Dateien\"\nPrivate strFilterSuffix(5) As String ' z.B. \"*.txt\"\n#If Win64 Then\n    Private lngHWnd As LongPtr\n#Else\n    Private lngHWnd As Long             ' Handle Window\n#End If\n' bei Multiselect kompatibel zum OCX, d.h. bei .Filename wird String der\n' Form \"Pfad & vbnullchar & Datei1 & vbnullchar & Datei2 & ...\" zurückgegeben\nPrivate blnKompatibel As Boolean\n\n' interne Variablen, von Funktionen benutzt\nPrivate strDateiname As String      ' zurückgegebener Dateiname\nPrivate cnstNull As String * 1      ' NULL-String\nPrivate strDefaultFileNameSave As String    ' Default merken, falls bei Multiselect\n                                            ' Stringlänge erhöht werden muß\nPrivate intLenFileName As Integer   ' max. Länge des zurückgegebenen Strings, entweder LEN_FILENAME_NORMAL\n                                    ' oder LEN_FILENAME_MULTISELECT. Ist der zurückgegebene Name zu lang,\n                                    ' gibts beim API-Aufruf einen Fehler und .FileName liefert \"\"\n#If Win64 Then\n    ' Typen\n    Private Type TOpenFileName\n        lStructSize As LongPtr           ' Länge des Datentyps OPENFILENAME\n        hOwner As LongPtr              ' Fenster, unter dem Dialog erscheint\n        hInstance As LongPtr              ' nicht verwendet\n        lpstrFilter As String          ' Zeichenkette von Anzeigenfiltern im Dialog\n        lpstrCustomFilter As String    ' nicht verwendet\n        nMaxCustFilter As Long         ' nicht verwendet\n        nFilterIndex As Long           ' 1 zum Benutzen des ersten Filters, 2 zum zweiten usw.\n        lpstrFile As String            ' String, der ausgewählte Datei bekommt\n        nMaxFile As Long               ' Länge von lpstrFile\n        lpstrFileTitle As String       ' Dateiname ohne Pfad (kann auch mit VBA ermittelt werden, also weglassen)\n        nMaxFileTitle As LongPtr          ' nicht verwendet\n        lpstrInitialDir As String      ' Ordner, in dem Dialog sich zuerst befinden soll\n        lpstrTitle As String           ' Titel des eigentlichen Dialogfensters\n        Flags As LongPtr                  ' verschiedene Optionen, die durch Konstanten eingestellt werden\n        nFileOffset As Integer         ' nicht verwendet\n        nFileExtension As Integer      ' nicht verwendet\n        lpstrDefExt As String          ' Erweiterung, die genommen wird, wenn keine eingegeben wurde\n        lCustData As LongPtr              ' nicht verwendet\n        lpfnHook As LongPtr               ' nicht verwendet\n        lpTemplateName As LongPtr\n    End Type\n    \n    Private Type BROWSEINFO\n      hOwner As LongPtr\n      pidlRoot As Long\n      pszDisplayName As String\n      lpszTitle As String\n      ulFlags As Long\n      lpfn As LongPtr\n      lParam As LongPtr\n      iImage As Long\n    End Type\n    \n    \n    Private Declare PtrSafe Function APT_GetOpenFileName Lib \"comdlg32.dll\" Alias _\n            \"GetOpenFileNameA\" (pOpenfilename As TOpenFileName) As Long\n    Private Declare PtrSafe Function APT_GetSaveFileName Lib \"comdlg32.dll\" Alias _\n            \"GetSaveFileNameA\" (pOpenfilename As TOpenFileName) As Long\n    Private Declare PtrSafe Function SHBrowseForFolder Lib \"SHELL32.DLL\" Alias _\n            \"SHBrowseForFolderA\" (lpBrowseInfo As BROWSEINFO) As Long\n    Private Declare PtrSafe Function SHGetPathFromIDList Lib \"SHELL32.DLL\" Alias _\n            \"SHGetPathFromIDListA\" (ByVal pidl As LongPtr, ByVal pszPath As String) As Long\n        \n    \n#Else\n\n    ' Typen\n    Private Type TOpenFileName\n        lStructSize As Long            ' Länge des Datentyps OPENFILENAME\n        hOwner    As Long              ' Fenster, unter dem Dialog erscheint\n        hInstance As Long              ' nicht verwendet\n        lpstrFilter As String          ' Zeichenkette von Anzeigenfiltern im Dialog\n        lpstrCustomFilter As String    ' nicht verwendet\n        nMaxCustFilter As Long         ' nicht verwendet\n        nFilterIndex As Long           ' 1 zum Benutzen des ersten Filters, 2 zum zweiten usw.\n        lpstrFile As String            ' String, der ausgewählte Datei bekommt\n        nMaxFile As Long               ' Länge von lpstrFile\n        lpstrFileTitle As String       ' Dateiname ohne Pfad (kann auch mit VBA ermittelt werden, also weglassen)\n        nMaxFileTitle As Long          ' nicht verwendet\n        lpstrInitialDir As String      ' Ordner, in dem Dialog sich zuerst befinden soll\n        lpstrTitle As String           ' Titel des eigentlichen Dialogfensters\n        Flags As Long                  ' verschiedene Optionen, die durch Konstanten eingestellt werden\n        nFileOffset As Integer         ' nicht verwendet\n        nFileExtension As Integer      ' nicht verwendet\n        lpstrDefExt As String          ' Erweiterung, die genommen wird, wenn keine eingegeben wurde\n        lCustData As Long              ' nicht verwendet\n        lpfnHook As Long               ' nicht verwendet\n        lpTemplateName As Long         ' nicht verwendet\n    End Type\n    \n    Private Type BROWSEINFO\n      hOwner As Long\n      pidlRoot As Long\n      pszDisplayName As String\n      lpszTitle As String\n      ulFlags As Long\n      lpfn As Long\n      lParam As Long\n      iImage As Long\n    End Type\n    \n    \n    Private Declare PtrSafe Function APT_GetOpenFileName Lib \"comdlg32.dll\" Alias _\n            \"GetOpenFileNameA\" (pOpenfilename As TOpenFileName) As Long\n    Private Declare PtrSafe Function APT_GetSaveFileName Lib \"comdlg32.dll\" Alias _\n            \"GetSaveFileNameA\" (pOpenfilename As TOpenFileName) As Long\n    Private Declare PtrSafe Function SHBrowseForFolder Lib \"SHELL32.DLL\" Alias _\n            \"SHBrowseForFolderA\" (lpBrowseInfo As BROWSEINFO) As Long\n    Private Declare PtrSafe Function SHGetPathFromIDList Lib \"SHELL32.DLL\" Alias _\n            \"SHGetPathFromIDListA\" (ByVal pidl As Long, ByVal pszPath As String) As Long\n#End If\n  \n#If Win64 Then\n    Property Let hwnd(lngAktHWnd As Long)\n        lngHWnd = CLngPtr(lngAktHWnd)\n    End Property\n#Else\n    Property Let hwnd(lngAktHWnd As Long)\n        lngHWnd = lngAktHWnd\n    End Property\n#End If\n\nPrivate Function CountFiles(strSelection As String) As Integer\nOn Error GoTo Error_CountFiles\n' zählen der selektierten Dateien\n\n    Dim idx As Integer, idxold As Integer\n    Dim Count As Integer\n    \n    idx = InStr(1, strSelection, cnstNull)\n    \n    Do Until idx = idxold\n        idxold = idx + 1\n        Count = Count + 1\n        idx = InStr(idxold, strSelection, cnstNull)\n    Loop\n\n    CountFiles = Count\n\nExit_CountFiles:\n    Exit Function\nError_CountFiles:\n    MsgBox err.description, , \"Exit_CountFiles\"\n    Resume Exit_CountFiles\nEnd Function\n\nProperty Let DefaultDir(strAktDefaultDir As String)\n    strInitDir = strAktDefaultDir & cnstNull\nEnd Property\n\nProperty Get FileCount() As Integer\n' Anzahl ausgewählter Dateien (she. auch .MultiSelect)\n    FileCount = intFileCount\nEnd Property\n'\n\nProperty Get ExtCount() As Integer\n' Anzahl der Extension\n    ExtCount = intExtCount\nEnd Property\n\n\nProperty Get GetNextFile() As String\n    GetNextFile = ParseAuswahl()\nEnd Property\n\nProperty Let InitDir(strAktDefaultDir As String)\n    Me.DefaultDir = strAktDefaultDir\nEnd Property\n\nProperty Let DefaultFileName(strAktDefaultFileName As String)\n    strDefaultFileNameSave = strAktDefaultFileName\nEnd Property\n\nPrivate Function BuildFilter() As String\n' bastelt bei Aufruf Open/Save aus den .FilterXText/Suffix und .Filter\n' einen gültigen Filterstring\nOn Error GoTo Error_BuildFilter\n\n   Dim myFilter As String\n   Dim i As Integer\n   \n   ' wenn .FilterXText/Suffix gesetzt dann String zusammenbauen\n   For i = 1 To UBound(strFilterText)\n      If strFilterText(i) <> \"\" And strFilterSuffix(i) <> \"\" Then\n         myFilter = myFilter & strFilterText(i) & cnstNull & strFilterSuffix(i) & cnstNull\n         intExtCount = intExtCount + 1\n      End If\n   Next\n   \n   If strFilter <> \"\" Then  ' .Filter wurde manuell gesetzt\n      ' cut trailing nulls\n      Do While Right(strFilter, 1) = cnstNull\n         strFilter = Left(strFilter, Len(strFilter) - 1)\n      Loop\n      \n      myFilter = strFilter & cnstNull & myFilter\n   End If\n   \n   If myFilter = \"\" Then myFilter = \"Alle Dateien\" & cnstNull & \"*.*\"\n   \n   myFilter = myFilter & cnstNull & cnstNull\n   \n   BuildFilter = myFilter\n   \nExit_BuildFilter:\n    Exit Function\nError_BuildFilter:\n    MsgBox err.description, , \"Exit_BuildFilter\"\n    Resume Exit_BuildFilter\nEnd Function\n\nPrivate Sub CheckFlags(Intention As String)\n\n   ' wenn die Flags schon manuell gesetzt wurden: nix tun,\n   ' außer wenn explizit Multiselect gewollt wird\n   If lngFlags <> 0 Then\n       If blnMultiSelect Then lngFlags = lngFlags Or OFN_ALLOWMULTISELECT Or OFN_EXPLORER\n       Exit Sub\n   End If\n   \n   ' sonst abhängig von Intention:\n   Select Case Intention\n      Case \"Open\"\n         lngFlags = OFN_FILEMUSTEXIST Or OFN_PATHMUSTEXIST Or OFN_HIDEREADONLY\n         If blnMultiSelect Then lngFlags = lngFlags Or OFN_ALLOWMULTISELECT Or OFN_EXPLORER\n      Case \"Save\"\n         lngFlags = OFN_PATHMUSTEXIST Or OFN_HIDEREADONLY Or OFN_OVERWRITEPROMPT\n      Case Else\n         MsgBox \"Unbekannte Intention: \" & Intention, vbOKOnly + vbCritical, \"CheckFlags\"\n   End Select\nEnd Sub\n\nProperty Let ShowNewFolderButton(blnAktCreateFolder As Boolean)\n    blnCreateFolder = blnAktCreateFolder\nEnd Property\n\nProperty Let DefaultExt(strAktDefaultExt As String)\n   strDefaultExt = strAktDefaultExt & cnstNull\nEnd Property\n\n\nProperty Let DialogTitle(title As String)\n   strDialogTitle = title & cnstNull\nEnd Property\n\n\nProperty Get fileName() As String\n   fileName = strDateiname\nEnd Property\n\nProperty Let filter(aktFilter As String)\n' wer dieses Property benutzt muß wissen was er macht, siehe für sichere Filterstrings\n' die Properties FilterXText/FilterXSuffix\n   \n   ' Korrekte Filterstrings haben z.B. die Form\n   ' \"Alle Dateien\" & cnstNull & \"*.*\" & cnstNull & cnstNull\n   \n   ' Korrekte Filter enden mit zweimal cnstnull\n   If Len(aktFilter) >= 2 And Right(aktFilter, 2) = cnstNull & cnstNull Then\n      strFilter = aktFilter\n   Else\n      strFilter = aktFilter & cnstNull & cnstNull\n   End If\n   \nEnd Property\n\nProperty Let Filter1Text(FilterText As String)\n   strFilterText(1) = FilterText\nEnd Property\nProperty Let Filter2Text(FilterText As String)\n   strFilterText(2) = FilterText\nEnd Property\nProperty Let Filter3Text(FilterText As String)\n   strFilterText(3) = FilterText\nEnd Property\n\nProperty Let Filter4Text(FilterText As String)\n   strFilterText(4) = FilterText\nEnd Property\n\nProperty Let Filter5Text(FilterText As String)\n   strFilterText(5) = FilterText\nEnd Property\n\nProperty Let Filter1Suffix(FilterSuffix As String)\n   strFilterSuffix(1) = FilterSuffix\nEnd Property\n\nProperty Let Filter2Suffix(FilterSuffix As String)\n   strFilterSuffix(2) = FilterSuffix\nEnd Property\nProperty Let Filter3Suffix(FilterSuffix As String)\n   strFilterSuffix(3) = FilterSuffix\nEnd Property\nProperty Let Filter4Suffix(FilterSuffix As String)\n   strFilterSuffix(4) = FilterSuffix\nEnd Property\nProperty Let Filter5Suffix(FilterSuffix As String)\n   strFilterSuffix(5) = FilterSuffix\nEnd Property\n\nProperty Let Flags(lngAktFlags As Long)\n   lngFlags = lngAktFlags\nEnd Property\n\nProperty Let MultiSelect(blnAktMultiSelect As Boolean)\n    blnMultiSelect = blnAktMultiSelect\n    intLenFileName = LEN_FILENAME_MULTISELECT\nEnd Property\n\n\nProperty Let MultiSelectOCXCompatible(blnAktKompatibel As Boolean)\n' wenn True dann Rückgabe der selektierten Dateien bei .FileName in der Form\n' \"Pfad & vbnullchar & Datei1 & vbnullchar & Datei2 & ...\" und\n' nicht über .GetNextFile, kompatibel zum OCX\n    \n    blnKompatibel = blnAktKompatibel\n    \n    ' vorsichtshalber auch gleich noch .MultiSelect auf True setzen\n    If blnAktKompatibel Then\n        blnMultiSelect = True\n        intLenFileName = LEN_FILENAME_MULTISELECT\n    End If\n\nEnd Property\n\nPrivate Function ParseAuswahl(Optional strAuswahl As String = \"\", Optional blnInitial As Boolean = False)\nOn Error GoTo Error_ParseAuswahl\n' wird nur für Multiselect verwendet. Mit blnInitial=True werden die\n' statischen Variablen initialisiert. Beim ersten Aufruf (blnInitial=True)\n' wird der Name der ersten Datei zurückgeliefert, bei jedem folgenden\n' Aufruf ohne Argumente der Name der nächsten. Der Initial-Aufruf erfolgt\n' aus .ShowOpen, weitere Aufrufe von außen über .GetNextFile, bis ein Leerstring\n' (\"\") zurückgeliefert wird.\n'\n' strAuswahl hat folgende Form (nur bei Initial):\n' mehrere Dateien selektiert: voller Pfad & chr(0) & Datei1 & chr(0) & datei2 & ....\n' nur eine Datei selektiert: Voller Dateiname inkl. Pfad & chr(0) & chr(0) & ...\n    \n    Static strPfadName As String\n    Static strDateien As String\n    Dim Dummy As String\n    Dim Retval As String\n    Dim idx As Integer\n    \n    If blnInitial Then\n        strDateien = strAuswahl\n        \n        idx = InStr(strDateien, cnstNull) ' erste 0\n        \n        If Asc(Mid(strDateien, idx + 1, 1)) = 0 Then\n        ' nach der ersten 0 kommt gleich noch eine weitere, d.h. trotz Multiselect\n        ' wurde nur eine Datei ausgewählt\n            Retval = Left$(strDateien, idx - 1)\n            intFileCount = 1\n        \n        Else ' als erstes kommt der Pfadname\n            strPfadName = Left$(strDateien, idx - 1)\n            ' bei c:\\ wird der Backslash mitgeliefert, bei c:\\windows nicht. Alle lieben Microsoft.\n            If Right$(strPfadName, 1) = \"\\\" Then strPfadName = Left$(strPfadName, Len(strPfadName) - 1)\n            \n            strDateien = Mid$(strDateien, idx + 1)\n            \n            intFileCount = CountFiles(strDateien)\n            \n            idx = InStr(strDateien, cnstNull)\n            Dummy = Left$(strDateien, idx - 1)\n            strDateien = Mid$(strDateien, idx + 1)\n            \n            Retval = strPfadName & \"\\\" & Dummy\n            \n        End If\n        \n    \n    Else    ' Folgeaufruf\n    \n        idx = InStr(strDateien, cnstNull)\n        If idx > 1 Then\n            Dummy = Left$(strDateien, idx - 1)\n            strDateien = Mid$(strDateien, idx + 1)\n            Retval = strPfadName & \"\\\" & Dummy\n        Else\n            Retval = \"\"\n        End If\n    End If\n    \n    ParseAuswahl = Retval\n\nExit_ParseAuswahl:\n    Exit Function\nError_ParseAuswahl:\n    MsgBox err.description, , \"Exit_ParseAuswahl\"\n    Resume Exit_ParseAuswahl\nEnd Function\n\n'This code was originally written by Terry Kreft.\n'It is not to be altered or distributed,\n'except as part of an application.\n'You are free to use it in any application,\n'provided the copyright notice is left unchanged.\n'\n'Code courtesy of\n'Terry Kreft\nFunction ShowFolder() As String\nOn Error GoTo Error_ShowFolder\n  \n    Dim X As Long, bi As BROWSEINFO, dwIList As Long\n    Dim szPath As String\n  \n    With bi\n        If lngHWnd = 0 Then\n             .hOwner = Application.hWndAccessApp\n        Else\n             .hOwner = lngHWnd\n        End If\n        .lpszTitle = strDialogTitle\n        '.ulFlags = BIF_RETURNONLYFSDIRS\n        'New Folder Button\n        .ulFlags = BIF_RETURNONLYFSDIRS + BIF_NEWDIALOGSTYLE _\n        + IIf(blnCreateFolder, 0, BIF_NONEWFOLDERBUTTON)\n    End With\n    \n    dwIList = SHBrowseForFolder(bi)\n    szPath = Space$(512)\n    X = SHGetPathFromIDList(ByVal dwIList, ByVal szPath)\n    \n    If X Then\n        strDateiname = Left$(szPath, InStr(szPath, cnstNull) - 1) ' restliche NUL-Werte abschneiden\n        ShowFolder = strDateiname\n    Else\n        strDateiname = \"\"\n        ShowFolder = \"\"\n    End If\n\nExit_ShowFolder:\n    Exit Function\nError_ShowFolder:\n    MsgBox err.Number & \": \" & err.description, , \"ShowFolder\"\n    Resume Exit_ShowFolder\nEnd Function\n\nFunction ShowOpen() As String\nOn Error GoTo Error_ShowOpen\n\n    Dim myFilter As String\n    Dim OpenDlg As TOpenFileName\n    \n    myFilter = BuildFilter()\n    Call CheckFlags(\"Open\")\n    \n    If strDialogTitle = \"\" Then\n       strDialogTitle = \"Datei öffnen\" & cnstNull\n    End If\n    \n    ' String für Default-Dateinamen setzen, Länge kann variieren (Normal/Multiselect), deswegen hier\n    strDateiname = strDefaultFileNameSave & String$(intLenFileName - Len(strDefaultFileNameSave), 0)\n    \n    With OpenDlg\n       .lStructSize = Len(OpenDlg)\n        If lngHWnd = 0 Then\n             .hOwner = Application.hWndAccessApp\n        Else\n             .hOwner = lngHWnd\n        End If\n       .lpstrFilter = myFilter\n       .nFilterIndex = 1\n       .lpstrFile = strDateiname\n       .nMaxFile = Len(strDateiname)\n       .lpstrInitialDir = strInitDir\n       .lpstrTitle = strDialogTitle\n       .Flags = lngFlags\n       .lpstrDefExt = strDefaultExt\n       \n       If APT_GetOpenFileName(OpenDlg) <> 0 Then     ' Aufruf erfolgreich\n         \n         If blnMultiSelect Then\n            \n            If Not blnKompatibel Then\n                strDateiname = ParseAuswahl(.lpstrFile, True)\n            Else ' OCX-kompatibel\n                strDateiname = Left$(.lpstrFile, InStr(.lpstrFile, cnstNull & cnstNull) - 1) ' restliche NUL-Werte abschneiden\n            End If\n         Else\n             intFileCount = 1\n             strDateiname = Left$(.lpstrFile, InStr(.lpstrFile, cnstNull) - 1) ' restliche NUL-Werte abschneiden\n         End If\n         \n         ' man kann beides machen:\n         ' Datei= fd.ShowOpen oder fd.ShowOpen : Datei=fd.FileName\n         ShowOpen = strDateiname\n       Else\n         strDateiname = \"\"\n         ShowOpen = \"\"\n         intFileCount = 0\n       End If\n    End With\n\nExit_ShowOpen:\n    Exit Function\nError_ShowOpen:\n    MsgBox err.description, , \"Exit_ShowOpen\"\n    Resume Exit_ShowOpen\nEnd Function\n\n\nFunction ShowSave() As String\nOn Error GoTo Error_ShowSave\n\n   Dim myFilter As String\n   Dim OpenDlg As TOpenFileName\n   \n   myFilter = BuildFilter()\n   Call CheckFlags(\"Save\")\n   \n   If strDialogTitle = \"\" Then\n      strDialogTitle = \"Datei speichern unter\" & cnstNull\n   End If\n   \n    ' String für Default-Dateinamen setzen, Länge kann variieren (Normal/Multiselect), deswegen hier\n    strDateiname = strDefaultFileNameSave & String$(intLenFileName - Len(strDefaultFileNameSave), 0)\n    \n   With OpenDlg\n      .lStructSize = Len(OpenDlg)\n       If lngHWnd = 0 Then\n            .hOwner = Application.hWndAccessApp\n       Else\n            .hOwner = lngHWnd\n       End If\n      .lpstrFilter = myFilter\n      .nFilterIndex = 1\n      .nFileExtension = ExtCount\n      .lpstrFile = strDateiname\n      .nMaxFile = Len(strDateiname)\n      .lpstrInitialDir = strInitDir\n      .lpstrTitle = strDialogTitle\n      .Flags = lngFlags\n      .lpstrDefExt = strDefaultExt\n      \n     \n      \n      If APT_GetSaveFileName(OpenDlg) <> 0 Then     ' Aufruf erfolgreich\n         ' man kann beides machen:\n         ' Datei= fd.ShowSave oder fd.ShowSave; Datei=fd.FileName\n\n         strDateiname = Left$(.lpstrFile, InStr(.lpstrFile, cnstNull) - 1) ' restliche NUL-Werte abschneiden\n         'If InStr(1, strDateiName, \".\" & LCase(strDefaultExt)) = 0 Then\n         '   strDateiName = strDateiName & \".\" & LCase(strDefaultExt)\n         'End If\n         ShowSave = strDateiname\n      Else\n         strDateiname = \"\"\n         ShowSave = \"\"\n      End If\n   End With\n\nExit_ShowSave:\n    Exit Function\nError_ShowSave:\n    MsgBox err.description, , \"Exit_ShowSave\"\n    Resume Exit_ShowSave\nEnd Function\n\nPrivate Sub Class_Initialize()\nOn Error GoTo Error_Class_Initialize\n   \n   ' Null-String initialisieren\n   cnstNull = Chr$(0)\n   \n   ' der String sollte lang genug für einen Win-95 Pfad sein,\n   ' für Multiselect wird das in .MultiSelect auf LEN_FILENAME_MULTISELECT erhöht\n   intLenFileName = LEN_FILENAME_NORMAL\n   strDateiname = String$(LEN_FILENAME_NORMAL, 0)\n   \n   strDialogTitle = \"\" ' erstmal leer, wird in .ShowOpen/.ShowSave auf Default gesetzt\n   strFilter = \"\"  ' erstmal leer, wird in BuildFilter() gebaut\n   \n   ' erstmal keine Default-Flags (wird in ShowOpen/ShowSave gesetzt)\n   lngFlags = 0\n   \n   ' keine Default-Erweiterung\n   strDefaultExt = cnstNull\n   \n   ' aktuelles Verzeichnis\n   strInitDir = CurDir$ & cnstNull\n\n    intExtCount = 0\n    \nExit_Class_Initialize:\n    Exit Sub\nError_Class_Initialize:\n    MsgBox err.description, , \"Exit_Class_Initialize\"\n    Resume Exit_Class_Initialize\nEnd Sub\n"}
