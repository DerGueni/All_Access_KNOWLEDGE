{"id":"MOD_mdlEinlesenVBAAlsText","name":"mdlEinlesenVBAAlsText","kind":"standard","procedures":["Function LesAlle(tblAusgabeName As String, Optional tblAlleName As String = \"Acc_tbl_Source_CL\", Optional pfad As String = \"\", Optional NurProgrammCode As Boolean = True)","Function tles(IDfile As Long, Datnam1 As String, Formnam1 As String, IstEinlesen As Boolean, IstModul As Boolean, stType As String, NurProgrammCode As Boolean, tblAusgabeName As String)","Private Function DatAuswert(ByVal st As String, NurLes As Boolean)","Private Function pgm_upd(IDfile As Long, tblAusgabeName As String)"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\n\nDim TestArray() As String\nDim tst1(1 To 4)\nDim bMerk As Boolean\nDim IstBegin As Boolean\nDim IstPrgm As Boolean\nDim vbControl As String\nDim iID As Long\nDim iIstFont As Long\nDim iIstFrame As Long\nDim stBeginArrType() As String\nDim stBeginArrName() As String\nDim ObjektNr As Long\n\n\nFunction LesAlle(tblAusgabeName As String, Optional tblAlleName As String = \"Acc_tbl_Source_CL\", Optional pfad As String = \"\", Optional NurProgrammCode As Boolean = True)\nDim ArrFill_DAO_OK1 As Boolean, recsetSQL1 As String, iZLMax1 As Long, iColMax1 As Long, DAOARRAY1, iZl As Long, iCol As Long\n'Dim Pfad As String\n\nObjektNr = 0\niID = 0\nrecsetSQL1 = \"Select ID, filename, IstModul, Formname, IsUsed, Type from \" & tblAlleName & \" Order By ID;\"\n\nArrFill_DAO_OK1 = ArrFill_DAO_Acc(recsetSQL1, iZLMax1, iColMax1, DAOARRAY1)\n'Info:   'AccessArray(iSpalte,iZeile) <0, 0>\nIf ArrFill_DAO_OK1 Then\n    For iZl = 0 To iZLMax1\n        bMerk = False\n        IstPrgm = False\n        vbControl = \"\"\n        iIstFont = 0\n        iIstFrame = 0\n        ReDim stBeginArrType(0)\n        ReDim stBeginArrName(0)\n        Call tles(CLng(DAOARRAY1(0, iZl)), pfad & CStr(DAOARRAY1(1, iZl)), CStr(DAOARRAY1(3, iZl)), CStr(DAOARRAY1(4, iZl)), CStr(DAOARRAY1(2, iZl)), CStr(DAOARRAY1(5, iZl)), NurProgrammCode, tblAusgabeName)\n    Next iZl\n    Set DAOARRAY1 = Nothing\nEnd If\n\nEnd Function\n\n\nFunction tles(IDfile As Long, Datnam1 As String, Formnam1 As String, IstEinlesen As Boolean, IstModul As Boolean, stType As String, NurProgrammCode As Boolean, tblAusgabeName As String)\nDim dateipruef As String\nDim Datnr1 As Variant\nDim ddaten1 As Variant\nDim i As Long\nDim db As DAO.Database\nDim rst As DAO.Recordset\n\n\ni = 1\n\ndateipruef = \"\"\ndateipruef = Dir(Datnam1)\nIf Len(dateipruef) = 0 Then\n    MsgBox \"Datei \" & Datnam1 & \" nicht vorhanden\"\n    Exit Function\nEnd If\n\nCurrentDb.Execute (\"DELETE * FROM \" & tblAusgabeName & \" WHERE IDfile = \" & IDfile & \";\")\n\nSet db = CurrentDb\nSet rst = db.OpenRecordset(\"SELECT * FROM \" & tblAusgabeName & \";\")\n\nDatnr1 = FreeFile\nOpen Datnam1 For Input As Datnr1    ' Datei zum Lesen öffnen.\nDo\n    Line Input #Datnr1, ddaten1            ' BEIM und nicht NACH dem letzten Satz er EOF'\n'    Debug.Print ddaten1, EOF(Datnr1)       ' bringt er EOF\n    Call DatAuswert(ddaten1, IstEinlesen)\n    'Bei Modulen (bzw Nicht Forms und Nicht Reports) kein Attributes als erste Programmzeile, daher \"künstlich\" Programmanfang setzen\n    If IstModul Then IstPrgm = True\n    If NurProgrammCode And Not IstPrgm Then\n    'tu nix\n    Else\n        rst.AddNew\n'            rst!ID = iID   ' wenn kein Autowert\n            rst!IDfile = IDfile\n            rst!IDZeile = i\n            rst!formName = Formnam1\n            rst!Memofeld = ddaten1\n            rst!IsUsed = IstEinlesen\n            rst!IstPgm = IstPrgm\n            rst!stType = stType\n            If Not (IstPrgm And IstEinlesen) Then\n                rst!Stufe = UBound(stBeginArrType) - 1\n                rst!txt1 = tst1(1)\n                rst!Txt2 = tst1(2)\n                rst!txt3 = tst1(3)\n                rst!vbControl = stBeginArrType(UBound(stBeginArrType))\n                rst!IstBegin = IstBegin\n                rst!IstFont = iIstFont\n                rst!IstFrame = iIstFrame\n                rst!vbControlName = stBeginArrName(UBound(stBeginArrType))\n                rst!ObjektNr = ObjektNr\n            End If\n        rst.update\n    End If\n    If EOF(Datnr1) Then\n        Exit Do\n    End If\n    i = i + 1\n'    iID = iID + 1\nLoop\nrst.Close\nClose Datnr1\n\nSet rst = Nothing\n\nCall pgm_upd(IDfile, tblAusgabeName)\n\nEnd Function\n\nPrivate Function DatAuswert(ByVal st As String, NurLes As Boolean)\n\nDim AnzWd, i, j\nDim iStufe As Long\n\n' Der Programmteil wird hier nicht aufgedröselt. Beginn des Programmteils ist immer eine \"Attribute\" Zeile\nIf Left(st, 9) = \"Attribute\" Or IstPrgm = True Then\n    IstPrgm = True\n    Exit Function\nEnd If\n\nIf NurLes = True Then\n    Exit Function\nEnd If\n\n' Zeilen aufdröseln\n' txt1 - leeren\nFor i = 1 To 4\n    tst1(i) = \"\"\nNext i\n'Kommentar aus Zeile entfernen\ni = InStrRev(st, \"'\")\nIf i > 0 Then\n    st = Left(st, i - 1)\nEnd If\n\n'= separieren, damit eigener Wert\nst = Replace(st, \"=\", \" = \", 1)\n\n'aufdröseln, Jedes Wort in eine Zeile des Arrays getrennt durch \" \"\nj = 1\nAnzWd = ExtractWords(st, TestArray(), \" \", True)\nFor i = LBound(TestArray) To UBound(TestArray)\n    ' Debug.Print \"   String \" & i & \" : \" & TestArray(i)\n    If Len(Trim(Nz(TestArray(i)))) > 0 Then\n        If j < 5 Then\n            tst1(j) = TestArray(i)\n        End If\n        j = j + 1\n    End If\nNext i\n\n' Nach Txt2 alles \"zuviel aufgedröselte\" wieder in ein Textfeld\nIf Len(Trim(Nz(tst1(4)))) > 0 Then\n    i = InStr(st, tst1(3))\n    If i > 0 Then\n        tst1(3) = Mid(st, i)\n    End If\nEnd If\n   \n' OK jetzt auswerten\n' ####################\n\niStufe = UBound(stBeginArrType)\n\nIstBegin = False\n\nIf bMerk = True Then\n    bMerk = False\n    If stBeginArrType(iStufe) = \"VB.Frame\" Then\n        iIstFrame = 0\n    End If\n    iStufe = iStufe - 1\n    ReDim Preserve stBeginArrType(iStufe)\n    ReDim Preserve stBeginArrName(iStufe)\nEnd If\n       \nIf tst1(1) = \"End\" Then\n    bMerk = True\nEnd If\n\nIf tst1(1) = \"EndProperty\" Then\n        iIstFont = 0\nEnd If\n\nIf tst1(1) = \"Begin\" Then\n    ObjektNr = ObjektNr + 1\n    iStufe = iStufe + 1\n    ReDim Preserve stBeginArrType(iStufe)\n    ReDim Preserve stBeginArrName(iStufe)\n    stBeginArrType(iStufe) = tst1(2)\n    stBeginArrName(iStufe) = tst1(3)\n    IstBegin = True\n    If tst1(2) = \"VB.Frame\" Then\n        iIstFrame = 1\n    End If\nEnd If\n   \nIf tst1(1) = \"BeginProperty\" And tst1(2) = \"Font\" Then\n    iIstFont = 1\nEnd If\n\nEnd Function\n\n\nPrivate Function pgm_upd(IDfile As Long, tblAusgabeName As String)\nDim i1 As Long\nDim i2 As Long\nDim iAlt As Long\n\nDim fkt As String\n\nDim db As DAO.Database\nDim rst As DAO.Recordset\n\nDim st As String\nDim AnzWd, i, j\nDim tst() As String\n\nst = \"\"\nSet db = CurrentDb\nSet rst = db.OpenRecordset(\"SELECT * FROM \" & tblAusgabeName & \" WHERE IstPGM = True AND IDfile = \" & IDfile & \" Order by ID;\")\n\ni1 = 1\ni2 = 1\niAlt = 1\n\nfkt = \"\"\nWith rst\n    Do While Not .EOF\n        If rst!IDfile <> iAlt Then\n            fkt = \"\"\n            iAlt = rst!IDfile\n        End If\n    \n        st = Nz(rst!Memofeld)\n    \n        i1 = 0\n        If Left(st, 11) = \"Private Sub\" Then i1 = 1\n        If Left(st, 10) = \"Public Sub\" Then i1 = 1\n        If Left(st, 3) = \"Sub\" Then i1 = 1\n        If Left(st, 8) = \"Function\" Then i1 = 1\n        If Left(st, 16) = \"Private Function\" Then i1 = 1\n        If Left(st, 15) = \"Public Function\" Then i1 = 1\n        If Left(st, 7) = \"End Sub\" Then i1 = 2\n        If Left(st, 12) = \"End Function\" Then i1 = 2\n        \n        If bMerk = True Then\n            fkt = \"\"\n            bMerk = False\n        End If\n        \n        If i1 = 2 Then\n            bMerk = True\n        End If\n        \n        If i1 = 1 Then\n            j = 0\n            AnzWd = ExtractWords(st, TestArray(), \" \", True)\n            ReDim tst(UBound(TestArray))\n            For i = LBound(TestArray) To UBound(TestArray)\n                If Len(Trim(Nz(TestArray(i)))) > 0 Then\n                    tst(j) = TestArray(i)\n                    j = j + 1\n                End If\n            Next i\n            For i = 0 To UBound(TestArray)\n                If tst(i) = \"Function\" Or tst(i) = \"Sub\" Then\n                    fkt = tst(i + 1)\n                    Exit For\n                End If\n            Next i\n            i = InStr(1, fkt, \"(\")\n            If i > 0 Then\n                fkt = Left(fkt, i - 1)\n            End If\n        End If\n        .Edit\n            !FunctionSub = fkt\n        .update\n        .MoveNext\n    Loop\n    .Close\nEnd With\nSet rst = Nothing\n\nEnd Function"}
