{"id":"MOD_mdl_Word_Bookmark","name":"mdl_Word_Bookmark","kind":"standard","procedures":["Function WD_template_NonBookmark_Ausles_Test()","Function WD_template_NonBookmark_Ausles(iDokNr As Long, Doc_Template_Pfad_Name As String)","Function WordReplace(Doc_Template_Pfad_Name As String, Doc_Save_Pfad_Name As String)","Function Word_Insert_Table(Doc_Save_Pfad_Name As String)","Function Ust_Loesch(ustname As String, Doc_Save_Pfad_Name As String)","Function PDF_Print(Doc_Save_Pfad_Name As String)","Function Reset_Word_Objekt()","Function wd_Close_All()"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\n'Dim wdApp As Word.Application\n'Dim wdDoc As Word.Document\n'Dim wdRng As Word.Range\n'Dim wdTab As Word.Table\n'Dim wdRng2 As Word.Range\n'Dim Ins As Word.InlineShape\n'Dim wdTmp As Word.TEMPLATE\n\nDim wdApp As Object\nDim wdDoc As Object\nDim wdRng As Object\nDim wdTab As Object\nDim wdRng2 As Object\nDim Ins As Object\nDim wdTmp As Object\n\nConst wdToggle = 9999998\nConst wdSortByName = 0\nConst wdCharacter = 1\nConst wdLine = 5\n\nConst wdStory As Long = 6\nConst wdPrintView As Long = 3\nConst wdGoToBookmark As Long = -1\nConst wdOpenFormatAuto As Long = 0\nConst wdUseDestinationStylesRecovery As Long = 19\nConst wdUndefined As Long = 9999999\nConst wdReplaceAll As Long = 2\nConst wdFindContinue As Long = 1\nConst wdWithInTable As Long = 12\nConst wdFormatPDF As Long = 17\n\n\nFunction WD_template_NonBookmark_Ausles_Test()\n'Alle gelisteten Wordvorlagen neu einlesen / dem System bekanntmachen - Felder in Tabelle speichern\n'Ruft die Arbeitsfunktion \"WD_template_NonBookmark_Ausles\" auf, in der die eigentliche Arbeit erledigt wird\n'####################################################################################################\n\nDim iDocNr As Long, Doc_Template_Pfad_Name As String, CONSYS_Grund_Pfad As String\n\nDim ArrFill_DAO_OK1 As Boolean, recsetSQL1 As String, iZLMax1 As Long, iColMax1 As Long, DAOARRAY1, iZl As Long, iCol As Long\n\nCONSYS_Grund_Pfad = Get_Priv_Property(\"prp_CONSYS_GrundPfad\")\n\nrecsetSQL1 = \"SELECT ID, DocPfad, Docname FROM _tblEigeneFirma_TB_Dok_Dateinamen\"\nArrFill_DAO_OK1 = ArrFill_DAO_Acc(recsetSQL1, iZLMax1, iColMax1, DAOARRAY1)\n'Info:   'AccessArray(iSpalte,iZeile) <0, 0>\nIf ArrFill_DAO_OK1 Then\n    For iZl = 0 To iZLMax1\n        iDocNr = Nz(DAOARRAY1(0, iZl), 0)\n        Doc_Template_Pfad_Name = Nz(DAOARRAY1(1, iZl))\n        If Right(Doc_Template_Pfad_Name, 1) <> \"\\\" Then Doc_Template_Pfad_Name = Doc_Template_Pfad_Name & \"\\\"\n        Doc_Template_Pfad_Name = CONSYS_Grund_Pfad & Doc_Template_Pfad_Name & Nz(DAOARRAY1(2, iZl))\n        WD_template_NonBookmark_Ausles iDocNr, Doc_Template_Pfad_Name\n\n    Next iZl\n    Set DAOARRAY1 = Nothing\nEnd If\n\n\nwdApp.Quit False\n\nDoEvents\nDBEngine.Idle dbRefreshCache\nDBEngine.Idle dbFreeLocks\nDoEvents\n\n'iDocNr = 1\n'Doc_Template_Pfad_Name = \"C:\\Kunden\\CONSEC (Siegert)\\Rechnungsschreibung\\Neu\\CONSEC_Template_Rch.docx\"\n'\n'WD_template_NonBookmark_Ausles iDocNr, Doc_Template_Pfad_Name\n'\nEnd Function\n\nFunction WD_template_NonBookmark_Ausles(iDokNr As Long, Doc_Template_Pfad_Name As String)\n'Einzelne Wordvorlage neu einlesen / dem System bekanntmachen - Felder in Tabelle speichern\n'#############################################################################################################################\n\nDim tTmp As String\n\nDim Bmk() As String\nDim X As Integer, j As Integer\nDim i As Long\n\nDim Fill_Tbl_OK1 As Boolean, recsetSQL1 As String, InArray1\n\nDim firstTerm As String\nDim secondTerm As String\nDim documentText As String\n\nDim startPos As Long 'Stores the starting position of firstTerm\nDim stopPos As Long 'Stores the starting position of secondTerm based on first term's location\nDim nextPosition As Long 'The next position to search for the firstTerm\n\nOn Error Resume Next\nSet wdApp = GetObject(, \"Word.Application\")\nIf wdApp Is Nothing Then\n    err.clear\n    Set wdApp = CreateObject(\"Word.Application\")\nEnd If\nOn Error GoTo 0\n\ntTmp = Doc_Template_Pfad_Name\n\nSet wdDoc = wdApp.Documents.Add(tTmp)\n\n'wdApp.Visible = False\nwdApp.Visible = True\n'wdApp.ScreenUpdating = False   ' buggy - dont use\n'wdApp.Visible = False\n\nnextPosition = 1\n\n'First and Second terms as defined by your example.  Obviously, this will have to be more dynamic\n'if you want to parse more than justpatientFirstname.\nfirstTerm = \"[\"\nsecondTerm = \"]\"\n\n'Get all the document text and store it in a variable.\nSet wdRng = wdDoc.Range\n'Maximum limit of a string is 2 billion characters.\n'So, hopefully your document is not bigger than that.  However, expect declining performance based on how big doucment is\ndocumentText = wdRng.Text\n\ni = 0\n'Loop documentText till you can't find any more matching \"terms\"\nDo Until nextPosition = 0\n    startPos = InStr(nextPosition, documentText, firstTerm, vbTextCompare)\n    If startPos = 0 And i = 0 Then\n        Exit Function\n    End If\n    stopPos = InStr(startPos, documentText, secondTerm, vbTextCompare)\n    ReDim Preserve Bmk(1, i)\n    Bmk(0, i) = iDokNr\n'    Bmk(1, i) = Mid$(documentText, startPos + Len(firstTerm), stopPos - startPos - Len(secondTerm))  '' ohne [ ]\n    Bmk(1, i) = Mid$(documentText, startPos - 1 + Len(firstTerm), stopPos - startPos + 2 - Len(secondTerm))   '' mit  [ ]\n'    Debug.Print Mid$(documentText, startPos + Len(firstTerm), stopPos - startPos - Len(secondTerm))\n    nextPosition = InStr(stopPos, documentText, firstTerm, vbTextCompare)\n    i = i + 1\nLoop\n\n'MsgBox \"I'm done First Step\"\n\nConst wdFormatHTML As Long = 8\nConst wdFormatXPS As Long = 18\nConst wdFormatPDF As Long = 17\n\n'wdDoc.SaveAs2 \"C:\\Test\\Test_\" & iDokNr & \".pdf\", wdFormatPDF  'WdSaveFormat-Enum  - wdFormatPDF - 17\n'\nCurrentDb.Execute (\"DELETE * FROM _tblEigeneFirma_TB_Dok_Feldnamen WHERE DokNr = \" & iDokNr)\nDoEvents\nrecsetSQL1 = \"SELECT DokNr, Feldname FROM _tblEigeneFirma_TB_Dok_Feldnamen\"\n\n'  0 = ID\n'  1 = DokNr\n'  2 = Feldname\n\nFill_Tbl_OK1 = Fill_Tbl(recsetSQL1, Bmk)\n''Info:   'AccessArray(iSpalte,iZeile) <0, 0>       'ExcelArray(iZeile, iSpalte) <1, 1>\nDoEvents\n\nwdDoc.Close False\n\nDoEvents\nDBEngine.Idle dbRefreshCache\nDBEngine.Idle dbFreeLocks\nDoEvents\n\nEnd Function\n\n\nFunction WordReplace(Doc_Template_Pfad_Name As String, Doc_Save_Pfad_Name As String)\n'Die in Tabelle tbltmp_Textbaustein_Ersetzung bereits vorbereiteten und ersetzten Felder in Word ersetzen und Dokument sichern\n'#############################################################################################################################\nDim myStoryRange\nDim SearchStr As String\nDim ReplaceStr As String\nDim tTmp As String\nDim ArrFill_DAO_OK1 As Boolean, recsetSQL1 As String, iZLMax1 As Long, iColMax1 As Long, DAOARRAY1, iZl As Long, iCol As Long\nDim FiCrLf As String\nDim ergCr As String\nDim ergCr1 As String\n\n   On Error GoTo WordReplace_Error\n\nWDStart:\n\nSleep 100\n\nDoEvents\nDBEngine.Idle dbRefreshCache\nDBEngine.Idle dbFreeLocks\nDoEvents\n\nOn Error Resume Next\nSet wdApp = GetObject(, \"Word.Application\")\nIf wdApp Is Nothing Then\n    err.clear\n    \n    DoEvents\n    DBEngine.Idle dbRefreshCache\n    DBEngine.Idle dbFreeLocks\n    DoEvents\n    \n    Set wdApp = CreateObject(\"Word.Application\")\nEnd If\n\n   On Error GoTo WordReplace_Error\n\ntTmp = Doc_Template_Pfad_Name\n\nSet wdDoc = wdApp.Documents.Add(tTmp)\n\n'wdApp.Visible = False\nwdApp.Visible = True\nwdApp.ScreenUpdating = False   ' buggy - dont use\n'wdApp.Visible = False\n\nerr.clear\nOn Error GoTo 0\n\n'Warum in Word der Zeilenumbruch mit Chr$(11) Funktioniert, aber nicht mir CRLF wird mir ewig ein Rätsel bleiben\nFiCrLf = vbCrLf\nergCr = Chr$(11)\n\nrecsetSQL1 = \"Select TB_Name_Kl, Ersetzung FROM tbltmp_Textbaustein_Ersetzung\"\nArrFill_DAO_OK1 = ArrFill_DAO_Acc(recsetSQL1, iZLMax1, iColMax1, DAOARRAY1)\n'Info:   'AccessArray(iSpalte,iZeile) <0, 0>\nIf ArrFill_DAO_OK1 Then\n    For iZl = 0 To iZLMax1\n        SearchStr = Nz(DAOARRAY1(0, iZl))\n        'Text Trim\n        ReplaceStr = Trim(Nz(DAOARRAY1(1, iZl)))\n        'CrLf für Word durch Lf ersetzt\n        ReplaceStr = Replace(ReplaceStr, FiCrLf, ergCr, , , vbTextCompare)\n        ' Seltsames Phänomen, das Zeichen 129 bei Nürnberg zwischen ü und r zu setzen, eliminiert\n        ReplaceStr = Replace(ReplaceStr, Chr$(129), \"\", , , vbTextCompare)\n                \n        For Each myStoryRange In wdDoc.StoryRanges\n            With myStoryRange.Find\n                .Text = SearchStr\n                .Replacement.Text = ReplaceStr\n                .Wrap = wdFindContinue\n              '  .ClearFormatting\n              '  .Replacement.ClearFormatting\n                .Replacement.Highlight = wdUndefined\n                .Execute Replace:=wdReplaceAll\n            End With\n        Next myStoryRange\n    \n\n    Next iZl\n    Set DAOARRAY1 = Nothing\nEnd If\n\n'wdApp.ActiveDocument.SaveAs2 Chr(34) & Doc_Save_Pfad_Name & Chr(34)\nwdDoc.SaveAs2 Chr(34) & Doc_Save_Pfad_Name & Chr(34)\n\nwdApp.Visible = True\nwdApp.ScreenUpdating = True   ' buggy - dont use\n\n'wdDoc.Close False\n'\n'DoEvents\n'DBEngine.Idle dbRefreshCache\n'DBEngine.Idle dbFreeLocks\n'DoEvents\n'\n'wdApp.Quit False\n'\n'DoEvents\n'DBEngine.Idle dbRefreshCache\n'DBEngine.Idle dbFreeLocks\n'DoEvents\n\n   On Error GoTo 0\n   Exit Function\n\nWordReplace_Error:\n    If err.Number = 429 Then\n        Set wdApp = Nothing\n        Sleep 200\n        DoEvents\n        DBEngine.Idle dbRefreshCache\n        DBEngine.Idle dbFreeLocks\n        DoEvents\n        Sleep 100\n        DoEvents\n        GoTo WDStart\n\nElse\n    MsgBox \"Error \" & err.Number & \" (\" & err.description & \") in procedure WordReplace of Modul mdl_Word_Bookmark\"\nEnd If\n\nEnd Function\n\n\nFunction Word_Insert_Table(Doc_Save_Pfad_Name As String)\n'Positions-Tabelle in Word (Artikel Menge Preis) füllen und Dokument sichern\n'###########################################################################\nDim ArrFill_DAO_OK1 As Boolean, recsetSQL1 As String, iZLMax1 As Long, iColMax1 As Long, DAOARRAY1, DAOARRAY_Name1, iZl As Long, iCol As Long\n  Dim i As Long\n  Dim j As Long\n  Dim strErsatz As Variant\n  \n  'Recordset muss identisch mit Tabellenpositionsfeldern sein\n  recsetSQL1 = \"Select PosNr, Art_Beschreibung, Anz_MA, Menge, ME, EZPreis, GesPreis FROM tbltmp_Position order by PosNr\"\n  ArrFill_DAO_OK1 = ArrFill_DAO(recsetSQL1, iZLMax1, iColMax1, DAOARRAY1, DAOARRAY_Name1)\n   'Zusatztabelle mit Feldnamen (Zeile 0) und Feldtypen als Long (Zeile 1) und als Text (Zeile 2)\n   'NumArray = Array(dbBigInt, dbBinary, dbBoolean, dbByte, dbChar, dbCurrency, dbDate, dbDecimal, dbDouble, dbFloat, dbGUID, dbInteger, dbLong, dbLongBinary, dbMemo, dbNumeric, dbSingle, dbText, dbTime, dbTimeStamp, dbVarBinary)\n   'NumtxtArray = Array(\"dbBigInt\", \"dbBinary\", \"dbBoolean\", \"dbByte\", \"dbChar\", \"dbCurrency\", \"dbDate\", \"dbDecimal\", \"dbDouble\", \"dbFloat\", \"dbGUID\", \"dbInteger\", \"dbLong\", \"dbLongBinary\", \"dbMemo\", \"dbNumeric\", \"dbSingle\", \"dbText\", \"dbTime\", \"dbTimeStamp\", \"dbVarBinary\")\n   'Info:   'AccessArray(iSpalte,iZeile) <0, 0>       'ExcelArray(iZeile, iSpalte) <1, 1>\n    'Tabelle Tabelle_Pos\n    If ArrFill_DAO_OK1 Then\n    ' i = Anzahl der Überschriftszeilen\n        i = 1\n        Set wdTab = wdDoc.Bookmarks(\"Tabelle_Pos\").Range.tables(1)\n        For iZl = 0 To iZLMax1\n            i = i + 1\n            'Felder für Word \"schön\" formatieren....\n            For j = 0 To iColMax1\n                If DAOARRAY_Name1(j, 1) = dbCurrency Then\n                    strErsatz = FormatCurrency(Nz(DAOARRAY1(j, iZl)))\n                ElseIf DAOARRAY_Name1(j, 1) = dbDouble Or DAOARRAY_Name1(j, 1) = dbFloat Or DAOARRAY_Name1(j, 1) = dbSingle Then\n                    strErsatz = FormatNumber(Nz(DAOARRAY1(j, iZl)), 2)\n                Else\n                    strErsatz = Nz(DAOARRAY1(j, iZl))\n                End If\n                '.... bevor der Wert nach Word gesetzt wird\n                wdTab.Cell(i, j + 1).Range.Text = strErsatz\n            Next j\n            If iZl < iZLMax1 Then\n                wdTab.rows.Add\n            End If\n        Next iZl\n        Set DAOARRAY1 = Nothing\n    End If\n\n'wdApp.ActiveDocument.SaveAs2 Chr(34) & Doc_Save_Pfad_Name & Chr(34)\nwdDoc.SaveAs2 Chr(34) & Doc_Save_Pfad_Name & Chr(34)\n\nEnd Function\n\nFunction Ust_Loesch(ustname As String, Doc_Save_Pfad_Name As String)\n'Word: Tabellenzeile (mit UstWert = 0) löschen und Dokument sichern\n'###################################################################\nDim oTable As Object\nDim oCurrentRow As Object\nwdApp.Selection.GoTo What:=wdGoToBookmark, Name:=ustname\n\nIf Not wdApp.Selection.Information(wdWithInTable) Then\nExit Function\nEnd If\n\nwdApp.Selection.rows(1).Delete\n\n'wdApp.ActiveDocument.SaveAs2 Chr(34) & Doc_Save_Pfad_Name & Chr(34)\nwdDoc.SaveAs2 Chr(34) & Doc_Save_Pfad_Name & Chr(34)\n\nEnd Function\n\nFunction PDF_Print(Doc_Save_Pfad_Name As String)\n' Word Dokument als PDF ausgeben\n'################################\n    Dim i As Long\n    Dim strdoc As String\n    i = InStrRev(Doc_Save_Pfad_Name, \".\")\n    If i > 0 Then\n        strdoc = Left(Doc_Save_Pfad_Name, i) & \"pdf\"\n        wdDoc.SaveAs2 strdoc, wdFormatPDF   'WdSaveFormat-Enum  - wdFormatPDF - 17\n    End If\nEnd Function\n\n\n\nFunction Reset_Word_Objekt()\n\nSet wdDoc = Nothing\nSet wdApp = Nothing\n\nEnd Function\n\n\nFunction wd_Close_All()\n\nOn Error Resume Next\n\nwdApp.Quit False\n\nDoEvents\nDBEngine.Idle dbRefreshCache\nDBEngine.Idle dbFreeLocks\nDoEvents\n\nEnd Function\n\n\n\n'For Each myStoryRange In ActiveDocument.StoryRanges\n'    With myStoryRange.Find\n'        .Text = \"string to be searched\"\n'        .Replacement.Text = \"string to be replaced\"\n'        .Wrap = wdFindContinue\n'        .ClearFormatting\n'        .Replacement.ClearFormatting\n'        .Replacement.Highlight = False\n'        .Execute Replace:=wdReplaceAll\n'    End With\n'Next myStoryRange\n\n''Function PDF_Print(iDokNr As Long)\n''    Dim p\n''    p = wdApp.ActivePrinter\n''    wdApp.ActivePrinter = \"PDFCreator\"\n''    wdApp.Options.PrintBackground = False\n''    wdDoc.PrintOut 'Outputfilename:=\"C:\\test\\test_\" & iDokNr & \".pdf\", PrintToFile:=True\n''    DoEvents\n''    wdApp.ActivePrinter = p\n''    Stop\n''End Function\n'\n'\n'' neuen COM-Schnittstelle im PDF-Creator 2.\n'Sub PdfWithPDFCreatorZwei()\n'\n'Dim pdfJob              As Object\n'Dim printJob            As Object\n'Dim wshNetwork          As Object\n'\n'Dim bolSendAsAttach     As Boolean\n'\n'Const Drucker1          As String = \"PDFCreator\"\n'Dim Drucker2    '       As String = \"Samsung ML-2850 Series\"\n'\n'Drucker2 = wdApp.ActivePrinter\n'\n'If MsgBox(\"Soll die Datei nach dem Erstellen versendet werden?\", 36, \"Senden?\") = vbYes Then bolSendAsAttach = True\n'\n'On Error GoTo Ende\n'\n'Set pdfJob = CreateObject(\"PDFCreatorBeta.JobQueue\")\n'\n'    pdfJob.Initialize\n'\n'Set wshNetwork = CreateObject(\"WScript.Network\")\n'    wshNetwork.SetDefaultPrinter Drucker1 'Standarddrucker auf PDFCreator setzen\n'\n'    Worksheets(\"Tabelle1\").PrintOut\n'\n'    pdfJob.WaitForJob (10)\n'\n'    Set printJob = pdfJob.NextJob\n'\n'        With printJob\n'            .SetProfileByGuid (\"DefaultGuid\")\n'\n'            If bolSendAsAttach Then\n'              .SetProfileSetting \"EmailClient.Enabled\", \"true\" 'Datei als Email senden einschalten\n'              .SetProfileSetting \"EmailClient.Subject\", \"Test\" 'Betreff\n'              .SetProfileSetting \"EmailClient.Content\", \"Hallo,<br><br>anbei gewünschte Unterlagen.\" & _\n'                                                        \"<br><br>Gruß, Max<br><br>\" 'Body\n'              .SetProfileSetting \"EmailClient.Recipients\", \"test@server.de;test2@server.de\" 'Empfänger\n'            End If\n'\n'            .ConvertTo (Environ(\"USERPROFILE\") & \"\\Desktop\\Test.pdf\") 'Pfad und Dateiname für PDF-Datei, und konvertieren\n'\n'           If .IsFinished = True Then\n'              pdfJob.ReleaseCom 'PDFCreator-Instanz beenden\n'              wshNetwork.SetDefaultPrinter Drucker2 'Standarddrucker wiederherstellen\n'           End If\n'        End With\n'\n'Exit Sub\n'\n'Ende:\n'pdfJob.ReleaseCom\n'End Sub\n'\n'\n\n\n' Alte PDFCreator Version vor 12.73\n'Sub PrintToPDF_Early(iDokNr As Long)\n'     'Author       : Ken Puls ([url]www.excelguru.ca[/url])\n'     'Macro Purpose: Print to PDF file using PDFCreator\n'     '   (Download from [url]http://sourceforge.net/projects/pdfcreator/[/url])\n'     '   Designed for early bind, set reference to PDFCreator\n'\n'\n'   Dim pdfJob As PDFCreator.clsPDFCreator\n''    Private WithEvents pdfjob As PDFCreator.clsPDFCreator\n'    Dim pdfApp As Object\n''    Dim pdfjob As Object\n'    Dim sPDFName As String\n'    Dim sPDFPath As String\n'\n'\n'\n'     Dim p\n'    p = wdApp.ActivePrinter\n'\n'     '/// Change the output file name here! ///\n'    sPDFName = \"test_\" & iDokNr & \".pdf\"\n'    sPDFPath = \"C:\\Test\\\"\n'    sPDFPath = ActiveDocument.path & Application.PathSeparator\n'\n''    On Error Resume Next\n''    'Set pdfjob = GetObject(, \"PDFCreator.clsPDFCreator\")\n''    Set pdfApp = GetObject(, \"PDFCreator\")\n''    If pdfApp Is Nothing Then\n''        Err.Clear\n''    '    Set pdfjob = CreateObject(\"PDFCreator.clsPDFCreator\")\n''        Set pdfApp = CreateObject(\"PDFCreator\")\n''    End If\n''    On Error GoTo 0\n'\n'    'Early Binding\n'    Set pdfJob = New PDFCreator.clsPDFCreator\n'\n'    With pdfJob\n'        If .cStart(\"/NoProcessingAtStartup\") = False Then\n'            MsgBox \"Can't initialize PDFCreator.\", vbCritical + _\n'            vbOKOnly, \"PrtPDFCreator\"\n'            Exit Sub\n'        End If\n'        .cOption(\"UseAutosave\") = 1\n'        .cOption(\"UseAutosaveDirectory\") = 1\n'        .cOption(\"AutosaveDirectory\") = sPDFPath\n'        .cOption(\"AutosaveFilename\") = sPDFName\n'        .cOption(\"AutosaveFormat\") = 0 ' 0 = PDF\n'        .cClearCache\n'    End With\n'\n'     'Print the document to PDF\n'    wdApp.ActivePrinter = \"PDFCreator\"\n'    wdDoc.PrintOut\n'\n'     'Wait until the print job has entered the print queue\n'    Do Until pdfJob.cCountOfPrintjobs = 1\n'        DoEvents\n'    Loop\n'    pdfJob.cPrinterStop = False\n'\n'     'Wait until PDF creator is finished then release the objects\n'    Do Until pdfJob.cCountOfPrintjobs = 0\n'        DoEvents\n'    Loop\n'    pdfJob.cClose\n'    Set pdfJob = Nothing\n'\n'    wdApp.ActivePrinter = p\n'\n'    Stop\n'\n'End Sub\n'\n\n\n''' ########### VBA Teilstücke\n\n''Dim Doc_Template_Pfad As String\n''Dim Doc_Template_Name As String\n'\n'Function WD_template_Bookmark_Ausles_Test()\n'\n'Dim iDocNr As Long, Doc_Template_Pfad_Name As String\n'\n'iDocNr = 1\n'Doc_Template_Pfad_Name = \"C:\\Kunden\\CONSEC (Siegert)\\Rechnungsschreibung\\Neu\\CONSEC_Template_Rch.docx\"\n'\n'WD_template_Bookmark_Ausles iDocNr, Doc_Template_Pfad_Name\n'\n'End Function\n'\n'\n'Function WD_template_Bookmark_Ausles(iDocNr As Long, Doc_Template_Pfad_Name As String)\n'\n'Dim tTmp As String\n'\n'Dim Bmk() As String\n'Dim x As Integer, J As Integer\n'\n'Dim Fill_Tbl_OK1 As Boolean, recsetSQL1 As String, InArray1\n'\n''Doc_Template_Pfad = \"C:\\Kunden\\CONSEC (Siegert)\\Rechnungsschreibung\\Neu\\\"\n''Doc_Template_Name = \"CONSEC_Template_Rch.docx\"\n'\n'On Error Resume Next\n'Set wdApp = GetObject(, \"Word.Application\")\n'If wdApp Is Nothing Then\n'    Err.Clear\n'    Set wdApp = CreateObject(\"Word.Application\")\n'End If\n'On Error GoTo 0\n'\n'tTmp = Doc_Template_Pfad_Name\n'Set wdDoc = wdApp.Documents.Add(tTmp)\n'\n''wdApp.Visible = False\n'wdApp.Visible = True\n''wdApp.ScreenUpdating = False   ' buggy - dont use\n''wdApp.Visible = False\n'\n'x = wdDoc.Bookmarks.count\n'ReDim Bmk(2, x - 1)\n'For J = 0 To x - 1\n'    Bmk(0, J) = iDocNr\n'    Bmk(1, J) = Nz(wdDoc.Bookmarks(J + 1).Name)\n'    Bmk(2, J) = Nz(wdDoc.Bookmarks(J + 1).Range.Text)\n'Next J\n'\n'recsetSQL1 = \"SELECT DOkNr, Bookmark_Name, Bookmark_Content FROM tbl_Textbaustein_Dokumente\"\n'\n''  0 = ID\n''  1 = Pfad\n''  2 = Name\n''  3 = Bookmark_Name\n''  4 = Bookmark_Content\n'\n'Fill_Tbl_OK1 = Fill_Tbl(recsetSQL1, Bmk)\n'''Info:   'AccessArray(iSpalte,iZeile) <0, 0>       'ExcelArray(iZeile, iSpalte) <1, 1>\n'\n'End Function\n\n\n\n'            Set wdRng = wdDoc.Range\n'            'Maximum limit of a string is 2 billion characters.\n'            'So, hopefully your document is not bigger than that.  However, expect declining performance based on how big doucment is\n'             wdRng.Text = documentText\n'\n'\n'\n'            'x = wdDoc.Bookmarks.count\n'            'ReDim Preserve Bmk(2, x - 1)\n'            'For J = 0 To x - 1\n'            '    Bmk(0, J) = 1\n'            '    Bmk(1, J) = Nz(wdDoc.Bookmarks(J + 1).Name)\n'            '    Bmk(2, J) = Nz(wdDoc.Bookmarks(J + 1).Range.Text)\n'            'Next J\n\n\n'Sub findTest()\n'\n'    Dim firstTerm As String\n'    Dim secondTerm As String\n'    Dim myRange As Range\n'    Dim documentText As String\n'\n'    Dim startPos As Long 'Stores the starting position of firstTerm\n'    Dim stopPos As Long 'Stores the starting position of secondTerm based on first term's location\n'    Dim nextPosition As Long 'The next position to search for the firstTerm\n'\n'    nextPosition = 1\n'\n'    'First and Second terms as defined by your example.  Obviously, this will have to be more dynamic\n'    'if you want to parse more than justpatientFirstname.\n'    firstTerm = \"[\"\n'    secondTerm = \"]\"\n'\n'    'Get all the document text and store it in a variable.\n'    Set wdRng = wdDoc.Range\n'    'Maximum limit of a string is 2 billion characters.\n'    'So, hopefully your document is not bigger than that.  However, expect declining performance based on how big doucment is\n'    documentText = wdRng.Text\n'\n'    'Loop documentText till you can't find any more matching \"terms\"\n'    Do Until nextPosition = 0\n'        startPos = InStr(nextPosition, documentText, firstTerm, vbTextCompare)\n'        stopPos = InStr(startPos, documentText, secondTerm, vbTextCompare)\n'        Debug.Print Mid$(documentText, startPos + Len(firstTerm), stopPos - startPos - Len(secondTerm))\n'        nextPosition = InStr(stopPos, documentText, firstTerm, vbTextCompare)\n'    Loop\n'\n'    MsgBox \"I'm done\"\n'\n'End Sub\n\n\n\n'Sub ReplaceWithBookmarks()\n'    Dim rng As Range\n'    Dim iBookmarkSuffix As Integer\n'    Dim strBookMarkPrefix\n'\n'    strBookMarkPrefix = \"BM\"\n'\n'    Set rng = ActiveDocument.Range\n'    With rng.Find\n'        .Text = \"XXX\"\n'        Do While .Execute\n'            rng.Text = \"\" 'clear the \"XXX\" (optional)\n'            iBookmarkSuffix = iBookmarkSuffix + 1\n'            ActiveDocument.Bookmarks.Add strBookMarkPrefix & iBookmarkSuffix, rng\n'        Loop\n'    End With\n'End Sub\n\n\n'With ActiveDocument.Range.Find\n'    .Text = \"Suchtext\"\n'    .Replacement.Text = \"neuer Text\"\n'    .Execute\n'End With\n'\n'\n'Dim orng As Range\n'Set orng = ActiveDocument.Range\n'orng.Start = orng.Bookmarks(\"StartBM\").Range.End\n'orng.End = orng.Bookmarks(\"EndBM\").Range.Start\n'orng.Select\n"}
