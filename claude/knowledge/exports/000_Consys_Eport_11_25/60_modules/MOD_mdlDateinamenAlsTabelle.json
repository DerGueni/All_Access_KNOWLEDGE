{"id":"MOD_mdlDateinamenAlsTabelle","name":"mdlDateinamenAlsTabelle","kind":"standard","procedures":["Function LOWord(X As Long) As Integer","Function HIWord(X As Long) As Integer","Function RdfiInf(strTblName As String, ByVal strFolderName As String, _","Sub ReadFileInfos(strTblName As String, ByVal strFolderName As String, _","Sub ReadFolderInfo(rs As DAO.Recordset, strFolderName As String, IstAbs As Boolean)"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\n'========================================================================\n'ACHTUNG: die Reihenfolge der Parameter beim Aufruf wurde geändert !!!!!!\n'\n'ist jetzt\n'* Call ReadFileInfos(\"DeineTablelle\", \"DeinStartVerzeichnis\" [,\"DeineMDB\"] )\n'Den MDB-Namen habi ich nach hinten versetzt. Wenn er nicht mit angegeben wird,\n'ist es automatisch die eigene MDB\n'========================================================================\n\n'**********************************************************************************\n'* Aus der deutschen MS KnowledgeBase\n'**********************************************************************************\n'* Art.Nr.: D33747\n'* Tabelle mit Datei-Informationen eines Verzeichnisbaums füllen (VB5)\n'* ===================================================================\n'* Beispiel:\n'* Call ReadFileInfos(\"tblNeuDateinamen\", \"C:\\Eigene Dateien\" )\n'*\n'* Änderung am 7.3.1999 strDatabaseName ans Ende und Optional und (\"[Current]\") als Default\n'*                      Sofern die Tabelle bereits existiert, wird sie vorher gelöscht, doEvents eingefügt\n'*                      Rekursionsfunktion mit Beispiel für selektive Dateitypen (z.B. nur Bilder)\n'*\n'* legt in der Tabelle \"tblNeuDateinamen\" alle Dateinamen etc...\n'* aus dem Subdirectory \"C:\\Eigene Dateien\" in der eigenen MDB ab\n'* Aber statt [Current] ein absoluter Pfadname \"C:\\hugo\\meine.mdb\" geht auch ...\n'* In der Rekursionsfunktion ist der Befehl:\n'*       rs!Ordner = Mid(strFolderName, giMainFolderStrLen + 1)\n'* auskommentiert, und dafür\n'*       rs!Ordner = strFolderName\n'* gesetzt, da ich absolute Pfadnamen (incl. der Eingabe) sinnvoller finde ...\n'* ansonsten wird im Ordner nur \"\\\" für den \"current Pfad\" angelegt.\n'* so wird z.B.: \"C:\\Eigene Dateien\\\" als Ordner zurückgegeben.\n'* Der Laufwerksbuchstabe wird nicht dazugesetzt, d.h. wenn der Laufwerksbuchstabe\n'* Im Ordner gewünscht ist, so muß er bei der Übergabe (in strFolderName)\n'* mit angegeben werden.\n'**********************************************************************************\n\nPrivate Type FileInfo\n    wLength As Integer\n    wValueLength As Integer\n    szKey As String * 16\n    dwSignature As Long\n    dwStrucVersion As Long\n    dwFileVersionMS As Long\n    dwFileVersionLS As Long\nEnd Type\n\n'**********************************************************************************\n'* Funktionsvereinbarungen für die APIs:\n'*\n'**********************************************************************************\nPrivate Declare PtrSafe Function GetFileVersionInfo& Lib \"version\" _\n    Alias \"GetFileVersionInfoA\" _\n    (ByVal fileName$, ByVal dwHandle&, ByVal cbBuff&, ByVal lpvData$)\n\nPrivate Declare PtrSafe Function GetFileVersionInfoSize& Lib \"version\" _\n    Alias \"GetFileVersionInfoSizeA\" _\n    (ByVal fileName$, dwHandle&)\n\nPrivate Declare PtrSafe Sub hmemcpy Lib \"kernel32\" _\n    Alias \"RtlMoveMemory\" _\n    (hpvDest As Any, hpvSource As Any, ByVal cbBytes&)\n\n'**********************************************************************************\n'* globale Hilfsvariable\n'*\n'**********************************************************************************\nDim giMainFolderStrLen As Integer\n\n'* globale Konstante\nConst gcMaxSubfolders = 250\n'* nur die ersten 250 Unterverzeichnisse pro Ebene berücksichtigen\n\n'**********************************************************************************\n'* Hilfsfunktionen:\n'*\n'**********************************************************************************\nFunction LOWord(X As Long) As Integer\nOn Error Resume Next\nLOWord = X And &HFFFF&\n'Low 16 bits contain Minor revision number.\nEnd Function\n\nFunction HIWord(X As Long) As Integer\nOn Error Resume Next\nHIWord = X \\ &HFFFF&\n'High 16 bits contain Major revision number.\nEnd Function\n\n\nFunction RdfiInf(strTblName As String, ByVal strFolderName As String, _\n    Optional strDatabaseName As String = \"[Current]\")\n    Call ReadFileInfos(strTblName, strFolderName, strDatabaseName, False)\nEnd Function\n\n'**********************************************************************************\n'* Hauptfunktion:\n'**********************************************************************************\nSub ReadFileInfos(strTblName As String, ByVal strFolderName As String, _\n    Optional strDatabaseName As String = \"[Current]\", Optional IstAbs As Boolean = True)\n'**********************************************************************************\n'* Beispiel:\n'* Call ReadFileInfos(\"tblNeuDateinamen\", \"C:\\Eigene Dateien\")\n'* Call ReadFileInfos(\"tblNeuDateinamen\", \"C:\\Eigene Dateien\", \"C:\\Programme\\Microsoft Office\\Office\\Nordwind.mdb\")\n'*\n'* Änderung am 7.3.1999 strDatabaseName ans Ende und Optional\n'*                      Sofern die Tabelle bereits existiert, wird sie vorher gelöscht\n'*\n'* Öffnet die ACCESS-Datenbank mit dem in strDatabaseName_\n'* übergebenen Namen, bzw. legt diese neu an, wenn nicht vorhanden. _\n'* Legt dort eine neue Tabelle mit dem in strTblName übergebenen _\n'* Namen an und speichert darin die Datei-Informationen des _\n'* Verzeichnisbaums mit der in strFolderName _\n'* übergebenen Wurzel.\n'*\n'**********************************************************************************\n\nDim db As DAO.Database\nDim rs As DAO.Recordset\nDim td As TableDef\nDim fld As field\nDim tbl As DAO.Recordset\n\nDoCmd.Hourglass True\n\ngiMainFolderStrLen = Len(strFolderName)\n\n'* Das if [Current] habe ich eingefügt, um die Tabelle\n'* ggf. in der laufenden DB einfügen zu können\nIf strDatabaseName = \"[Current]\" Then   ' Verwende CurrentDb\n    Set db = CurrentDb\nElse\n    If Dir(strDatabaseName) = \"\" Then ' Datenbank existiert nicht\n        Set db = DBEngine.CreateDatabase(strDatabaseName, dbLangGeneral)\n    Else    ' Datenbank existiert\n        Set db = DBEngine.OpenDatabase(strDatabaseName)\n    End If\nEnd If\n\n'Tabelle löschen, sofern vorhanden, Fehler (Tabelle nicht vorhanden) ignorieren\nOn Error Resume Next\ndb.TableDefs.Delete strTblName\nOn Error GoTo 0\n\nDoEvents\nSleep 20\nDoEvents\n\nSet td = db.CreateTableDef(strTblName)\n' Felder hinzufügen.\nSet fld = td.CreateField(\"Ordner\", dbText, 255)\ntd.fields.append fld\nSet fld = td.CreateField(\"Dateiname\", dbText, 255)\ntd.fields.append fld\nSet fld = td.CreateField(\"Version\", dbText, 50)\ntd.fields.append fld\nSet fld = td.CreateField(\"Datum\", dbDate)\ntd.fields.append fld\nSet fld = td.CreateField(\"Länge\", dbDouble)\ntd.fields.append fld\n' TableDef-Definition durch Anfügen an TableDefs-Auflistung speichern.\ndb.TableDefs.append td\n\nSet rs = db.OpenRecordset(strTblName)\n\nIf Right(strFolderName, 1) <> \"\\\" Then strFolderName = strFolderName & \"\\\"\nReadFolderInfo rs, strFolderName, IstAbs\nrs.Close\n\n'* Von mir eingefügt, um die aktuelle DB nicht zu schließen\nIf strDatabaseName <> \"[Current]\" Then\n    db.Close\nElse\n    Set db = Nothing\nEnd If\n\nDoCmd.Hourglass False\n\nEnd Sub\n\n'**********************************************************************************\n'* Rekursionsfunktion:\n'**********************************************************************************\n'* Diese Funktion wird von ReadFileInfos(..) aufgerufen und ruft sich\n'* jedesmal selber auf, wenn der untersuchte Verzeichniseintrag ein\n'* Unterverzeichnis ist. Alle übrigen Dateieinträge werden im übergebenen\n'* Recordset-Objekt gespeichert.\n'**********************************************************************************\n\nSub ReadFolderInfo(rs As DAO.Recordset, strFolderName As String, IstAbs As Boolean)\n\nDim arrFoldernames(gcMaxSubfolders)\nDim fileName As String\nDim X As FileInfo\nDim FileVer As String\nDim dwHandle&, BUFSIZE&, lpvData$, r&\nDim iLoop As Long, iLoop2 As Long, Types As String\n\nfileName = Dir(strFolderName, vbDirectory)\niLoop = -1\n\n'* nur die ersten 250 Unterverzeichnisse berücksichtigen\n'* (Const gcMaxSubfolders = 250)\nWhile fileName <> \"\" And iLoop < gcMaxSubfolders\n    If fileName <> \".\" And fileName <> \"..\" And fileName <> \"\" Then\n        '* Mit bitweisem Vergleich sicherstellen, daß Name1 ein\n        '* Verzeichnis ist.\n        If (GetAttr(strFolderName & fileName) And vbDirectory) = vbDirectory Then\n            iLoop = iLoop + 1\n            arrFoldernames(iLoop) = fileName\n        Else\n''############# nur bestimmte Dateitypen selektieren (siehe auch weiter unten)\n'          ' Um nur bestimmte Dateitypen einzulesen: (auskommentiert, daher alle Dateien)\n'            Types = UCase(Right(FileName, 3))\n'            Select Case Types\n'                Case \"JPG\", \"PCD\", \"PCX\", \"WMF\", \"EMF\", \"DIB\", \"BMP\", \"ICO\", \"EPS\", \"PCT\", \"DXF\", \"CGM\", \"CDR\", \"TGA\", \"GIF\", \"PNG\", \"WPG\", \"DRW\", \"TIF\"\n'                ' Es handelt sich um eine Bild-Datei\n''#############\n            '*** Version Information lesen, wenn vorhanden ****\n                  FileVer = \"\"\n                  BUFSIZE& = GetFileVersionInfoSize(strFolderName & fileName, dwHandle&)\n                  If BUFSIZE& = 0 Then\n                      FileVer = \"no Version\"\n                  Else\n                      lpvData$ = Space$(BUFSIZE&)\n                      r& = GetFileVersionInfo(strFolderName & fileName, dwHandle&, BUFSIZE&, lpvData$)\n                      hmemcpy X, ByVal lpvData$, Len(X)\n                      \n                      '**** Datei Versions-Nummer interpretieren ****\n                      FileVer = Trim$(str$(HIWord(X.dwFileVersionMS))) + \".\"\n                      FileVer = FileVer + Trim$(str$(LOWord(X.dwFileVersionMS))) + \".\"\n                      FileVer = FileVer + Trim$(str$(HIWord(X.dwFileVersionLS))) + \".\"\n                      FileVer = FileVer + Trim$(str$(LOWord(X.dwFileVersionLS)))\n                  End If\n                  rs.AddNew\n                \n                  If IstAbs = False Then\n                    '  gibt ohne den eingegebenen Pfad (relativ) zurück\n                      rs!Ordner = Mid(strFolderName, giMainFolderStrLen + 1)\n                  Else\n                    '\n                    '  gibt mit eingegebenem Pfad (absolut) zurück\n                      rs!Ordner = Trim(strFolderName)\n                  End If\n                  \n                  If Right(rs!Ordner, 2) = \"\\\\\" Then rs!Ordner = Left(rs!Ordner, Len(rs!Ordner) - 1)\n                  If Right(rs!Ordner, 1) <> \"\\\" Then rs!Ordner = rs!Ordner & \"\\\"\n                  \n                  rs!Dateiname = fileName\n                  rs!Länge = fileLen(strFolderName & fileName)\n                  rs!Datum = FileDateTime(strFolderName & fileName)\n                  rs!version = FileVer\n                  rs.update\n''############# nur bestimmte Dateitypen selektieren\n'                Case Else\n'            End Select\n''################\n        End If\n    End If\n    fileName = Dir\n    DoEvents\nWend\n\nFor iLoop2 = 0 To iLoop\n    ReadFolderInfo rs, strFolderName & arrFoldernames(iLoop2) & \"\\\", IstAbs\n    DoEvents\nNext iLoop2\n\nEnd Sub\n"}
