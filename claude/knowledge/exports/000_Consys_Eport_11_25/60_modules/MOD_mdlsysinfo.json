{"id":"MOD_mdlsysinfo","name":"mdlsysinfo","kind":"standard","procedures":["Public Function atCNames(UOrC As Integer) As String","Public Function atCNames1(UOrC As Integer) As String","Private Function IsWinNT4Plus() As Boolean","Function atWinver(intOSInfo%) As Variant","Public Function atGetSysStatus(intStatus As Integer) As Variant","Function atDiskFreeSpace(Drive As String) As String","Function atDiskFreeSpaceEx(Drive As String, Optional MsgBoxOnErr As Boolean = True) As String","Public Function atGetColourCap() As String","Public Function TwipsPerPixelX() As Single","Public Function TwipsPerPixelY() As Single","Public Function atGetdevcaps%(ByVal intCapability%)","Function atGetjetver() As String","Public Function atGetMem(intInfoItem As Integer) As Variant","Public Function atGetMemEx(intInfoItem As Integer) As Variant","Public Function atDriveType(Drive As String) As Long","Function GetWinDir() As String","Function GetSysDir() As String","Function GetTempDir() As String","Function GetAktDir() As String","Function GetClassName(hwnd As Long) As String","Function FlpFormat()","Function getEnviromentVar(ByVal strEnviroment_IN As String) As String","Function XFree(path)","Function DOSPgmStart(DosAufruf As String, Optional AufrufArt As Integer = vbMinimizedNoFocus)","Function WriteSystemTbl()","Function WinSerNr() As String","Public Function getMDBVersion(fileName As String) As String","Function conn_dbname(s As String, su As String) As String"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database   'Use database order for string comparisons\nOption Explicit\n\n'--------------------------------------------------------------------------\n'System Info by ATTAC Consulting Group, Ann Arbor, MI  USA\n'Copyright © 1995-98,  All rights reserved.\n\n'This is an Access 95 and 97 sample of a System Information Dialog\n'that you can import into your applications.  The code is freely distributable.\n\n'For other Access Developer's tools, tips and files visit us on the web at\n'http://ourworld.compuserve.com/homepages/attac-cg/acgsoft.htm\n\n'Our e-mail address is:\n'mailto:  75323.2112@Compuserve.com\n\n'NOTICE OF DISCLAIMER:\n'=========================\n'This Software is provided \"As Is\" without warranty of any kind.  ATTAC\n'Consulting Group expressly disclaims any warrenty regarding\n'merchantablity, performance or usability for any purpose whatsoever.\n'ATTAC Consulting Group disclaims all liability for any damages,\n'or loss including loss of data, or loss of business profits from use or inability\n'to use the Software or any other pecuniary loss real, consequential or otherwise\n'arrising in the course of use of this Software.\n'---------------------------------------------------------------------------------\n\nPrivate Declare PtrSafe Function TerminateProcess Lib \"kernel32.dll\" (ByVal ApphProcess As Long, _\nByVal uExitCode As Long) As Long\n\n\n' Es wird noch das Modul mdlRegistry verwendet.\n\n'Implementation by ATTAC Consulting Group, Ann Arbor, MI USA.  Freely Distributed\n\nDeclare PtrSafe Function MakePath Lib \"imagehlp.dll\" Alias \"MakeSureDirectoryPathExists\" (ByVal lpPath As String) As Long\nPublic Declare PtrSafe Sub Sleep Lib \"kernel32\" (ByVal dwMilliseconds As Long)\n\nPrivate Declare PtrSafe Function api_GetDiskFreeSpace Lib \"kernel32\" Alias \"GetDiskFreeSpaceA\" (ByVal lpRootPathName As String, lpSectorsPerCluster As Long, lpBytesPerSector As Long, lpNumberOfFreeClusters As Long, lpTtoalNumberOfClusters As Long) As Long\nPrivate Declare PtrSafe Function api_GetDiskFreeSpaceEx Lib \"kernel32\" Alias \"GetDiskFreeSpaceExA\" (ByVal lpRootPathName As String, lpFreeBytesAvailableToCaller As Currency, lpTotalNumberOfBytes As Currency, lpTotalNumberOfFreeBytes As Currency) As Long\nPrivate Declare PtrSafe Function api_GetDriveType Lib \"kernel32\" Alias \"GetDriveTypeA\" (ByVal lpRootPathName As String) As Long\nPrivate Declare PtrSafe Sub GetSystemInfo Lib \"kernel32\" (lpSystemInfo As SYSTEM_INFO)\n\n' war im Original\n'Private Declare PtrSafe Function GetVersionEx Lib \"kernel32\" Alias \"GetVersionExA\" (lpOSInfo As OSVERSIONINFO) As Boolean\n\n'defined As Any to support OSVERSIONINFO and OSVERSIONINFOEX\nPrivate Declare PtrSafe Function GetVersionEx Lib \"kernel32\" Alias \"GetVersionExA\" _\n  (lpOSInfo As Any) As Long\n\nPrivate Declare PtrSafe Function GlobalMemoryStatusEx Lib \"kernel32.dll\" (ByRef lpBuffer As MemoryStatusEx) As Long\n\nPrivate Declare PtrSafe Sub GlobalMemoryStatus Lib \"kernel32\" (lpBuffer As MEMORYSTATUS)\nPrivate Declare PtrSafe Function api_GetUserName Lib \"advapi32.dll\" Alias \"GetUserNameA\" (ByVal lpBuffer As String, nSize As Long) As Long\nPrivate Declare PtrSafe Function api_GetComputerName Lib \"kernel32\" Alias \"GetComputerNameA\" (ByVal lpBuffer As String, nSize As Long) As Long\nPrivate Declare PtrSafe Function api_CreateIC Lib \"gdi32\" Alias \"CreateICA\" (ByVal lpDriverName As String, ByVal lpDeviceName As Any, ByVal lpOutput As Any, ByVal lpInitData As Any) As Long\nPrivate Declare PtrSafe Function api_DeleteDC Lib \"gdi32\" Alias \"DeleteDC\" (ByVal hdc As Long) As Long\nPrivate Declare PtrSafe Function API_GetDeviceCaps Lib \"gdi32\" Alias \"GetDeviceCaps\" (ByVal hdc As Long, ByVal nIndex As Long) As Long\nPrivate Declare PtrSafe Function api_SetErrorMode Lib \"kernel32\" Alias \"SetErrorMode\" (ByVal fuErrorMode As Long) As Long\n'Declares for Version Verification\n\nPrivate Declare PtrSafe Function ac_GetFileVersionInfoSize Lib \"Version.dll\" Alias \"GetFileVersionInfoSizeA\" (ByVal lptstrFilename As String, lpdwHandle As Long) As Long\nPrivate Declare PtrSafe Function ac_GetFileVersionInfo Lib \"Version.dll\" Alias \"GetFileVersionInfoA\" (ByVal lptstrFilename As String, ByVal dwHandle As Long, ByVal dwLen As Long, lpData As Any) As Long\nPrivate Declare PtrSafe Function ac_VerQueryValue Lib \"Version.dll\" Alias \"VerQueryValueA\" (pBlock As Any, ByVal lpSubBlock As String, lplpBuffer As Any, puLen As Long) As Long\nPrivate Declare PtrSafe Sub ac_MoveMemory Lib \"kernel32\" Alias \"RtlMoveMemory\" (dest As Any, ByVal Source As Long, ByVal Length As Long)\n\nPrivate Declare PtrSafe Function api_GetWindowsDirectory Lib \"kernel32\" Alias \"GetWindowsDirectoryA\" (ByVal lpBuffer As String, ByVal nSize As Long) As Long\nPrivate Declare PtrSafe Function api_GetSystemDirectory Lib \"kernel32\" Alias \"GetSystemDirectoryA\" (ByVal lpBuffer As String, ByVal nSize As Long) As Long\nPrivate Declare PtrSafe Function api_GetTempPath Lib \"kernel32\" Alias \"GetTempPathA\" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long\nPrivate Declare PtrSafe Function api_GetClassName Lib \"user32\" Alias \"GetClassNameA\" (ByVal hwnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long) As Long\n\nConst Jet_FILENAME = \"MSJT3032.DLL\"\nConst Jet35_FILE = \"msjet35.dll\"\n\nConst SEM_FAILCRITICALERRORS = &H1\nConst SEM_NOGPFAULTERRORBOX = &H2\nConst SEM_NOOPENFILEERRORBOX = &H8000\n    \n' Type returned by VER.DLL GetFileVersionInfo\nPrivate Type VS_FIXEDFILEINFO\n    dwSignature As Long\n    dwStrucVersionl As Integer     '  e.g. = &h0000 = 0\n    dwStrucVersionh As Integer     '  e.g. = &h0042 = .42\n    dwFileVersionMSl As Integer    '  e.g. = &h0003 = 3\n    dwFileVersionMSh As Integer    '  e.g. = &h0075 = .75\n    dwFileVersionLSl As Integer    '  e.g. = &h0000 = 0\n    dwFileVersionLSh As Integer    '  e.g. = &h0031 = .31\n    dwProductVersionMSl As Integer '  e.g. = &h0003 = 3\n    dwProductVersionMSh As Integer '  e.g. = &h0010 = .1\n    dwProductVersionLSl As Integer '  e.g. = &h0000 = 0\n    dwProductVersionLSh As Integer '  e.g. = &h0031 = .31\n    dwFileFlagsMask As Long        '  = &h3F for version \"0.42\"\n    dwFileFlags As Long            '  e.g. VFF_DEBUG Or VFF_PRERELEASE\n    dwFileOS As Long               '  e.g. VOS_DOS_WINDOWS16\n    dwFileType As Long             '  e.g. VFT_DRIVER\n    dwFileSubtype As Long          '  e.g. VFT2_DRV_KEYBOARD\n    dwFileDateMS As Long           '  e.g. 0\n    dwFileDateLS As Long           '  e.g. 0\n End Type\nType fBuffer\n    item As String * 1024\nEnd Type\n\nPrivate Type SYSTEM_INFO\n   dwOemID As Long\n   dwPageSize As Long\n   lpMinimumApplicationAddress As Long\n   lpMaximumApplicationAddress As Long\n   dwActiveProcessorMask As Long\n   dwNumberOrfProcessors As Long\n   dwProcessorType As Long\n   dwAllocationGranularity As Long\n   dwReserved As Long\nEnd Type\n\nConst VER_PLATFORM_WIN32s = 0\nConst VER_PLATFORM_WIN32_WINDOWS = 1   ' Windows 95\nConst VER_PLATFORM_WIN32_NT = 2\n\nPrivate Type OSVERSIONINFO\n   dwOSVersionInfoSize As Long\n   dwMajorVersion As Long\n   dwMinorVersion As Long\n   dwBuildNumber As Long\n   dwPlatformId As Long\n   szCSDVersion As String * 128\nEnd Type\n\nPrivate Type OSVERSIONINFOEX\n  OSVSize            As Long\n  dwVerMajor        As Long\n  dwVerMinor         As Long\n  dwBuildNumber      As Long\n  PlatformID         As Long\n  szCSDVersion       As String * 128\n  wServicePackMajor  As Integer\n  wServicePackMinor  As Integer\n  wSuiteMask         As Integer\n  wProductType       As Byte\n  wReserved          As Byte\nEnd Type\n\nPrivate Type MEMORYSTATUS\n   dwLength As Long\n   dwMemoryLoad As Long\n   dwTotalPhys As Long\n   dwAvailPhys As Long\n   dwTotalPageFile As Long\n   dwAvailPageFile As Long\n   dwTotalVirtual As Long\n   dwAvailVirtual As Long\nEnd Type\n\nPrivate Type MemoryStatusEx\n    dwLength As Long\n    dwMemoryLoad As Long\n    ullTotalPhys As Currency\n    ullAvailPhys As Currency\n    ullTotalPageFile As Currency\n    ullAvailPageFile As Currency\n    ullTotalVirtual As Currency\n    ullAvailVirtual As Currency\n    ullAvailExtendedVirtual As Currency\nEnd Type\n\n'Speziell Angepasst für Login CONSEC\nPublic Function atCNames(UOrC As Integer) As String\n'**************************************************\n'Purpose:  Returns the User LogOn Name or ComputerName\n'Author: 'System Info by ATTAC Consulting Group, Ann Arbor, MI  USA\n'Accepts:  UorC; 1=User, anything else = computer\n'Returns:  The Windows Networking name of the user or computer\n'Declares:\n'Private Declare PtrSafe Function api_GetUserName Lib \"advapi32.dll\" Alias \"GetUserNameA\" (ByVal lpBuffer As String, nSize As Long) As Long\n'Private Declare PtrSafe Function api_GetComputerName Lib \"kernel32\" Alias \"GetComputerNameA\" (ByVal lpBuffer As String, nSize As Long) As Long\n'**************************************************\nOn Error Resume Next\n\n    Dim NBuffer As String\n    Dim Buffsize As Long\n    Dim Wok As Long\n\n    Buffsize = 256\n    NBuffer = Space$(Buffsize)\n\n\n    If UOrC = 1 Then\n        atCNames = Get_Priv_Property(\"prp_Loginname\")\n    Else\n        Wok = api_GetComputerName(NBuffer, Buffsize)\n        atCNames = Trim$(NBuffer)\n    End If\n    If Right(atCNames, 1) = Chr(0) Then\n        atCNames = Left(atCNames, Len(atCNames) - 1)\n    End If\n    \nEnd Function\n\nPublic Function atCNames1(UOrC As Integer) As String\n'**************************************************\n'Purpose:  Returns the User LogOn Name or ComputerName\n'Author: 'System Info by ATTAC Consulting Group, Ann Arbor, MI  USA\n'Accepts:  UorC; 1=User, anything else = computer\n'Returns:  The Windows Networking name of the user or computer\n'Declares:\n'Private Declare PtrSafe Function api_GetUserName Lib \"advapi32.dll\" Alias \"GetUserNameA\" (ByVal lpBuffer As String, nSize As Long) As Long\n'Private Declare PtrSafe Function api_GetComputerName Lib \"kernel32\" Alias \"GetComputerNameA\" (ByVal lpBuffer As String, nSize As Long) As Long\n'**************************************************\nOn Error Resume Next\n\n    Dim NBuffer As String\n    Dim Buffsize As Long\n    Dim Wok As Long\n\n    Buffsize = 256\n    NBuffer = Space$(Buffsize)\n\n\n    If UOrC = 1 Then\n'        atCNames = \"zigausi\"\n        Wok = api_GetUserName(NBuffer, Buffsize)\n        atCNames1 = Trim$(NBuffer)\n    Else\n        Wok = api_GetComputerName(NBuffer, Buffsize)\n        atCNames1 = Trim$(NBuffer)\n    End If\n    If Right(atCNames1, 1) = Chr(0) Then\n        atCNames1 = Left(atCNames1, Len(atCNames1) - 1)\n    End If\n    \nEnd Function\n\nPrivate Function IsWinNT4Plus() As Boolean\n\n  'returns True if running Windows NT4 or later\n   Dim osV As OSVERSIONINFO\n\n   osV.dwOSVersionInfoSize = Len(osV)\n\n   If GetVersionEx(osV) = 1 Then\n   \n      IsWinNT4Plus = (osV.dwPlatformId = VER_PLATFORM_WIN32_NT) And _\n                     (osV.dwMajorVersion >= 4)\n \n   End If\n\nEnd Function\n\nFunction atWinver(intOSInfo%) As Variant\n'http://www.codeguru.com/cpp/w-p/system/systeminformation/article.php/c8973/\n'http://vbnet.mvps.org/code/helpers/iswinversion.htm\n\n'***********************************************\n'Purpose:  Retrieve operating system information\n'Author: 'System Info by ATTAC Consulting Group, Ann Arbor, MI  USA\n'Accepts: intOSInfo: which piece of information to retrieve\n   '        0: Major Version\n   '        1: Minor version\n   '        2: Build-Nr\n   '        3: Platform ID\n   '        4: CSDVersion\n' Returns: OS supplied Information\n'Declares:\n'Private Type OSVERSIONINFO\n'  OSVSize         As Long         'size, in bytes, of this data structure\n'  dwVerMajor      As Long         'ie NT 3.51, dwVerMajor = 3; NT 4.0, dwVerMajor = 4.\n'  dwVerMinor      As Long         'ie NT 3.51, dwVerMinor = 51; NT 4.0, dwVerMinor= 0.\n'  dwBuildNumber   As Long         'NT: build number of the OS\n'                                  'Win9x: build number of the OS in low-order word.\n'                                  '       High-order word contains major & minor ver nos.\n'  PlatformID      As Long         'Identifies the operating system platform.\n'  szCSDVersion    As String * 128 'NT: string, such as \"Service Pack 3\"\n'                                  'Win9x: string providing arbitrary additional information\n'End Type\n'\n'Private Type OSVERSIONINFOEX\n'  OSVSize            As Long\n'  dwVerMajor         As Long\n'  dwVerMinor         As Long\n'  dwBuildNumber      As Long\n'  PlatformID         As Long\n'  szCSDVersion       As String * 128\n'  wServicePackMajor  As Integer\n'  wServicePackMinor  As Integer\n'  wSuiteMask         As Integer\n'  wProductType       As Byte\n'  wReserved          As Byte\n'End Type\n\n'Private Declare PtrSafe Function GetVersionEx Lib \"kernel32\" Alias \"GetVersionExA\" (lpOSInfo As OSVERSIONINFO) As Boolean\n\n'Win 95          4.00.950\n'Win 95 OSR 2    4.00.1111\n'Win 98          4.10.1998\n'Win 98 SE       4.10.2222\n'Win Me          4.90.3000\n'Win NT4         4.00.1381 platform ID as 2\n'Win 2000        5.00.2195 platform ID as 2\n'Win XP          5.01.2600 platform ID as 2\n'Win 2003 Server        5.02.3790 platform ID as 2\n'Win Vista              6.00.6000 platform ID as 2 ProductType 1\n'Win 2008 Server        6.00.6000 platform ID as 2 ProductType 3\n'Windows Server 2008 R2 6.1 6 1 OSVERSIONINFOEX.wProductType 3 != VER_NT_WORKSTATION\n'Windows 7              6.1 6 1 OSVERSIONINFOEX.wProductType 1 == VER_NT_WORKSTATION\n\n\n'Eine nur ab Vista und Windows Server 2008 verfügbare neue API \"GetProductInfo\" hilft bei der Definition der\n'genauen Version, siehe\n'http://www.codeguru.com/cpp/w-p/system/systeminformation/article.php/c8973/\n\n'Win Vista - Major 6 - Minor 0 - Product Type 1\n'       Ultimate und Business        - Suite Mask = 0x000\n'       Home Basic und Home Premium  - Suite Mask = 0x200\n\n'Win Server 2008 - Major 6 - Minor 0 - Product Type 3\n'       Standard    - Suite Mask = 0x000\n'       Enterprise  - Suite Mask = 0x002\n'       Data Center - Suite Mask = 0x080\n\n'Win Server 2008 R2 - Major 6 - Minor 1 - Product Type 3\n\n'Windows 7          - Major 6 - Minor 1 - Product Type 1\n\n'Windows Vista\n'Platform type: NT\n'Major version: 6\n'Minor version: 0\n'Build number: 6000\n'Service Pack info:  (Build 6000)\n'\n'32-bit platform: true\n'64-bit platform: false\n\n'***********************************************\n   Dim OSInfo As OSVERSIONINFO\n   Dim OSInfoEx As OSVERSIONINFOEX\n   Dim dwReturn&\n   \n   Dim Is_Ex As Boolean\n   Dim Is_OK As Long\n   \n   Const PLAT_WINDOWS = 1\n   Const PLAT_WIN_NT = 2\n   \n   OSInfo.szCSDVersion = Space(128)\n   \n   'Set the size= to length of structure\nIf IsWinNT4Plus Then\n    OSInfo.dwOSVersionInfoSize = Len(OSInfo)\n    Is_OK = GetVersionEx(OSInfo)\n    If Is_OK = 0 Then Exit Function\n    OSInfoEx.OSVSize = Len(OSInfoEx)\n    Is_OK = GetVersionEx(OSInfoEx)\n    Is_Ex = True\nElse\n    OSInfo.dwOSVersionInfoSize = Len(OSInfo)\n    Is_OK = GetVersionEx(OSInfo)\n    Is_Ex = False\nEnd If\n   If Is_OK > 0 Then\n      Select Case intOSInfo\n         Case 0\n            atWinver = OSInfo.dwMajorVersion\n         Case 1\n            atWinver = OSInfo.dwMinorVersion\n         Case 2\n            atWinver = OSInfo.dwBuildNumber And &HFFFF&\n         Case 3\n            \n            dwReturn = OSInfo.dwPlatformId\n            atWinver = OSInfo.dwMinorVersion\n            If dwReturn = PLAT_WINDOWS Then\n                If atWinver < 10 Then\n                    If (OSInfo.dwBuildNumber And &HFFFF&) > 1000 Then\n                        atWinver = \"Win 95 SR2\"\n                    Else\n                        atWinver = \"Win 95 SR1\"\n                    End If\n                Else\n'                    atWinver = \"Windows 98\"\n                    If (OSInfo.dwBuildNumber And &HFFFF&) > 2000 Then\n                        atWinver = \"Win 98 SE\"\n                    Else\n                        atWinver = \"Win 98\"\n                    End If\n                End If\n            Else\n                If dwReturn = PLAT_WIN_NT Then\n                    If OSInfo.dwMajorVersion = 5 Then\n                        Select Case OSInfo.dwMinorVersion\n                            Case 0\n                               atWinver = \"Win 2000\"\n                                If Is_Ex Then\n                                    If Hex(OSInfoEx.wSuiteMask) And &H80& = &H80& Then\n                                        atWinver = \"Win 2000 Datacenter\"\n                                    ElseIf Hex(OSInfoEx.wSuiteMask) And &H2& = &H2& Then\n                                        atWinver = \"Win 2000 Advanced\"\n                                    End If\n                                Else\n                                    atWinver = \"Win 2000\"\n                                End If\n                            Case 1\n                               atWinver = \"Win XP\"\n                                If Is_Ex Then\n                                    If Hex(OSInfoEx.wSuiteMask) And &H80& = &H80& Then\n                                        atWinver = \"Win XP Pro\"\n                                    ElseIf Hex(OSInfoEx.wSuiteMask) And &H200& = &H200& Then\n                                        atWinver = \"Win XP Home\"\n                                    End If\n                                Else\n                                    atWinver = \"Win XP\"\n                                End If\n                            Case 2\n                               atWinver = \"Win 2003 Server\"\n                                If Is_Ex Then\n                                    If Hex(OSInfoEx.wSuiteMask) And &H80& = &H80& Then\n                                        atWinver = \"Win 2003 Server Datacenter\"\n                                    ElseIf Hex(OSInfoEx.wSuiteMask) And &H2& = &H2& Then\n                                        atWinver = \"Win 2003 Server Enterprise\"\n                                    ElseIf Hex(OSInfoEx.wSuiteMask) And &H400& = &H400& Then\n                                        atWinver = \"Win 2003 Server Web Edition\"\n                                    ElseIf Hex(OSInfoEx.wSuiteMask) And &H0& = &H0& Then\n                                        atWinver = \"Win 2003 Server Standard\"\n                                    End If\n                                Else\n                                    atWinver = \"Win 2003 Server\"\n                                End If\n                            Case Else\n                                atWinver = \"Win ???\"\n                        End Select\n                    ElseIf OSInfo.dwMajorVersion = 4 Then\n                        If Is_Ex Then\n                            If Hex(OSInfoEx.wSuiteMask) And &H2& = &H2& Then\n                                atWinver = \"Win NT Server Enterprise\"\n                            ElseIf Hex(OSInfoEx.wSuiteMask) And &H0& = &H0& Then\n                                atWinver = \"Win NT Server Standard\"\n                            End If\n                        Else\n                            atWinver = \"Win NT\"\n                        End If\n                    ElseIf OSInfo.dwMajorVersion = 6 Then\n                        If Is_Ex Then\n                            If OSInfo.dwMinorVersion = 0 Then\n                                If OSInfoEx.wProductType = 1 Then\n                                    If Hex(OSInfoEx.wSuiteMask) And &H0& = &H0& Then\n                                        atWinver = \"Win VISTA Ultimate Business\"\n                                    ElseIf Hex(OSInfoEx.wSuiteMask) And &H200& = &H200& Then\n                                        atWinver = \"Win Vista Home\"\n                                    End If\n                                ElseIf OSInfoEx.wProductType = 2 Then\n                                    If Hex(OSInfoEx.wSuiteMask) And &H2& = &H2& Then\n                                        atWinver = \"Win 2008 Server Enterprise\"\n                                    ElseIf Hex(OSInfoEx.wSuiteMask) And &H80& = &H80& Then\n                                        atWinver = \"Win 2008 Server Datacenter\"\n                                    ElseIf Hex(OSInfoEx.wSuiteMask) And &H0& = &H0& Then\n                                        atWinver = \"Win 2008 Server Standard\"\n                                    End If\n                                End If\n                            ElseIf OSInfo.dwMinorVersion = 1 And OSInfoEx.wProductType = 3 Then\n                                If Hex(OSInfoEx.wSuiteMask) And &H2& = &H2& Then\n                                    atWinver = \"Win 2008 Server R2 Enterprise\"\n                                ElseIf Hex(OSInfoEx.wSuiteMask) And &H80& = &H80& Then\n                                    atWinver = \"Win 2008 Server R2 Datacenter\"\n                                ElseIf Hex(OSInfoEx.wSuiteMask) And &H0& = &H0& Then\n                                    atWinver = \"Win 2008 Server R2 Standard\"\n                                End If\n                            ElseIf OSInfo.dwMinorVersion = 1 And OSInfoEx.wProductType = 1 Then\n                                If Hex(OSInfoEx.wSuiteMask) And &H0& = &H0& Then\n                                    atWinver = \"Windows 7 Ultimate Business\"\n                                ElseIf Hex(OSInfoEx.wSuiteMask) And &H200& = &H200& Then\n                                    atWinver = \"Windows 7 Home\"\n                                End If\n                            ElseIf OSInfo.dwMinorVersion = 2 And OSInfoEx.wProductType = 3 Then\n                                If Hex(OSInfoEx.wSuiteMask) And &H2& = &H2& Then\n                                    atWinver = \"Win 2012 Server R2 Enterprise\"\n                                ElseIf Hex(OSInfoEx.wSuiteMask) And &H80& = &H80& Then\n                                    atWinver = \"Win 2012 Server R2 Datacenter\"\n                                ElseIf Hex(OSInfoEx.wSuiteMask) And &H0& = &H0& Then\n                                    atWinver = \"Win 2012 Server R2 Standard\"\n                                End If\n                            ElseIf OSInfo.dwMinorVersion = 2 And OSInfoEx.wProductType = 1 Then\n                                If Hex(OSInfoEx.wSuiteMask) And &H0& = &H0& Then\n                                    atWinver = \"Windows 8 Ultimate Business\"\n                                ElseIf Hex(OSInfoEx.wSuiteMask) And &H200& = &H200& Then\n                                    atWinver = \"Windows 8 Home\"\n                                End If\n                            End If\n                        Else\n                            atWinver = \"Win VISTA\"\n                        End If\n                    End If\n                Else\n                    atWinver = \"???\"\n                End If\n            End If\n         Case 4\n            atWinver = Trim(OSInfo.szCSDVersion)\n      End Select\n   Else\n      atWinver = 0\n   End If\n\nEnd Function\n\n\nPublic Function atGetSysStatus(intStatus As Integer) As Variant\n'****************************************************************\n'Purpose:  Retrieve system status information\n'Accepts:  intStatus: which piece of information to retrieve\n'           1: The number of CPUs in the system\n'           2: The type of CPUs in the system\n'Returns:  The requested information\n'*****************************************************************\n On Error Resume Next\n   Dim si As SYSTEM_INFO\n   Dim CPUType$\n\n   \n   GetSystemInfo si\n   Select Case intStatus\n      Case 1\n         atGetSysStatus = si.dwNumberOrfProcessors\n      Case 2\n         CPUType = si.dwProcessorType\n         If CPUType = \"586\" Then\n            atGetSysStatus = \"Pentium\"\n         Else\n             atGetSysStatus = si.dwProcessorType\n         End If\n      Case Else\n         atGetSysStatus = 0\n   End Select\n   \nEnd Function\n\n\nFunction atDiskFreeSpace(Drive As String) As String\n'**************************************************\n'Wird normalerweise nicht mehr benötigt ...\n'Purpose: Return Free Space\n'Accepts: A Drive letter\n'Returns: Disk space available\n'**************************************************\nOn Error GoTo Err_DF\n\n    Dim wResult\n    Dim TotalSpace As Long\n    Dim TotalSpaceMB As Single\n    Dim freeSpace As Long\n    Dim FreeSpaceMB As Single\n    Dim PercentFree As Single\n    Dim path As String\n    Dim Sectors As Long\n    Dim bytes As Long\n    Dim FClusters As Long\n    Dim TClusters As Long\n    Dim ErrorMode&\n      \n    If IsNull(Drive) Then Exit Function\n    'Set the error mode for the system so that \"system errors\" are ignored\n    'and we let Access handle the errors, capture the return value so that\n    'the error mode can be reset to its initial setting upon exit from the\n    'function\n'    ErrorMode = api_SetErrorMode(SEM_FAILCRITICALERRORS)\n'    ErrorMode = api_SetErrorMode(SEM_NOGPFAULTERRORBOX)\n'    ErrorMode = api_SetErrorMode(SEM_NOOPENFILEERRORBOX)\n    ErrorMode = api_SetErrorMode(SEM_NOOPENFILEERRORBOX + SEM_NOGPFAULTERRORBOX)\n\n    wResult = Dir(Drive & \":\\*.*\")\n    \n    path = Drive & \":\\\" & Chr$(0)\n    \n    wResult = api_GetDiskFreeSpace(path, Sectors, bytes, FClusters, TClusters)\n    \n    TotalSpace = Sectors * bytes * TClusters\n    TotalSpaceMB = (TotalSpace / 1024) / 1024\n    freeSpace = Sectors * bytes * FClusters\n    FreeSpaceMB = (freeSpace / 1024) / 1024\n    PercentFree = (freeSpace / TotalSpace) * 100\n    If TotalSpace = -1 Then\n        atDiskFreeSpace = \"Drive Not Available\"\n    Else\n        If FreeSpaceMB < 1000 And TotalSpaceMB < 1000 Then\n            atDiskFreeSpace = Format$(FreeSpaceMB, \"###0.##\") & \" MB: \" & Format$(PercentFree, \"0.##\") & \"% of \" & Format$(TotalSpaceMB, \"0.##\") & \" MB\"\n        ElseIf FreeSpaceMB < 1000 And TotalSpaceMB > 1000 Then\n            TotalSpaceMB = TotalSpaceMB / 1024\n            atDiskFreeSpace = Format$(FreeSpaceMB, \"###0.##\") & \" MB: \" & Format$(PercentFree, \"0.##\") & \"% of \" & Format$(TotalSpaceMB, \"0.##\") & \" GB\"\n        Else\n            FreeSpaceMB = FreeSpaceMB / 1024\n            TotalSpaceMB = TotalSpaceMB / 1024\n            atDiskFreeSpace = Format$(FreeSpaceMB, \"###0.##\") & \" GB: \" & Format$(PercentFree, \"0.##\") & \"% of \" & Format$(TotalSpaceMB, \"0.##\") & \" GB\"\n        End If\n    End If\n    ErrorMode = api_SetErrorMode(ErrorMode)\n    \nExit_DF:\n    Exit Function\n\nErr_DF:\n    \n    If err = 71 Then\n        MsgBox \"There is no disc in Drive \" & Drive & \":, the drive door is not closed, or the current disc has not been formatted.\", 16, \"System Information\"\n    ElseIf err = 68 Then\n        atDiskFreeSpace = \"Drive Not Available\"\n        Resume Exit_DF\n    ElseIf err = 75 Or 76 Then\n        MsgBox \"Drive \" & Drive & \": is not accessable.  If the Drive is a CDROM then make sure it is turned on and/or a disk is in the Drive.\", 16, \"System Information\"\n    ElseIf err = 3043 Then\n        MsgBox \"The Network or Disc Drive \" & Drive & \" is unavailable or has produced an error\", 48, \"System Information\"\n    Else\n        MsgBox \"Error \" & Error$, 48, \"System Information\"\n    End If\n    ErrorMode = api_SetErrorMode(ErrorMode)\n    atDiskFreeSpace = \"Drive Not Available\"\n    Resume Exit_DF\n\n\n\nEnd Function\n\nFunction atDiskFreeSpaceEx(Drive As String, Optional MsgBoxOnErr As Boolean = True) As String\n'Author: 'System Info by ATTAC Consulting Group, Ann Arbor, MI  USA\n'Funktion ersetzt normalerweise die Funktion atDiskFreeSpace, da diese mit SEHR großen Festplatten nicht zu Rande kommt.\n'Funktion benötigt dennoch das (alte) Declare api_GetDiskFreeSpace, im Falle api_GetDiskFreeSpaceEx (z.B. bei Win 95 SR1) nicht klappt oder fehlt\n'Declares:\n'Private Declare PtrSafe Function api_GetDiskFreeSpace Lib \"kernel32\" Alias \"GetDiskFreeSpaceA\" (ByVal lpRootPathName As String, lpSectorsPerCluster As Long, lpBytesPerSector As Long, lpNumberOfFreeClusters As Long, lpTtoalNumberOfClusters As Long) As Long\n'Private Declare PtrSafe Function api_GetDiskFreeSpaceEx Lib \"kernel32\" Alias \"GetDiskFreeSpaceExA\" (ByVal lpRootPathName As String, lpFreeBytesAvailableToCaller As Currency, lpTotalNumberOfBytes As Currency, lpTotalNumberOfFreeBytes As Currency) As Long\n'Private Declare PtrSafe Function api_SetErrorMode Lib \"kernel32\" Alias \"SetErrorMode\" (ByVal fuErrorMode As Long) As Long\n'Const SEM_FAILCRITICALERRORS = &H1\n'**************************************************\n'Purpose: Return Free Space on Drives\n'Accepts: A Drive letter\n'Returns: Disk space available\n'**************************************************\nOn Error GoTo Err_DF\n    Dim wResult\n    Dim TotalSpace As Long\n    Dim TotalSpaceMB As Double\n    Dim freeSpace As Long\n    Dim FreeSpaceMB As Double\n    Dim PercentFree As Single\n    Dim path As String\n    Dim FreeBytesCaller As Currency\n    Dim TotalBytes As Currency\n    Dim TotalFreeBytes As Currency\n    Dim Sectors As Long\n    Dim bytes As Long\n    Dim FClusters As Long\n    Dim TClusters As Long\n    Dim ErrorMode&\n      \n    If IsNull(Drive) Then Exit Function\n    'Set the error mode for the system so that \"system errors\" are ignored\n    'and we let Access handle the errors, capture the return value so that\n    'the error mode can be reset to its initial setting upon exit from the\n    'function\n'    ErrorMode = api_SetErrorMode(SEM_FAILCRITICALERRORS)\n'    ErrorMode = api_SetErrorMode(SEM_NOGPFAULTERRORBOX)\n'    ErrorMode = api_SetErrorMode(SEM_NOOPENFILEERRORBOX)\n    ErrorMode = api_SetErrorMode(SEM_NOOPENFILEERRORBOX + SEM_NOGPFAULTERRORBOX)\n\n    wResult = Dir(Drive & \":\\*.*\")\n    \n    path = Drive & \":\\\" & Chr$(0)\n    \n    On Error Resume Next\n    'Only supported on Win95 OSR2 and above and NT 4 and above\n    wResult = api_GetDiskFreeSpaceEx(path, FreeBytesCaller, TotalBytes, TotalFreeBytes)\n    If err = 0 Then\n        TotalSpaceMB = ((TotalBytes * 10000) / 1024) / 1024\n        FreeSpaceMB = ((FreeBytesCaller * 10000) / 1024) / 1024\n    Else\n        'Win95 OSR1\n        wResult = api_GetDiskFreeSpace(path, Sectors, bytes, FClusters, TClusters)\n        TotalSpace = Sectors * bytes * TClusters\n        TotalSpaceMB = (TotalSpace / 1024) / 1024\n        freeSpace = Sectors * bytes * FClusters\n        FreeSpaceMB = (freeSpace / 1024) / 1024\n    End If\n    On Error GoTo Err_DF\n    PercentFree = (FreeSpaceMB / TotalSpaceMB) * 100\n    If TotalSpaceMB = -1 Then\n        atDiskFreeSpaceEx = \"Drive Not Available\"\n    Else\n        If FreeSpaceMB < 1000 And TotalSpaceMB < 1000 Then\n            atDiskFreeSpaceEx = Format$(FreeSpaceMB, \"###0.##\") & \" MB: \" & Format$(PercentFree, \"0.##\") & \"% of \" & Format$(TotalSpaceMB, \"0.##\") & \" MB\"\n        ElseIf FreeSpaceMB < 1000 And TotalSpaceMB > 1000 Then\n            TotalSpaceMB = TotalSpaceMB / 1024\n            atDiskFreeSpaceEx = Format$(FreeSpaceMB, \"###0.##\") & \" MB: \" & Format$(PercentFree, \"0.##\") & \"% of \" & Format$(TotalSpaceMB, \"0.##\") & \" GB\"\n        Else\n            FreeSpaceMB = FreeSpaceMB / 1024\n            TotalSpaceMB = TotalSpaceMB / 1024\n            atDiskFreeSpaceEx = Format$(FreeSpaceMB, \"###0.##\") & \" GB: \" & Format$(PercentFree, \"0.##\") & \"% of \" & Format$(TotalSpaceMB, \"0.##\") & \" GB\"\n        End If\n    End If\n    ErrorMode = api_SetErrorMode(ErrorMode)\n    \nExit_DF:\n    Exit Function\n\nErr_DF:\n    If err = 71 Then\n        If MsgBoxOnErr Then\n            MsgBox \"There is no disc in Drive \" & Drive & \":, the drive door is not closed, or the current disc has not been formatted.\", 16, \"System Information\"\n        End If\n    ElseIf err = 68 Then\n        atDiskFreeSpaceEx = \"Drive Not Available\"\n        Resume Exit_DF\n    ElseIf err = 75 Or 76 Then\n        If MsgBoxOnErr Then\n            MsgBox \"Drive \" & Drive & \": is not accessable.  If the Drive is a CDROM then make sure it is turned on and/or a disk is in the Drive.\", 16, \"System Information\"\n        End If\n    ElseIf err = 3043 Then\n        If MsgBoxOnErr Then\n            MsgBox \"The Network or Disc Drive \" & Drive & \" is unavailable or has produced an error\", 48, \"System Information\"\n        End If\n    Else\n        If MsgBoxOnErr Then\n            MsgBox \"Error \" & Error$, 48, \"System Information\"\n        End If\n    End If\n    ErrorMode = api_SetErrorMode(ErrorMode)\n    atDiskFreeSpaceEx = \"Drive Not Available\"\n    Resume Exit_DF\n\nEnd Function\n\n\n\nPublic Function atGetColourCap() As String\n'**************************************************\n'Purpose:  Get the colour depth setting for the monitor\n'Accepts:  Nothing, calls GetDeviceCaps for the Display\n'Returns:  String Value base on the number of Bits and color\n'           Planes\n'***************************************************\nOn Error GoTo Err_Colour\n\n    Dim PLANES As Integer\n    Dim Bits As Integer\n\n    PLANES = atGetdevcaps(14)\n    Bits = atGetdevcaps(12)\n\n    If PLANES = 1 Then\n        Select Case Bits\n            Case 8\n                atGetColourCap = \"256\"\n            Case 15\n                atGetColourCap = \"32K\"\n            Case 16\n                atGetColourCap = \"64K\"\n            Case 24\n                atGetColourCap = \"16 Mio\"\n            Case 32\n                atGetColourCap = \"True\"\n            End Select\n    ElseIf PLANES = 4 Then\n        atGetColourCap = 16\n    Else\n        atGetColourCap = \"Unk\"\n    End If\n\nExit_Colour:\n    Exit Function\n\nErr_Colour:\n    atGetColourCap = \"Unk\"\n    Resume Exit_Colour\n\n\n\nEnd Function\n\nPublic Function TwipsPerPixelX() As Single\n\nTwipsPerPixelX = 1440& / atGetdevcaps%(88&)\n\nEnd Function\n\n\nPublic Function TwipsPerPixelY() As Single\n\nTwipsPerPixelY = 1440& / atGetdevcaps%(90&)\n\nEnd Function\n\n\n\nPublic Function atGetdevcaps%(ByVal intCapability%)\n'===========================================================\n' Purpose:      Returns information on the capabilities of\n'               a given device. Which device is determined\n'               by the arguments to api_CreateIC. Which\n'               capability is determined by the intCapability\n'               argument which is one of the constants\n'               defined for the GetDeviceCaps Windows API\n'               function.\n' Arguments:    intCapability - index of capability to check\n'               see win32api.txt for list of values\n' Returns:      Results of call to GetDeviceCaps\n'-----------------------------------------------------------\n\n'   Global Const DRIVERVERSION = 0\n'   Global Const TECHNOLOGY = 2\n'   Global Const HORZSIZE = 4\n'   Global Const VERTSIZE = 6\n'   Global Const HORZRES = 8\n'   Global Const VERTRES = 10\n'   Global Const BITSPIXEL = 12\n'   Global Const PLANES = 14\n'   Global Const NUMBRUSHES = 16\n'   Global Const NUMPENS = 18\n'   Global Const NUMMARKERS = 20\n'   Global Const NUMFONTS = 22\n'   Global Const NUMCOLORS = 24\n'   Global Const PDEVICESIZE = 26\n'   Global Const CURVECAPS = 28\n'   Global Const LINECAPS = 30\n'   Global Const POLYGONALCAPS = 32\n'   Global Const TEXTCAPS = 34\n'   Global Const CLIPCAPS = 36\n'   Global Const RASTERCAPS = 38\n'   Global Const ASPECTX = 40\n'   Global Const ASPECTY = 42\n'   Global Const ASPECTXY = 44\n'   Global Const LOGPIXELSX = 88\n'   Global Const LOGPIXELSY = 90\n'   Global Const SIZEPALETTE = 104\n'   Global Const NUMRESERVED = 106\n'   Global Const COLORRES = 108\n'   Global Const DT_PLOTTER = 0\n'   Global Const DT_RASDISPLAY = 1\n'   Global Const DT_RASPRINTER = 2\n'   Global Const DT_RASCAMERA = 3\n'   Global Const DT_CHARSTREAM = 4\n'   Global Const DT_METAFILE = 5\n'   Global Const DT_DISPFILE = 6\n'   Global Const CP_NONE = 0\n'   Global Const CP_RECTANGLE = 1\n'   Global Const RC_BITBLT = 1\n'   Global Const RC_BANDING = 2\n'   Global Const RC_SCALING = 4\n'   Global Const RC_BITMAP64 = 8\n'   Global Const RC_GDI20_OUTPUT = &H10\n'   Global Const RC_DI_BITMAP = &H80\n'   Global Const RC_PALETTE = &H100\n'   Global Const RC_DIBTODEV = &H200\n'   Global Const RC_BIGFONT = &H400\n'   Global Const RC_STRETCHBLT = &H800\n'   Global Const RC_FLOODFILL = &H1000\n'   Global Const RC_STRETCHDIB = &H2000\n\nOn Error GoTo getdevcapsError\n\n    Dim hdc&  'handle for the device context\n    \n    'Specify the device -- use \"DISPLAY' to check screen capabilities\n    Const DRIVER_NAME = \"DISPLAY\"\n    Const DEVICE_NAME = 0&\n    Const OUTPUT_DEVICE = 0&\n    Const lpDevmode = 0&\n\n    'Get a handle to a device context (hDC)\n    hdc = api_CreateIC(DRIVER_NAME, DEVICE_NAME, OUTPUT_DEVICE, lpDevmode)\n    If hdc Then\n        \n        'If a valid hDC was returned, call GetDeviceCaps and\n        'then release the DC\n        atGetdevcaps = API_GetDeviceCaps(hdc, intCapability)\n        hdc = api_DeleteDC(hdc)\n    End If\n\ngetdevcapsExit:\n    Exit Function\ngetdevcapsError:\n    MsgBox \"Error: \" & Error$, 48, \"System Information\"\n    Resume getdevcapsExit\nEnd Function\n\nFunction atGetjetver() As String\n'*******************************************\n'Purpose:  Returns Version information on Jet DB Engine\n'          Based on the Version of Access Used\n'*******************************************\n\n    Dim Buffer As fBuffer\n    Dim VInfo As VS_FIXEDFILEINFO\n    Dim stBuf() As Byte\n    Dim lSize As Long\n    Dim stUnused As Long\n    Dim ErrCode As Long\n    Dim VerNum As Variant\n    Dim lVerPointer       As Long\n    Dim lVerbufferLen     As Long\n    Dim Jet$\n\n    If SysCmd(acSysCmdAccessVer) < 8 Then\n        Jet = Jet_FILENAME\n    Else\n        Jet = Jet35_FILE\n    End If\n        \n    lSize = ac_GetFileVersionInfoSize(Jet, stUnused)\n    ReDim stBuf(lSize)\n    ErrCode = ac_GetFileVersionInfo(Jet, 0&, lSize, stBuf(0))\n        \n    ErrCode = ac_VerQueryValue(stBuf(0), \"\\\", lVerPointer, lVerbufferLen)\n        \n    If ErrCode <> 0 Then\n        ac_MoveMemory VInfo, lVerPointer, Len(VInfo)\n        \n        VerNum = Format$(VInfo.dwFileVersionMSh) & \".\" & _\n        Format$(VInfo.dwFileVersionMSl) & \".\" & _\n        Format$(VInfo.dwFileVersionLSh) & \".\" & _\n        Format$(VInfo.dwFileVersionLSl)\n    End If\n    atGetjetver = VerNum\nEnd Function\n\n\n\nPublic Function atGetMem(intInfoItem As Integer) As Variant\n'**********************************************************\n'Purpose:  Retrieve system memory use information\n'Accepts:  intInfoItem: Memory Info to retrieve\n'           1: Total physical memory in bytes\n'           2: Available physical memory in bytes\n'           3: Total virtual memory in bytes\n'           4: Available virtual memory in bytes\n'add\n'           5: Total PageFile\n'           6: Available PageFile\n'           7: Memory Load\n'Returns:  The current memory use informaiton\n'**********************************************************\nOn Error Resume Next\n\n   Dim atgetmem1 As Long\n   Dim atgetmem2 As Double\n\n   Dim MemStat As MEMORYSTATUS\n\n   MemStat.dwLength = Len(MemStat)\n   Call GlobalMemoryStatus(MemStat)\n   Select Case intInfoItem\n\n    Case 1\n        atGetMem = MemStat.dwTotalPhys\n    Case 2\n        atGetMem = MemStat.dwAvailPhys\n    Case 3\n        atGetMem = MemStat.dwTotalVirtual\n    Case 4\n        atGetMem = MemStat.dwAvailVirtual\n    Case 5\n        atGetMem = MemStat.dwTotalPageFile\n    Case 6\n        atGetMem = MemStat.dwAvailPageFile\n    Case 7\n        atGetMem = MemStat.dwMemoryLoad\n    Case Else\n        atGetMem = 0\n    End Select\n\nEnd Function\n\nPublic Function atGetMemEx(intInfoItem As Integer) As Variant\n'**********************************************************\n'Purpose:  Retrieve system memory use information\n'Accepts:  intInfoItem: Memory Info to retrieve\n'           1: Total physical memory in bytes\n'           2: Available physical memory in bytes\n'           3: Total virtual memory in bytes\n'           4: Available virtual memory in bytes\n'add\n'           5: Total PageFile\n'           6: Available PageFile\n'           7: Memory Load\n'Returns:  The current memory use informaiton\n'**********************************************************\nOn Error Resume Next\n   \n   Dim MemStat As MemoryStatusEx\n   \n   MemStat.dwLength = Len(MemStat)\n   Call GlobalMemoryStatusEx(MemStat)\n   \n   Select Case intInfoItem\n\n    'Currency = Abspeicherung als BigInt jedoch intern mit 5 Nachkommastellen, daher * 10.000\n\n    Case 1\n        atGetMemEx = MemStat.ullTotalPhys * 10000\n    Case 2\n        atGetMemEx = MemStat.ullAvailPhys * 10000\n    Case 3\n        atGetMemEx = MemStat.ullTotalVirtual * 10000\n    Case 4\n        atGetMemEx = MemStat.ullAvailVirtual * 10000\n    Case 5\n        atGetMemEx = MemStat.ullTotalPageFile * 10000\n    Case 6\n        atGetMemEx = MemStat.ullAvailPageFile * 10000\n    Case 7\n        atGetMemEx = MemStat.dwMemoryLoad\n    Case Else\n        atGetMemEx = 0\n    End Select\n    \nEnd Function\n\n\n\nPublic Function atDriveType(Drive As String) As Long\n'***************************************************\n'Purpose:  Gets a long interger value representing the drive type\n'\n'Accepts:  A drive letter\n'Returns:  The drive type; used by after update of drive combo\n'          to change the drive picture\n'***************************************************\nOn Error GoTo Err_DT\n\nDim wResult As Long\nDim path As String\n\n\npath = Drive & \":\\\" & Chr$(0)\n\nwResult = api_GetDriveType(path)\n\natDriveType = wResult\nExit Function\n\n\nErr_DT:\n    atDriveType = 0\n    Exit Function\n\nEnd Function\n\n\n'#################################################\n'## Weitere systemnahe Functions\n'#################################################\n      \n      ' This function returns the path to the Windows directory\n      ' as a string.\n      Function GetWinDir() As String\n'Private Declare PtrSafe Function api_GetWindowsDirectory Lib \"kernel32\" Alias \"GetWindowsDirectoryA\" (ByVal lpBuffer As String, ByVal nSize As Long) As Long\n         Dim lpBuffer As String * 255\n         Dim Length As Long\n         Length = api_GetWindowsDirectory(lpBuffer, Len(lpBuffer))\n         GetWinDir = Left(lpBuffer, Length)\n         If Right(GetWinDir, 1) <> \"\\\" Then GetWinDir = GetWinDir & \"\\\"\n      End Function\n\n      ' This function returns the path to the Windows System directory\n      ' as a string.\n      Function GetSysDir() As String\n'Private Declare PtrSafe Function api_GetSystemDirectory Lib \"kernel32\" Alias \"GetSystemDirectoryA\" (ByVal lpBuffer As String, ByVal nSize As Long) As Long\n         Dim lpBuffer As String * 255\n         Dim Length As Long\n         Length = api_GetSystemDirectory(lpBuffer, Len(lpBuffer))\n         GetSysDir = Left(lpBuffer, Length)\n         If Right(GetSysDir, 1) <> \"\\\" Then GetSysDir = GetSysDir & \"\\\"\n      End Function\n\n      ' This function returns the path to the Windows Temp directory\n      ' as a string.\n      Function GetTempDir() As String\n'Private Declare PtrSafe Function api_GetTempPath Lib \"kernel32\" Alias \"GetTempPathA\" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long\n         Dim lpBuffer As String * 255\n         Dim Length As Long\n         Length = api_GetTempPath(Len(lpBuffer), lpBuffer)\n         GetTempDir = Left(lpBuffer, Length)\n         If Right(GetTempDir, 1) <> \"\\\" Then GetTempDir = GetTempDir & \"\\\"\n      End Function\n\n       ' This function returns the actual path as a string\n        Function GetAktDir() As String\n          GetAktDir = CurDir\n         If Right(GetAktDir, 1) <> \"\\\" Then GetAktDir = GetAktDir & \"\\\"\n        End Function\n      \n      ' This function returns the Classname of a given Hwnd#\n      ' as a string.\n      Function GetClassName(hwnd As Long) As String\n         Dim lpBuffer As String * 255\n         Dim Length As Long\n         Length = api_GetClassName(hwnd, lpBuffer, Len(lpBuffer))\n         GetClassName = Left(lpBuffer, Length)\n      End Function\n\n\nFunction FlpFormat()\n'Info von Brian Harper\n'EmaiL: Brian@brianharper.demon.co.uk\n'http://www.brianharper.demon.co.uk/\n\nDim WinPath As String\n\nWinPath = GetWinDir()\n\nFlpFormat = Shell(WinPath + \"\\rundll32.exe shell32.dll,SHFormatDrive\", 1)\n\nEnd Function\n\n\nFunction getEnviromentVar(ByVal strEnviroment_IN As String) As String\n   \n   ' Die Umgebungsvariable strEnviroment_IN auswerten\n   ' und zurückgeben\n   '\n   ' Funktionsaufruf (Beispiel)\n   '    strReturnValue = getEnviromentVar(\"Temp\")\n   '  oder\n   '    strReturnValue = getEnviromentVar(\"Temp=\")\n   '\n   ' IN\n   '    Name der Umgebungsvariablen\n   '\n   ' OUT\n   '     Die Zuweisung der Umgebungsvariablen\n   '  o. \"VarNotInitialized\"\n   '     wenn die Variable nicht initialisiert wurde\n   '  o. \"VarEmpty\"\n   '     wenn keine Zuweisung vorhanden ist\n   '\n   ' Version----Datum------Name-----Grund\n   ' Version 2:\n   ' Version 1: 16.10.1998 Klauke\n   '\n   \n   Dim strEnviroment   As String\n   Dim strReturnValue  As String\n   Dim blnTempExist    As Boolean\n   Dim intCount        As Integer\n   \n   Dim mvarMsg         As Variant\n   \n   Const mMODUL_NAME = \"getEnviromentVar\"\n   \n   On Error GoTo getEnviromentVar_ERROR\n   \n   intCount = 1\n   strReturnValue = \"VarNotInitialized\"\n   \n   ' Gleichheitszeichen zu strEnviroment_IN hinzufügen,\n   ' damit z.B. TEMP= erhalten wird\n   If Not Right(Trim(strEnviroment_IN), 1) = \"=\" Then\n      strEnviroment_IN = Trim(strEnviroment_IN) & \"=\"\n   End If\n\n   ' alle Umgebungsvariablen auf strEnviroment_IN\n   ' durchsuchen\n   Do\n      strEnviroment = Environ(intCount)\n      intCount = intCount + 1\n   Loop Until Left(strEnviroment, Len(strEnviroment_IN)) = strEnviroment_IN Or _\n                                                           strEnviroment = \"\"\n\n   ' Umgebungsvariable ist initialisiert worden\n   If Left(strEnviroment, Len(strEnviroment_IN)) = strEnviroment_IN Then\n      \n      If Len(strEnviroment) > Len(strEnviroment_IN) Then\n         ' Zuweisung auswerten\n         strReturnValue = Trim(Right(strEnviroment, _\n                                     (Len(strEnviroment) - Len(strEnviroment_IN))))\n      Else\n         ' Umgebungsvariable wurde initialisiert, Zuweisung fehlt\n         strReturnValue = \"VarEmpty\"\n      End If\n   \n   End If\n\ngetEnviromentVar_EXIT:\n   getEnviromentVar = strReturnValue\n   Exit Function\n\ngetEnviromentVar_ERROR:\n   mvarMsg = MsgBox(\"Fehler: \" & err & \" \" & err.description, _\n                     vbOKOnly + vbCritical, _\n                     mMODUL_NAME & \": getEnviromentVar\")\n   Resume getEnviromentVar_EXIT\n\nEnd Function\n\n\nFunction XFree(path)\n'Path = \"C:\\\" oder so\n'Private Declare PtrSafe Function api_GetDiskFreeSpaceEx Lib \"kernel32\" Alias \"GetDiskFreeSpaceExA\" (ByVal lpRootPathName As String, lpFreeBytesAvailableToCaller As Currency, lpTotalNumberOfBytes As Currency, lpTotalNumberOfFreeBytes As Currency) As Long\nDim wResult, FreeBytesCaller, TotalBytes, TotalFreeBytes, TotalSpaceMB, FreeSpaceMB\n    wResult = api_GetDiskFreeSpaceEx(path, FreeBytesCaller, TotalBytes, TotalFreeBytes)\n\n        TotalSpaceMB = ((TotalBytes * 10000) / 1024) / 1024\n        FreeSpaceMB = ((FreeBytesCaller * 10000) / 1024) / 1024\n        \nMsgBox \"Path: \" & path & \" - FreeBytesCaller \" & FreeBytesCaller & vbCrLf & _\n\"TotalBytes \" & TotalBytes & vbCrLf & _\n\"TotalFreeBytes\" & TotalFreeBytes & vbCrLf & _\n\"TotalSpaceMB \" & TotalSpaceMB & vbCrLf & _\n\"FreeSpaceMB \" & FreeSpaceMB\n\nEnd Function\n\n\nFunction DOSPgmStart(DosAufruf As String, Optional AufrufArt As Integer = vbMinimizedNoFocus)\nDim varDummy\n' Hergeleitet aus dem Newsgroup-Beispiel\n' vardummy = Shell(Environ(\"COMSPEC\") & \" /C COPY \" & Quelle & \" \" & Ziel, 6)\n\n' Beispiel:\n' Nix = DOSPgmStart(\"Copy C:\\Autoexec.bat A:\", 6)\n\n' AufrufArt einer der folgenden 6 Parameter: (aus der Hilfe:)\n\n'vbHide              0   Fenster ist ausgeblendet, und das ausgeblendete Fenster erhält den Fokus.\n'vbNormalFocus       1   Fenster hat den Fokus und wird mit der ursprünglichen Größe und Position wiederhergestellt.\n'vbMinimizedFocus    2   Fenster wird als Symbol angezeigt und hat den Fokus.\n'vbMaximizedFocus    3   Fenster ist maximiert und hat den Fokus.\n'vbNormalNoFocus     4   Fenster wird mit der letzten Größe und Position wiederhergestellt. Das momentan aktive Fenster bleibt aktiv.\n'vbMinimizedNoFocus  6   Fenster wird als Symbol angezeigt. Das momentan aktive Fenster bleibt aktiv.\n\nvarDummy = Shell(Environ(\"COMSPEC\") & \" /C \" & DosAufruf, AufrufArt)\n\nEnd Function\n\n\n\nFunction WriteSystemTbl()\n\nDim Div As String\nDim Vgl As String\nDim rst As DAO.Recordset\nDim i As Integer\nDim j As Long\nDim k As Long\nDim ErrorMode&\nDim DType As Long\nDim nix\nDim BinaryData() As Byte\nDim xstr As String\nDim strWinSerNr As String\n\nstrWinSerNr = WinSerNr()\n\n'Debug.Print strWinSerNr\n\nDiv = atCNames(2)\n\nErrorMode = api_SetErrorMode(SEM_NOOPENFILEERRORBOX + SEM_NOGPFAULTERRORBOX)\n\nIf Len(Trim(Nz(TLookup(\"[Rechnername]\", \"tblRechner\", \"[Rechnername] = '\" & Div & \"'\")))) > 0 Then\n    CurrentDb.Execute (\"DELETE * FROM tblRechner WHERE Rechnername = '\" & Div & \"';\")\nEnd If\n\nSet rst = CurrentDb.OpenRecordset(\"SELECT TOP 1 * FROM tblRechner;\", dbOpenDynaset)\n    \n    With rst\n'Rechnername       Text          20\n'IPNr              Text          20\n'ProcTyp           Text          50\n'ProcAnz           Byte          1\n'ProcName          Text          120\n'ProcSpeedMHZ      Text          50\n'MemMB             Text          50\n'WinPlatf          Text          50\n'WinVers           Text          50\n'WinCSD            Text          130\n'BildPixel         Text          50\n'Bildmm            Text          50\n'BildFarbe         Text          50\n'WinSerNr          Text          255\n'LicenseInfo       Text          255\n'DigitalProductID  Text          255\n'ProductID         Text          255\n'Erst_Am           Date/Time     8\n'Erst_Von          Text          20\n            .AddNew\n'            .Edit\n            \n            .fields(0) = Div\n            .fields(1) = GetIPAddress()\n            .fields(2) = atGetSysStatus(2)\n            .fields(3) = atGetSysStatus(1)\n            .fields(4) = GetCPUSpeedName(2)\n            .fields(5) = GetCPUSpeedName(1) & \" MHZ\"\n            .fields(6) = (atGetMem(1) / 1024) & \" KB\"\n            .fields(7) = atWinver(3)\n            .fields(8) = atWinver(0) & \".\" & atWinver(1) & \" / \" & atWinver(2)\n            .fields(9) = atWinver(4)\n            .fields(10) = atGetdevcaps(10) & \" x \" & atGetdevcaps(10) & \" Pixel\"\n            .fields(11) = atGetdevcaps(4) & \" x \" & atGetdevcaps(6) & \" mm\"\n            .fields(12) = atGetColourCap()\n            .fields(13) = strWinSerNr\n            .fields(14) = GetRegistryValue(HKEY_LOCAL_MACHINE, \"Software\\Microsoft\\Windows NT\\CurrentVersion\", \"LicenseInfo\")\n            .fields(15) = GetRegistryValue(HKEY_LOCAL_MACHINE, \"Software\\Microsoft\\Windows NT\\CurrentVersion\", \"DigitalProductID\")\n            .fields(16) = GetRegistryValue(HKEY_LOCAL_MACHINE, \"Software\\Microsoft\\Windows NT\\CurrentVersion\", \"ProductID\")\n            .fields(17) = Now()\n            .fields(18) = atCNames(1)\n\n            .update\n            .Close\n        End With\n        Set rst = Nothing\n\n    Set rst = CurrentDb.OpenRecordset(\"SELECT TOP 1 * FROM tblRechnerFestpl;\", dbOpenDynaset)\n        For i = 65 To 90 ' A - Z\n            DType = atDriveType(Chr$(i))\n            If DType = 3 Then   ' Festplatte, kein Netzwerk ...\n        \n                With rst\n                    .AddNew\n        'ID            Long Integer  4\n        'Rechnername   Text          20\n        'LW            Text          5\n        'Partitionsize Text          50\n        'LwSerienNr    Text          50\n        'Erst_Am       Date/Time     8\n        'Erst_Von      Text          20\n        \n                    .fields(1) = Div\n                    .fields(2) = Chr$(i)\n                    .fields(3) = atDiskFreeSpaceEx(Chr$(i))\n                    .fields(4) = VolSerialNoErm(Chr$(i) & \":\\\")\n                    .fields(5) = Now()\n                    .fields(6) = atCNames(1)\n        \n                    .update\n                \n                End With\n            End If\n        Next i\n        \n        \n        rst.Close\n        Set rst = Nothing\n        ErrorMode = api_SetErrorMode(ErrorMode)\n\nEnd Function\n\nFunction WinSerNr() As String\n\n''Das habe ich für VB.NET gefunden, geht aber auch so ähnlich in VB6 ...\n''\n''Windows serial number is stored in the registry.\n''\n''This example shows how to get it.\n''\n''Dim myReg As RegistryKey = Registry.LocalMachine\n''Dim MyRegKey As RegistryKey\n''Dim MyVal As String\n''\n''?QueryValue(HKEY_LOCAL_MACHINE, \"Software\\Microsoft\\Windows NT\\CurrentVersion\", \"ProductID\")\n'\n''Function GetRegistryValue(ByVal hKey As Long, ByVal KeyName As String, _\n''    ByVal ValueName As String, Optional DefaultValue As Variant) As Variant\n'\n''?GetRegistryValue(HKEY_LOCAL_MACHINE, \"Software\\Microsoft\\Windows NT\\CurrentVersion\", \"LicenseInfo\")\n''?GetRegistryValue(HKEY_LOCAL_MACHINE, \"Software\\Microsoft\\Windows NT\\CurrentVersion\", \"DigitalProductID\")\n'\n'\n''MyRegKey = myReg.OpenSubKey(\"Software\\Microsoft\\Windows NT\\CurrentVersion\")\n''MyVal = MyRegKey.GetValue(\"ProductID\")\n''MyRegKey.Close()\n'\n''LicenseInfo REG_BINARY\n''DigitalProductID REG_BINARY\n''ProductID REG_SZ\n'\n'Dim I As Integer\n'Dim J As Long\n'Dim K As Long\n'Dim nix\n'\n'Dim iNr As Long\n'\n'Dim C_strPath As String\n'\n'C_strPath = GetTempDir()\n'\n'If Not File_exist(C_strPath & \"JSKeyfinder.exe\") Then\n'\n'    nix = Path_erzeugen(C_strPath, False)\n'    nix = BinExport(\"tblPicture\", C_strPath & \"JSKeyfinder.exe\", \"Picture\", 2)\n'    Call Sleep(1000)\n'    DoEvents\n'\n'End If\n'\n'' Achtung, das Programm bleibt im Speicher bis es abgeschossen wird ...\n'iNr = Shell(C_strPath & \"JSKeyfinder.exe /e\", 0)\n'\n'Dim Nr As Long\n'Nr = FreeFile\n'\n'Dim Textzeile\n''Dim GesText() As String\n'\n'DoEvents\n'Call Sleep(200)\n'DoEvents\n'\n'Open C_strPath & \"ExportedSerials.txt\" For Input As #Nr    ' Datei öffnen.\n'I = 0\n'WinSerNr = \"\"\n'Do While Not EOF(Nr)    ' Schleife bis Dateiende.\n'    Line Input #Nr, Textzeile    ' Zeile in Variable einlesen.\n'    If Len(Trim(Nz(Textzeile))) > 0 Then\n''        ReDim Preserve GesText(I)\n''        GesText(I) = Textzeile\n'        I = I + 1\n'        If Left(Textzeile, 17) = \"Microsoft Windows\" Then\n'            ' man kann, wenn man die Länge der Seriennummer kennt, Right(Textzeile, nn)  verwenden\n'            ' dann benötigt man keinen Loop\n'            ' Bei mir ist die Windows XP Seriennummer 29 Zeichen lang\n''            WinSerNr = Right(Textzeile, 29)\n''           ' Am sichersten scheint mir zu sein, dass der Key immer an Stelle 56 anfängt\n'            WinSerNr = Trim(Mid(Textzeile, 56))\n'            Exit Do\n'''            ' Funktioniert nur, wenn die SerialNr immer ein einzelner String\n'''            ' als Ganzes ist und keine Blanks enthält\n'''            J = Len(Textzeile)\n'''            For K = J To 1 Step -1\n'''                If Mid(Textzeile, K, 1) = \" \" Then\n'''                    J = K + 1\n'''                    WinSerNr = Mid(Textzeile, J)\n'''                    Exit For\n'''                    Exit Do\n'''                End If\n'''            Next K\n'        End If\n'    End If\n''    Debug.Print Textzeile    ' Ausgabe im Direktfenster.\n'Loop\n'Close #Nr    ' Datei schließen.\n'\n'DoEvents\n'KillProcess \"JSKeyfinder.exe\"\n'\nEnd Function\n\nPublic Function getMDBVersion(fileName As String) As String\nDim daoObject As Object\nDim db As Object\n\nSet daoObject = CreateObject(\"DAO.DBEngine.36\")\nSet db = daoObject.OpenDatabase(fileName, False, True)\nOn Error Resume Next\ngetMDBVersion = \"Access Version \" & _\ndb.Properties(\"AccessVersion\") & _\n\". Jet Version: \" & db.version\nIf err Then\ngetMDBVersion = \"Keine Access Anwendung\" & _\n\". Jet Version: \" & db.version\nerr.clear\nEnd If\ndb.Close\nSet db = Nothing\nSet daoObject = Nothing\nEnd Function\n'Zum Testen im Direktbereich (Strg+G; Testfenster)\n'?getMDBVersion(\"C:\\Test.mdb\")\n'Access Version 07.53. Jet Version: 3.0 (A97)\n'Access Version 08.50. Jet Version: 4.0 (A2000)\n'Access Version 09.50. Jet Version: 4.0 (A2002)\n'Access Version 10.50. Jet Version: 4.0 (A2003)\n\n\nFunction conn_dbname(s As String, su As String) As String\n'DRIVER=SQL Server;SERVER=(local);Trusted_Connection=Yes;APP=Microsoft Office 2010;DATABASE=Cancom_Main_001_BE;xxxxxxxxxxxxxxxxxxxxxxxx\nDim i As Long, j As Long, st As String, il As Long\nil = Len(Trim(Nz(su)))\nconn_dbname = \"\"\nIf il = 0 Then Exit Function\n\nst = \"\"\ni = InStr(1, s, su, vbTextCompare)\nIf i > 0 Then\n    j = InStr(i, s, \";\", vbTextCompare)\n    If j > 0 Then\n        st = Mid(s, i + il, j - i - il)\n    Else\n        st = Mid(s, i + il)\n    End If\nEnd If\nconn_dbname = st\nEnd Function\n"}
