{"id":"MOD_basGDIPlus_OGL","name":"basGDIPlus_OGL","kind":"standard","procedures":["Function GetGDIPVersion() As Boolean","Function InitGDIP() As Boolean","Sub ShutDownGDIP()","Private Sub AutoShutDown()","Private Sub TimerProc(ByVal hwnd As Long, ByVal uMsg As Long, ByVal idEvent As Long, ByVal dwTime As Long)","Function UsesOGL() As Boolean","Function LoadPictureGDIP(sFilename As String) As StdPicture","Function ResampleGDIP(ByVal image As StdPicture, ByVal width As Long, ByVal height As Long) As StdPicture","Function CropImage(ByVal image As StdPicture, _","Function GetDimensionsGDIP(ByVal image As StdPicture) As TSize","Function SavePicGDIPlus(ByVal image As StdPicture, sFile As String, _","Function ArrayFromPicture(ByVal image As Object, PicType As PicFileType, Optional Quality As Long = 80) As Byte()","Public Function AttachmentToPicture(strTable As String, strAttachmentField As String, strImage As String) As StdPicture","Public Function PicFromField(ByVal picField As DAO.field, Optional FlattenColor As Variant = &HFFFFFFFF) As StdPicture","Public Function ArrayToPicture(ByRef PicBin() As Byte, Optional FlattenColor As Variant) As StdPicture","Function MaskFromPicture(ByVal image As StdPicture, Optional TransColor As Variant) As StdPicture","Function BitmapToPicture(ByVal hBmp As Long, Optional bIsIcon As Boolean = False) As StdPicture","Function LoadPictureGDIP_O(sFilename As String) As StdPicture","Function ResampleGDIP_O(ByVal image As StdPicture, ByVal width As Long, ByVal height As Long) As StdPicture","Function CropImage_O(ByVal image As StdPicture, _","Function GetDimensionsGDIP_O(ByVal image As StdPicture) As TSize","Function SavePicGDIPlus_O(ByVal image As StdPicture, sFile As String, _","Function ArrayFromPicture_O(ByVal image As Object, PicType As PicFileType, Optional Quality As Long = 80) As Byte()","Public Function AttachmentToPicture_O(strTable As String, strAttachmentField As String, strImage As String) As StdPicture","Public Function ArrayToPicture_O(ByRef PicBin() As Byte, Optional FlattenColor As Variant) As StdPicture","Function MaskFromPicture_O(ByVal image As StdPicture, Optional TransColor As Variant) As StdPicture","Function Save_as_Jpg(strIn As String, strOut As String, Optional iQuality As Long = 70)"],"calls":{"DoCmd.OpenForm":[],"DoCmd.OpenReport":[],"DoCmd.RunSQL":[],"CurrentDb.Execute":[],"DLookup":[],"DCount":[],"DMax":[],"DMin":[]},"source":"Option Compare Database\nOption Explicit\n\n'-------------------------------------------------\n'    Picture functions using GDIPlus-API (GDIP)   |\n'-------------------------------------------------\n'    *  Office 2003/2007/2010 version  *          |\n'-------------------------------------------------\n'   (c) mossSOFT / Sascha Trowitzsch rev. 08/2010 |\n'-------------------------------------------------\n\n'- Reference to library \"OLE Automation\" (stdole) needed!\n\nPublic Const GUID_IPicture = \"{7BF80980-BF32-101A-8BBB-00AA00300CAB}\"    'IPicture\n\n'User-defined types: ----------------------------------------------------------------------\n\nPublic Enum PicFileType\n    pictypeBMP = 1\n    pictypeGIF = 2\n    pictypePNG = 3\n    pictypeJPG = 4\nEnd Enum\n\nPrivate Enum GpUnit\n   UnitWorld = 0        ' World coordinate (non-physical unit)\n   UnitDisplay = 1      ' Variable -- for PageTransform only\n   UnitPixel = 2        ' Each unit is one device pixel.\n   UnitPoint = 3        ' Each unit is a printer's point, or 1/72 inch.\n   UnitInch = 4         ' Each unit is 1 inch.\n   UnitDocument = 5     ' Each unit is 1/300 inch.\n   UnitMillimeter = 6   ' Each unit is 1 millimeter.\nEnd Enum\n\nPrivate Enum PixelFormat\n    PixelFormat1bppIndexed = &H30101\n    PixelFormat4bppIndexed = &H30402\n    pixelFormat8bppIndexed = &H30803\n    PixelFormat16bppGreyScale = &H101004\n    PixelFormat16bppRGB555 = &H21005\n    PixelFormat16bppRGB565 = &H21006\n    PixelFormat16bppARGB1555 = &H61007\n    PixelFormat24bppRGB = &H21808\n    PixelFormat32bppRGB = &H22009\n    PixelFormat32bppARGB = &H26200A\n    PixelFormat32bppPARGB = &HE200B\n    PixelFormat48bppRGB = &H10300C\n    PixelFormat64bppARGB = &H34400D\n    PixelFormat64bppPARGB = &H1C400E\n    PixelFormatMax = 15 '&HF\nEnd Enum\n\nPrivate Enum ImageLockMode\n   ImageLockModeRead = &H1\n   ImageLockModewrite = &H2\n   ImageLockModeUserInputBuf = &H4\nEnd Enum\n\nPrivate Type guid\n    Data1 As Long\n    Data2 As Integer\n    Data3 As Integer\n    Data4(7) As Byte\nEnd Type\n\nPublic Type TSize\n    X As Double\n    Y As Double\nEnd Type\n\nPrivate Type RECT\n    Bottom As Long\n    Left As Long\n    Right As Long\n    Top As Long\nEnd Type\n\nPrivate Type RECTL\n    Bottom As Long\n    Left As Long\n    Right As Long\n    Top As Long\nEnd Type\n\nPrivate Type PICTDESC\n    cbSizeOfStruct As Long\n    PicType As Long\n    hImage As Long\n    XExt As Long\n    yExt As Long\nEnd Type\n\nPrivate Type GDIPStartupInput\n    GdiplusVersion As Long\n    DebugEventCallback As Long\n    SuppressBackgroundThread As Long\n    SuppressExternalCodecs As Long\nEnd Type\n\nPrivate Type EncoderParameter\n    UUID As guid\n    NumberOfValues As Long\n    Type As Long\n    Value As LongPtr\nEnd Type\n\nPrivate Type EncoderParameters\n    Count As Long\n    Parameter As EncoderParameter\nEnd Type\n\nPrivate Type BitmapData\n   width As Long\n   height As Long\n   stride As Long\n   PixelFormat As Long\n   scan0 As LongPtr\n   Reserved As Long\nEnd Type\n\n'Common API-Declarations: ----------------------------------------------------------------------------\n\n'Convert a windows bitmap to OLE-Picture :\nPrivate Declare PtrSafe Function OleCreatePictureIndirect Lib \"oleaut32.dll\" (lpPictDesc As PICTDESC, riid As guid, ByVal fPictureOwnsHandle As Long, IPic As Object) As Long\n'Retrieve GUID-Type from string :\nPrivate Declare PtrSafe Function CLSIDFromString Lib \"ole32\" (ByVal lpsz As Any, pclsid As guid) As Long\n\n'Memory functions:\nPrivate Declare PtrSafe Function GlobalAlloc Lib \"kernel32\" (ByVal uFlags As Long, ByVal dwBytes As Long) As Long\nPrivate Declare PtrSafe Function GlobalSize Lib \"kernel32.dll\" (ByVal hMem As Long) As Long\nPrivate Declare PtrSafe Function GlobalLock Lib \"kernel32.dll\" (ByVal hMem As Long) As Long\nPrivate Declare PtrSafe Function GlobalUnlock Lib \"kernel32.dll\" (ByVal hMem As Long) As Long\nPrivate Declare PtrSafe Function GlobalFree Lib \"kernel32\" (ByVal hMem As Long) As Long\nPrivate Declare PtrSafe Sub CopyMemory Lib \"kernel32.dll\" Alias \"RtlMoveMemory\" (ByRef Destination As Any, ByRef Source As Any, ByVal Length As Long)\nPrivate Declare PtrSafe Sub MoveMemory Lib \"kernel32\" Alias \"RtlMoveMemory\" (ByVal Destination As Long, ByRef Source As Byte, ByVal Length As Long)\n\n'Modules API:\nPrivate Declare PtrSafe Function FreeLibrary Lib \"kernel32.dll\" (ByVal hLibModule As Long) As Long\nPrivate Declare PtrSafe Function LoadLibrary Lib \"kernel32.dll\" Alias \"LoadLibraryA\" (ByVal lpLibFileName As String) As Long\nPrivate Declare PtrSafe Function GetModuleHandle Lib \"kernel32.dll\" Alias \"GetModuleHandleA\" (ByVal lpModuleName As String) As Long\nPrivate Declare PtrSafe Function GetProcAddress Lib \"kernel32.dll\" (ByVal hModule As Long, ByVal lpProcName As String) As Long\n\n'Timer API:\nPrivate Declare PtrSafe Function SetTimer Lib \"user32\" (ByVal hwnd As Long, ByVal nIDEvent As Long, ByVal uElapse As Long, ByVal lpTimerFunc As LongPtr) As Long\nPrivate Declare PtrSafe Function KillTimer Lib \"user32\" (ByVal hwnd As Long, ByVal nIDEvent As Long) As Long\n\n\n'OLE-Stream functions :\nPrivate Declare PtrSafe Function CreateStreamOnHGlobal Lib \"ole32\" (ByVal hGlobal As LongPtr, ByVal fDeleteOnRelease As Long, ByRef ppstm As Any) As Long\nPrivate Declare PtrSafe Function GetHGlobalFromStream Lib \"ole32.dll\" (ByVal pstm As Any, ByRef phglobal As Long) As Long\n\n'GDIPlus Flat-API declarations ----------------------------------------------------------------------------\n\n'*Remark:\n'          We use a special gdi+ version here that comes with Office 2007/2010! (program files\\common files\\microsoft shared\\office1x\\ogl.dll)\n'          Benefit: No need to load a separate dll because ogl.dll is normally already loaded by Office 2007/2010.\n'          ogl.dll is identical to the gdiplus.dll (V1.1) used in Vista\n'Remark 2: This DLL is only installed by Office Setup (and also Access Runtime) if OS = WinXP.\n'          On Vista or Win7 Office 2010 uses the built-in GDIPLUS.DLL !\n\n\n'OGL.DLL library declarations:\n\n'Initialization OGL:\nPrivate Declare PtrSafe Function GdiplusStartup_O Lib \"ogl\" Alias \"GdiplusStartup\" (token As Long, inputbuf As GDIPStartupInput, Optional ByVal outputbuf As Long = 0) As Long\n'Tear down GDIP:\nPrivate Declare PtrSafe Function GdiplusShutdown_O Lib \"ogl\" Alias \"GdiplusShutdown\" (ByVal token As Long) As Long\n'Load GDIP-Image from file :\nPrivate Declare PtrSafe Function GdipCreateBitmapFromFile_O Lib \"ogl\" Alias \"GdipCreateBitmapFromFile\" (ByVal fileName As LongPtr, BITMAP As Long) As Long\n'Create GDIP- graphical area from Windows-DeviceContext:\nPrivate Declare PtrSafe Function GdipCreateFromHDC_O Lib \"ogl\" Alias \"GdipCreateFromHDC\" (ByVal hdc As Long, GpGraphics As Long) As Long\n'Delete GDIP graphical area :\nPrivate Declare PtrSafe Function GdipDeleteGraphics_O Lib \"ogl\" Alias \"GdipDeleteGraphics\" (ByVal graphics As Long) As Long\n'Copy GDIP-Image to graphical area:\nPrivate Declare PtrSafe Function GdipDrawImageRect_O Lib \"ogl\" Alias \"GdipDrawImageRect\" (ByVal graphics As Long, ByVal image As Long, ByVal X As Single, ByVal Y As Single, ByVal width As Single, ByVal height As Single) As Long\n'Clear allocated bitmap memory from GDIP :\nPrivate Declare PtrSafe Function GdipDisposeImage_O Lib \"ogl\" Alias \"GdipDisposeImage\" (ByVal image As Long) As Long\n'Retrieve windows bitmap handle from GDIP-Image:\nPrivate Declare PtrSafe Function GdipCreateHBITMAPFromBitmap_O Lib \"ogl\" Alias \"GdipCreateHBITMAPFromBitmap\" (ByVal BITMAP As Long, hbmReturn As Long, ByVal background As Long) As Long\n'Retrieve Windows-Icon-Handle from GDIP-Image:\nPublic Declare PtrSafe Function GdipCreateHICONFromBitmap_O Lib \"ogl\" Alias \"GdipCreateHICONFromBitmap\" (ByVal BITMAP As Long, hbmReturn As Long) As Long\n'Scaling GDIP-Image size:\nPrivate Declare PtrSafe Function GdipGetImageThumbnail_O Lib \"ogl\" Alias \"GdipGetImageThumbnail\" (ByVal image As Long, ByVal thumbWidth As Long, ByVal thumbHeight As Long, thumbImage As Long, Optional ByVal callback As Long = 0, Optional ByVal callbackData As Long = 0) As Long\n'Retrieve GDIP-Image from Windows-Bitmap-Handle:\nPrivate Declare PtrSafe Function GdipCreateBitmapFromHBITMAP_O Lib \"ogl\" Alias \"GdipCreateBitmapFromHBITMAP\" (ByVal hbm As Long, ByVal hPal As Long, BITMAP As Long) As Long\n'Retrieve GDIP-Image from Windows-Icon-Handle:\nPrivate Declare PtrSafe Function GdipCreateBitmapFromHICON_O Lib \"ogl\" Alias \"GdipCreateBitmapFromHICON\" (ByVal hicon As Long, BITMAP As Long) As Long\n'Retrieve width of a GDIP-Image (Pixel):\nPrivate Declare PtrSafe Function GdipGetImageWidth_O Lib \"ogl\" Alias \"GdipGetImageWidth\" (ByVal image As Long, width As Long) As Long\n'Retrieve height of a GDIP-Image (Pixel):\nPrivate Declare PtrSafe Function GdipGetImageHeight_O Lib \"ogl\" Alias \"GdipGetImageHeight\" (ByVal image As Long, height As Long) As Long\n'Save GDIP-Image to file in seletable format:\nPrivate Declare PtrSafe Function GdipSaveImageToFile_O Lib \"ogl\" Alias \"GdipSaveImageToFile\" (ByVal image As Long, ByVal fileName As LongPtr, clsidEncoder As guid, encoderParams As Any) As Long\n'Save GDIP-Image in OLE-Stream with seletable format:\nPrivate Declare PtrSafe Function GdipSaveImageToStream_O Lib \"ogl\" Alias \"GdipSaveImageToStream\" (ByVal image As Long, ByVal stream As IUnknown, clsidEncoder As guid, encoderParams As Any) As Long\n'Retrieve GDIP-Image from OLE-Stream-Object:\nPrivate Declare PtrSafe Function GdipLoadImageFromStream_O Lib \"ogl\" Alias \"GdipLoadImageFromStream\" (ByVal stream As IUnknown, image As Long) As Long\n'Create a gdip image from scratch\nPrivate Declare PtrSafe Function GdipCreateBitmapFromScan0_O Lib \"ogl\" Alias \"GdipCreateBitmapFromScan0\" (ByVal width As Long, ByVal height As Long, ByVal stride As Long, ByVal PixelFormat As Long, scan0 As Any, BITMAP As Long) As Long\n'Get the DC of an gdip image\nPrivate Declare PtrSafe Function GdipGetImageGraphicsContext_O Lib \"ogl\" Alias \"GdipGetImageGraphicsContext\" (ByVal image As Long, graphics As Long) As Long\n'Blit the contents of an gdip image to another image DC using positioning\nPrivate Declare PtrSafe Function GdipDrawImageRectRectI_O Lib \"ogl\" Alias \"GdipDrawImageRectRectI\" (ByVal graphics As Long, ByVal image As Long, ByVal dstx As Long, ByVal dsty As Long, ByVal dstwidth As Long, ByVal dstheight As Long, ByVal srcx As Long, ByVal srcy As Long, ByVal srcwidth As Long, ByVal srcheight As Long, ByVal srcUnit As Long, Optional ByVal imageAttributes As Long = 0, Optional ByVal callback As Long = 0, Optional ByVal callbackData As Long = 0) As Long\n'Duplicates a gdiplus image object\nPrivate Declare PtrSafe Function GdipCloneImage_O Lib \"ogl\" Alias \"GdipCloneImage\" (ByVal image As Long, cloneImage As Long) As Long\n'Clear device context and set background color\nPrivate Declare PtrSafe Function GdipGraphicsClear_O Lib \"ogl\" Alias \"GdipGraphicsClear\" (ByVal graphics As Long, ByVal lColor As Long) As Long\n'Suspend image to work with its data (pixels)\nPrivate Declare PtrSafe Function GdipBitmapLockBits_O Lib \"ogl\" Alias \"GdipBitmapLockBits\" (ByVal BITMAP As Long, RECT As RECTL, ByVal Flags As ImageLockMode, ByVal PixelFormat As Long, lockedBitmapData As BitmapData) As Long\n'Continue to use altered image in GDIP\nPrivate Declare PtrSafe Function GdipBitmapUnlockBits_O Lib \"ogl\" Alias \"GdipBitmapUnlockBits\" (ByVal BITMAP As Long, lockedBitmapData As BitmapData) As Long\n\n\n'Same for simple GDIPLUS.DLL:\nPrivate Declare PtrSafe Function GdiplusStartup Lib \"gdiplus\" (token As Long, inputbuf As GDIPStartupInput, Optional ByVal outputbuf As Long = 0) As Long\nPrivate Declare PtrSafe Function GdiplusShutdown Lib \"gdiplus\" (ByVal token As Long) As Long\nPrivate Declare PtrSafe Function GdipCreateBitmapFromFile Lib \"gdiplus\" (ByVal fileName As LongPtr, BITMAP As Long) As Long\nPrivate Declare PtrSafe Function GdipCreateFromHDC Lib \"gdiplus\" (ByVal hdc As Long, GpGraphics As Long) As Long\nPrivate Declare PtrSafe Function GdipDeleteGraphics Lib \"gdiplus\" (ByVal graphics As Long) As Long\nPrivate Declare PtrSafe Function GdipDrawImageRect Lib \"gdiplus\" (ByVal graphics As Long, ByVal image As Long, ByVal X As Single, ByVal Y As Single, ByVal width As Single, ByVal height As Single) As Long\nPrivate Declare PtrSafe Function GdipDisposeImage Lib \"gdiplus\" (ByVal image As Long) As Long\nPrivate Declare PtrSafe Function GdipCreateHBITMAPFromBitmap Lib \"gdiplus\" (ByVal BITMAP As Long, hbmReturn As Long, ByVal background As Long) As Long\nPrivate Declare PtrSafe Function GdipCreateHICONFromBitmap Lib \"gdiplus\" (ByVal BITMAP As Long, hbmReturn As Long) As Long\nPrivate Declare PtrSafe Function GdipGetImageThumbnail Lib \"gdiplus\" (ByVal image As Long, ByVal thumbWidth As Long, ByVal thumbHeight As Long, thumbImage As Long, Optional ByVal callback As Long = 0, Optional ByVal callbackData As Long = 0) As Long\nPrivate Declare PtrSafe Function GdipCreateBitmapFromHBITMAP Lib \"gdiplus\" (ByVal hbm As Long, ByVal hPal As Long, BITMAP As Long) As Long\nPrivate Declare PtrSafe Function GdipCreateBitmapFromHICON Lib \"gdiplus\" (ByVal hicon As Long, BITMAP As Long) As Long\nPrivate Declare PtrSafe Function GdipGetImageWidth Lib \"gdiplus\" (ByVal image As Long, width As Long) As Long\nPrivate Declare PtrSafe Function GdipGetImageHeight Lib \"gdiplus\" (ByVal image As Long, height As Long) As Long\nPrivate Declare PtrSafe Function GdipSaveImageToFile Lib \"gdiplus\" (ByVal image As Long, ByVal fileName As LongPtr, clsidEncoder As guid, encoderParams As Any) As Long\nPrivate Declare PtrSafe Function GdipSaveImageToStream Lib \"gdiplus\" (ByVal image As Long, ByVal stream As IUnknown, clsidEncoder As guid, encoderParams As Any) As Long\nPrivate Declare PtrSafe Function GdipLoadImageFromStream Lib \"gdiplus\" (ByVal stream As IUnknown, image As Long) As Long\nPrivate Declare PtrSafe Function GdipCreateBitmapFromScan0 Lib \"gdiplus\" (ByVal width As Long, ByVal height As Long, ByVal stride As Long, ByVal PixelFormat As Long, scan0 As Any, BITMAP As Long) As Long\nPrivate Declare PtrSafe Function GdipGetImageGraphicsContext Lib \"gdiplus\" (ByVal image As Long, graphics As Long) As Long\nPrivate Declare PtrSafe Function GdipDrawImageRectRectI Lib \"gdiplus\" (ByVal graphics As Long, ByVal image As Long, ByVal dstx As Long, ByVal dsty As Long, ByVal dstwidth As Long, ByVal dstheight As Long, ByVal srcx As Long, ByVal srcy As Long, ByVal srcwidth As Long, ByVal srcheight As Long, ByVal srcUnit As Long, Optional ByVal imageAttributes As Long = 0, Optional ByVal callback As Long = 0, Optional ByVal callbackData As Long = 0) As Long\nPrivate Declare PtrSafe Function GdipCloneImage Lib \"gdiplus\" (ByVal image As Long, cloneImage As Long) As Long\nPrivate Declare PtrSafe Function GdipGraphicsClear Lib \"gdiplus\" (ByVal graphics As Long, ByVal lColor As Long) As Long\nPrivate Declare PtrSafe Function GdipBitmapLockBits Lib \"gdiplus\" (ByVal BITMAP As Long, RECT As RECTL, ByVal Flags As ImageLockMode, ByVal PixelFormat As Long, lockedBitmapData As BitmapData) As Long\nPrivate Declare PtrSafe Function GdipBitmapUnlockBits Lib \"gdiplus\" (ByVal BITMAP As Long, lockedBitmapData As BitmapData) As Long\n\n\n'-----------------------------------------------------------------------------------------\n'Global module variables:\nPrivate lGDIP As Long           'GDIPLus object instance\nPrivate bSharedLoad As Boolean  'Is gdiplus.dll or ogl.dll already loaded by Access? (In this case do not FreeLibrary module)\nPrivate bUseOGL As Boolean      'If True use ogl.dll, otherwise gdiplus.dll\nPrivate IsGDI11 As Boolean      'Is GDIPLUS version 1.1 or 1.0? (1.1 supports effects like Sharpen etc.)\nPrivate lTimer As Long          'Timer Handle for AutoShutdown\n'Be sure to have error handlers in all your VBA procedures since unhandled errors clear the above variables\n'This may cause instableties or even crashes due to memory leaks in gdiplus!\n'-----------------------------------------------------------------------------------------\n\nFunction GetGDIPVersion() As Boolean\n    Dim hMod As Long\n    Select Case Application.version\n    \n        Case \"11.0\", \"15.0\" 'A2003, A2013\n            bUseOGL = False\n            hMod = GetModuleHandle(\"gdiplus.dll\")\n            If hMod = 0 Then\n                hMod = LoadLibrary(\"gdiplus.dll\")\n            Else\n                bSharedLoad = True\n            End If\n            Dim lAddr As Long\n            lAddr = GetProcAddress(hMod, \"GdipCreateEffect\")    'Check if effect section is supported by GDIPLUS module (=V 1.1)\n            IsGDI11 = (lAddr <> 0)\n            \n        Case \"12.0\" 'A2007\n            bUseOGL = True\n            IsGDI11 = True\n            hMod = GetModuleHandle(\"ogl.dll\")\n            If hMod = 0 Then\n                hMod = LoadLibrary(Environ$(\"CommonProgramFiles\") & \"\\Microsoft Shared\\Office12\\ogl.dll\")\n            Else\n                bSharedLoad = True\n            End If\n            \n        Case \"14.0\" 'A2010\n            IsGDI11 = True\n            'Office 2010 Setup only installs the OGL module, if OS <> Vista or Win7!\n            'Check here for existance:\n            hMod = GetModuleHandle(\"ogl.dll\")   'Attempt Shared OGL\n            If hMod <> 0 Then\n                bUseOGL = True\n                bSharedLoad = True\n            Else\n                hMod = GetModuleHandle(\"gdiplus.dll\")   'Attempt Shared GDIPLUS\n                If hMod <> 0 Then bSharedLoad = True\n            End If\n            If hMod = 0 Then    'Not Shared, so load the library...\n                hMod = LoadLibrary(Environ$(\"CommonProgramFiles\") & \"\\Microsoft Shared\\Office14\\ogl.dll\")\n                If hMod <> 0 Then\n                    bUseOGL = True\n                Else\n                    hMod = LoadLibrary(\"gdiplus.dll\")   'OGL does not exist, so load Vistas or Win7s gdiplus.dll (= always V 1.1)\n                End If\n            End If\n    End Select\n    GetGDIPVersion = (hMod <> 0)    'Valid only if we could receive any module handle\nEnd Function\n\n'Initialize GDI+\nFunction InitGDIP() As Boolean\n    Dim TGDP As GDIPStartupInput\n    Dim hMod As Long\n\n    If lGDIP = 0 Then\n        If GetGDIPVersion Then  'Distinguish between Office and OS versions\n            TGDP.GdiplusVersion = 1\n            If bUseOGL Then 'Get a personal instance of gdiplus:\n                GdiplusStartup_O lGDIP, TGDP\n            Else\n                GdiplusStartup lGDIP, TGDP\n            End If\n            If lGDIP <> 0 Then AutoShutDown\n        End If\n    End If\n    InitGDIP = (lGDIP > 0)\nEnd Function\n\n'Clear GDI+\nSub ShutDownGDIP()\n    If lGDIP <> 0 Then\n        If KillTimer(0&, lTimer) Then lTimer = 0\n        If bUseOGL Then GdiplusShutdown_O lGDIP Else GdiplusShutdown lGDIP\n        lGDIP = 0\n        If Not bSharedLoad Then\n            If bUseOGL Then FreeLibrary GetModuleHandle(\"ogl.dll\") Else FreeLibrary GetModuleHandle(\"gdiplus.dll\")\n        End If\n    End If\nEnd Sub\n\n'Scheduled ShutDown of GDI+ handle to avoid memory leaks\nPrivate Sub AutoShutDown()\n    'Set to 5 seconds for next shutdown\n    'That's IMO appropriate for looped routines  - but configure for your own purposes\n    If lGDIP <> 0 Then\n        lTimer = SetTimer(0&, 0&, 5000, AddressOf TimerProc)\n    End If\nEnd Sub\n\n'Callback for AutoShutDown\nPrivate Sub TimerProc(ByVal hwnd As Long, ByVal uMsg As Long, ByVal idEvent As Long, ByVal dwTime As Long)\n    Debug.Print \"GDI+ AutoShutDown\", idEvent\n    If lTimer <> 0 Then\n        If KillTimer(0&, lTimer) Then lTimer = 0\n    End If\n    ShutDownGDIP\nEnd Sub\n\nFunction UsesOGL() As Boolean\n    If Not InitGDIP Then Exit Function\n    UsesOGL = bUseOGL\nEnd Function\n\n'Load image file with GDIP\n'It's equivalent to the method LoadPicture() in OLE-Automation library (stdole2.tlb)\n'Allowed format: bmp, gif, jp(e)g, tif, png, wmf, emf, ico\nFunction LoadPictureGDIP(sFilename As String) As StdPicture\n    Dim hBmp As Long\n    Dim hPic As Long\n\n    If Not InitGDIP Then Exit Function\n    If bUseOGL Then\n        Set LoadPictureGDIP = LoadPictureGDIP_O(sFilename)\n    Else\n        If GdipCreateBitmapFromFile(StrPtr(sFilename), hPic) = 0 Then\n            GdipCreateHBITMAPFromBitmap hPic, hBmp, 0&\n            If hBmp <> 0 Then\n                Set LoadPictureGDIP = BitmapToPicture(hBmp)\n                GdipDisposeImage hPic\n            End If\n        End If\n    End If\n\nEnd Function\n\n'Scale picture with GDIP\n'A Picture object is commited, also the return value\n'Width and Height of generatrix pictures in Width, Height\nFunction ResampleGDIP(ByVal image As StdPicture, ByVal width As Long, ByVal height As Long) As StdPicture\n    Dim lRes As Long\n    Dim lBitmap As Long\n\n    If Not InitGDIP Then Exit Function\n\n    If bUseOGL Then\n        Set ResampleGDIP = ResampleGDIP_O(image, width, height)\n    Else\n        If image.Type = 1 Then\n            lRes = GdipCreateBitmapFromHBITMAP(image.handle, 0, lBitmap)\n        Else\n            lRes = GdipCreateBitmapFromHICON(image.handle, lBitmap)\n        End If\n        If lRes = 0 Then\n            Dim lThumb As Long\n            Dim hBitmap As Long\n\n            lRes = GdipGetImageThumbnail(lBitmap, width, height, lThumb, 0, 0)\n            If lRes = 0 Then\n                If image.Type = 3 Then  'Image-Type 3 is named : Icon!\n                    'Convert with these GDI+ method :\n                    lRes = GdipCreateHICONFromBitmap(lThumb, hBitmap)\n                    Set ResampleGDIP = BitmapToPicture(hBitmap, True)\n                Else\n                    lRes = GdipCreateHBITMAPFromBitmap(lThumb, hBitmap, 0)\n                    Set ResampleGDIP = BitmapToPicture(hBitmap)\n                End If\n\n                GdipDisposeImage lThumb\n            End If\n            GdipDisposeImage lBitmap\n        End If\n    End If\n\nEnd Function\n\n'Extract a part of an image\n'x,y:   Left top corner of area to extract (pixel)\n'Width, Height: Width and height of area to extract\n'Return:    Image partly extracted\nFunction CropImage(ByVal image As StdPicture, _\n                   X As Long, Y As Long, _\n                   width As Long, height As Long) As StdPicture\n    Dim ret As Long\n    Dim lBitmap As Long\n    Dim lBitmap2 As Long\n    Dim lGraph As Long\n    Dim hBitmap As Long\n    Dim sx As Long, sy As Long\n\n    Const PixelFormat32bppARGB = &H26200A\n    Const UnitPixel = 2\n\n    If Not InitGDIP Then Exit Function\n\n    If bUseOGL Then\n        Set CropImage = CropImage_O(image, X, Y, width, height)\n    Else\n        ret = GdipCreateBitmapFromHBITMAP(image.handle, 0, lBitmap)\n        If ret = 0 Then\n            ret = GdipGetImageWidth(lBitmap, sx)\n            ret = GdipGetImageHeight(lBitmap, sy)\n            If (X + width) > sx Then width = sx - X\n            If (Y + height) > sy Then height = sy - Y\n            ret = GdipCreateBitmapFromScan0(CLng(width), CLng(height), _\n                                            0, PixelFormat32bppARGB, ByVal 0&, lBitmap2)\n            ret = GdipGetImageGraphicsContext(lBitmap2, lGraph)\n            ret = GdipDrawImageRectRectI(lGraph, lBitmap, 0&, 0&, _\n                                         width, height, X, Y, width, height, UnitPixel)\n            ret = GdipCreateHBITMAPFromBitmap(lBitmap2, hBitmap, 0)\n            Set CropImage = BitmapToPicture(hBitmap)\n\n            GdipDisposeImage lBitmap\n            GdipDisposeImage lBitmap2\n            GdipDeleteGraphics lGraph\n        End If\n    End If\n\nEnd Function\n\n'Retrieve Width and Height of a pictures in Pixel with GDIP\n'Return value as user/defined type TSize (X/Y als Long)\nFunction GetDimensionsGDIP(ByVal image As StdPicture) As TSize\n    Dim lRes As Long\n    Dim lBitmap As Long\n    Dim X As Long, Y As Long\n\n    If Not InitGDIP Then Exit Function\n    If image Is Nothing Then Exit Function\n    If bUseOGL Then\n        GetDimensionsGDIP = GetDimensionsGDIP_O(image)\n    Else\n        lRes = GdipCreateBitmapFromHBITMAP(image.handle, 0, lBitmap)\n        If lRes = 0 Then\n            GdipGetImageHeight lBitmap, Y\n            GdipGetImageWidth lBitmap, X\n            GetDimensionsGDIP.X = CDbl(X)\n            GetDimensionsGDIP.Y = CDbl(Y)\n            GdipDisposeImage lBitmap\n        End If\n    End If\n\nEnd Function\n\n'Save a bitmap as file (with format conversion!)\n'image = StdPicture object\n'sFile = complete file path\n'PicType = pictypeBMP, pictypeGIF, pictypePNG oder pictypeJPG\n'Quality: 0...100; (works only with pictypeJPG!)\n'Returns TRUE if successful\nFunction SavePicGDIPlus(ByVal image As StdPicture, sFile As String, _\n                        PicType As PicFileType, Optional Quality As Long = 80) As Boolean\n    Dim lBitmap As Long\n    Dim TEncoder As guid\n    Dim ret As Long\n    Dim TParams As EncoderParameters\n    Dim sType As String\n\n    If Not InitGDIP Then Exit Function\n\n    If bUseOGL Then\n        SavePicGDIPlus = SavePicGDIPlus_O(image, sFile, pictypeBMP, Quality)\n    Else\n        If GdipCreateBitmapFromHBITMAP(image.handle, 0, lBitmap) = 0 Then\n            Select Case PicType\n            Case pictypeBMP: sType = \"{557CF400-1A04-11D3-9A73-0000F81EF32E}\"\n            Case pictypeGIF: sType = \"{557CF402-1A04-11D3-9A73-0000F81EF32E}\"\n            Case pictypePNG: sType = \"{557CF406-1A04-11D3-9A73-0000F81EF32E}\"\n            Case pictypeJPG: sType = \"{557CF401-1A04-11D3-9A73-0000F81EF32E}\"\n            End Select\n            CLSIDFromString StrPtr(sType), TEncoder\n            If PicType = pictypeJPG Then\n                TParams.Count = 1\n                With TParams.Parameter    ' Quality\n                    CLSIDFromString StrPtr(\"{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}\"), .UUID\n                    .NumberOfValues = 1\n                    .Type = 4\n                    .Value = VarPtr(CLng(Quality))\n                End With\n            Else\n                'Different numbers of parameter between GDI+ 1.0 and GDI+ 1.1 on GIFs!!\n                If (PicType = pictypeGIF) Then TParams.Count = 1 Else TParams.Count = 0\n            End If\n            'Save GDIP-Image to file :\n            ret = GdipSaveImageToFile(lBitmap, StrPtr(sFile), TEncoder, TParams)\n            GdipDisposeImage lBitmap\n            DoEvents\n            'Function returns True, if generated file actually exists:\n            SavePicGDIPlus = (Dir(sFile) <> \"\")\n        End If\n    End If\n\nEnd Function\n\n'This procedure is similar to the above (see Parameter), the different is,\n'that nothing is stored as a file, but a conversion is executed\n'using a OLE-Stream-Object to an Byte-Array .\nFunction ArrayFromPicture(ByVal image As Object, PicType As PicFileType, Optional Quality As Long = 80) As Byte()\n    Dim lBitmap As Long\n    Dim TEncoder As guid\n    Dim ret As Long\n    Dim TParams As EncoderParameters\n    Dim sType As String\n    Dim IStm As IUnknown\n\n    If Not InitGDIP Then Exit Function\n\n    If bUseOGL Then\n        ArrayFromPicture = ArrayFromPicture_O(image, pictypeBMP, Quality)\n    Else\n        If GdipCreateBitmapFromHBITMAP(image.handle, 0, lBitmap) = 0 Then\n            Select Case PicType    'Choose GDIP-Format-Encoders CLSID:\n            Case pictypeBMP: sType = \"{557CF400-1A04-11D3-9A73-0000F81EF32E}\"\n            Case pictypeGIF: sType = \"{557CF402-1A04-11D3-9A73-0000F81EF32E}\"\n            Case pictypePNG: sType = \"{557CF406-1A04-11D3-9A73-0000F81EF32E}\"\n            Case pictypeJPG: sType = \"{557CF401-1A04-11D3-9A73-0000F81EF32E}\"\n            End Select\n            CLSIDFromString StrPtr(sType), TEncoder\n\n            If PicType = pictypeJPG Then    'If JPG, then set additional parameter\n                ' to apply quality level\n                TParams.Count = 1\n                With TParams.Parameter    ' Quality\n                    CLSIDFromString StrPtr(\"{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}\"), .UUID\n                    .NumberOfValues = 1\n                    .Type = 4\n                    .Value = VarPtr(CLng(Quality))\n                End With\n            Else\n                'Different number of parameters between GDI+ 1.0 and GDI+ 1.1 on GIFs!!\n                If (PicType = pictypeGIF) Then TParams.Count = 1 Else TParams.Count = 0\n            End If\n\n            ret = CreateStreamOnHGlobal(0&, 1, IStm)    'Create stream\n            'Save GDIP-Image to stream :\n            ret = GdipSaveImageToStream(lBitmap, IStm, TEncoder, TParams)\n            If ret = 0 Then\n                Dim hMem As Long, lSize As Long, lpMem As Long\n                Dim abData() As Byte\n\n                ret = GetHGlobalFromStream(IStm, hMem)    'Get memory handle from stream\n                If ret = 0 Then\n                    lSize = GlobalSize(hMem)\n                    lpMem = GlobalLock(hMem)   'Get access to memory\n                    ReDim abData(lSize - 1)    'Arrays dimension\n                    'Commit memory stack from streams :\n                    CopyMemory abData(0), ByVal lpMem, lSize\n                    GlobalUnlock hMem   'Lock memory\n                    ArrayFromPicture = abData   'Result\n                End If\n\n                Set IStm = Nothing  'Clean\n            End If\n\n            GdipDisposeImage lBitmap    'Clear GDIP-Image-Memory\n        End If\n    End If\nEnd Function\n\n'Create a picture object from an Access 2007 attachment\n'strTable:              Table containing picture file attachments\n'strAttachmentField:    Name of the attachment column in the table\n'strImage:              Name of the image to search in the attachment records\n'? AttachmentToPicture(\"ribbonimages\",\"imageblob\",\"cloudy.png\").Width\nPublic Function AttachmentToPicture(strTable As String, strAttachmentField As String, strImage As String) As StdPicture\n    Dim strSQL As String\n    Dim bin() As Byte\n    Dim nOffset As Long\n    Dim nSize As Long\n\n    strSQL = \"SELECT \" & strTable & \".\" & strAttachmentField & \".FileData AS data \" & _\n             \"FROM \" & strTable & _\n             \" WHERE \" & strTable & \".\" & strAttachmentField & \".FileName='\" & strImage & \"'\"\n    On Error Resume Next\n    bin = DBEngine(0)(0).OpenRecordset(strSQL, dbOpenSnapshot)(0)\n    If err.Number = 0 Then\n        Dim bin2() As Byte\n        nOffset = bin(0)    'First byte of Field2.FileData identifies offset to the file data block\n        nSize = UBound(bin)\n        ReDim bin2(nSize - nOffset)\n        CopyMemory bin2(0), bin(nOffset), nSize - nOffset   'Copy file into new byte array starting at nOffset\n        If bUseOGL Then\n            Set AttachmentToPicture = ArrayToPicture_O(bin2)\n        Else\n            Set AttachmentToPicture = ArrayToPicture(bin2)\n        End If\n        Erase bin2\n        Erase bin\n    End If\nEnd Function\n\nPublic Function PicFromField(ByVal picField As DAO.field, Optional FlattenColor As Variant = &HFFFFFFFF) As StdPicture\n    Dim arrBin() As Byte\n    Dim lSize As Long\n\n    On Error GoTo fehler\n\n    lSize = picField.FieldSize\n    If lSize > 0 Then\n        arrBin() = picField.GetChunk(0, lSize)\n        Set PicFromField = ArrayToPicture(arrBin, FlattenColor)\n    End If\n\nEnde:\n    Erase arrBin\n    Exit Function\n\nfehler:\n    MsgBox err.description, vbCritical\n    Resume Ende\nEnd Function\n\n'Create an OLE-Picture from Byte-Array PicBin()\nPublic Function ArrayToPicture(ByRef PicBin() As Byte, Optional FlattenColor As Variant) As StdPicture\n    Dim IStm As IUnknown\n    Dim lBitmap As Long\n    Dim hBmp As Long\n    Dim ret As Long\n\n    If Not InitGDIP Then Exit Function\n\n    If bUseOGL Then\n        Set ArrayToPicture = ArrayToPicture_O(PicBin, FlattenColor)\n    Else\n        ret = CreateStreamOnHGlobal(VarPtr(PicBin(0)), 0, IStm)    'Create stream from memory stack\n        If ret = 0 Then    'OK, start GDIP :\n            'Convert stream to GDIP-Image :\n            ret = GdipLoadImageFromStream(IStm, lBitmap)\n            If ret = 0 Then\n                If Not IsMissing(FlattenColor) Then\n                    Dim lBitmap2 As Long\n                    Dim lGraph As Long\n                    Dim w As Long, h As Long\n\n                    ret = GdipCloneImage(lBitmap, lBitmap2)\n                    ret = GdipGetImageGraphicsContext(lBitmap2, lGraph)\n                    If ret = 0 Then\n                        ret = GdipGetImageWidth(lBitmap, w)\n                        ret = GdipGetImageHeight(lBitmap, h)\n                        ret = GdipGraphicsClear(lGraph, CLng(FlattenColor))\n                        ret = GdipDrawImageRectRectI(lGraph, lBitmap, 0, 0, w, h, 0, 0, w, h, _\n                         UnitPixel, 0, 0)\n                    End If\n                    GdipCreateHBITMAPFromBitmap lBitmap2, hBmp, 0&\n                    GdipDeleteGraphics lGraph\n                Else\n                    GdipCreateHBITMAPFromBitmap lBitmap, hBmp, 0&\n                End If\n                If hBmp <> 0 Then\n                    'Convert bitmap to picture object :\n                    Set ArrayToPicture = BitmapToPicture(hBmp)\n                End If\n            End If\n            'Clear memory ...\n            GdipDisposeImage lBitmap\n        End If\n    End If\n\nEnd Function\n\nFunction MaskFromPicture(ByVal image As StdPicture, Optional TransColor As Variant) As StdPicture\n    Dim lBitmap As Long\n    Dim hBitmap As Long\n    Dim w As Long, h As Long\n    Dim bytes() As Long\n    Dim BD As BitmapData\n    Dim rct As RECTL\n    Dim X As Long, Y As Long\n    Dim AlphaColor As Long\n    Dim ret As Long\n\n    If Not InitGDIP Then Exit Function\n\n    If bUseOGL Then\n        Set MaskFromPicture = MaskFromPicture_O(image, TransColor)\n    Else\n        ret = GdipCreateBitmapFromHBITMAP(image.handle, 0, lBitmap)\n        If ret = 0 Then\n            ret = GdipGetImageWidth(lBitmap, w)\n            ret = GdipGetImageHeight(lBitmap, h)\n            With rct\n                .Left = 0\n                .Top = h\n                .Right = w\n                .Bottom = 0\n            End With\n            ReDim bytes(w, h)\n            With BD\n                .width = w\n                .height = h\n                .PixelFormat = PixelFormat32bppARGB\n                .stride = 4 * CLng(.width + 1)\n                .scan0 = VarPtr(bytes(0, 0))\n            End With\n            ret = GdipBitmapLockBits(lBitmap, rct, ImageLockModeRead Or _\n                                                   ImageLockModeUserInputBuf Or ImageLockModewrite, PixelFormat32bppARGB, BD)\n            If IsMissing(TransColor) Then\n                AlphaColor = bytes(0, 0)\n            Else\n                AlphaColor = CLng(TransColor)\n            End If\n            For X = 0 To w\n                For Y = 0 To h\n                    If bytes(X, Y) = AlphaColor Then bytes(X, Y) = &HFFFFFF Else bytes(X, Y) = &H0\n                Next Y\n            Next X\n\n            ret = GdipBitmapUnlockBits(lBitmap, BD)\n            GdipCreateHBITMAPFromBitmap lBitmap, hBitmap, 0&\n            Set MaskFromPicture = BitmapToPicture(hBitmap)\n            GdipDisposeImage lBitmap\n        End If\n    End If\n\nEnd Function\n\n'Helper function to get a OLE-Picture from Windows-Bitmap-Handle\n'If bIsIcon = TRUE, an Icon-Handle is commited\nFunction BitmapToPicture(ByVal hBmp As Long, Optional bIsIcon As Boolean = False) As StdPicture\n    Dim TPicConv As PICTDESC, UID As guid\n\n    With TPicConv\n        If bIsIcon Then\n            .cbSizeOfStruct = 16\n            .PicType = 3    'PicType Icon\n        Else\n            .cbSizeOfStruct = Len(TPicConv)\n            .PicType = 1    'PicType Bitmap\n        End If\n        .hImage = hBmp\n    End With\n\n    CLSIDFromString StrPtr(GUID_IPicture), UID\n    OleCreatePictureIndirect TPicConv, UID, True, BitmapToPicture\n\nEnd Function\n\n\n'--------------------------------------------------------------------------------------------------\n'Following the same procedures using the OGL library\n'The procedure names are the same but ending with \"_O\" here\n'(for comments see procs above)\n\nFunction LoadPictureGDIP_O(sFilename As String) As StdPicture\n    Dim hBmp As Long\n    Dim hPic As Long\n\n    If Not InitGDIP Then Exit Function\n    If GdipCreateBitmapFromFile_O(StrPtr(sFilename), hPic) = 0 Then\n        GdipCreateHBITMAPFromBitmap_O hPic, hBmp, 0&\n        If hBmp <> 0 Then\n            Set LoadPictureGDIP_O = BitmapToPicture(hBmp)\n            GdipDisposeImage_O hPic\n        End If\n    End If\n\nEnd Function\n\nFunction ResampleGDIP_O(ByVal image As StdPicture, ByVal width As Long, ByVal height As Long) As StdPicture\n    Dim lRes As Long\n    Dim lBitmap As Long\n\n    If Not InitGDIP Then Exit Function\n\n    If image.Type = 1 Then\n        lRes = GdipCreateBitmapFromHBITMAP_O(image.handle, 0, lBitmap)\n    Else\n        lRes = GdipCreateBitmapFromHICON_O(image.handle, lBitmap)\n    End If\n    If lRes = 0 Then\n        Dim lThumb As Long\n        Dim hBitmap As Long\n\n        lRes = GdipGetImageThumbnail_O(lBitmap, width, height, lThumb, 0, 0)\n        If lRes = 0 Then\n            If image.Type = 3 Then\n                lRes = GdipCreateHICONFromBitmap_O(lThumb, hBitmap)\n                Set ResampleGDIP_O = BitmapToPicture(hBitmap, True)\n            Else\n                lRes = GdipCreateHBITMAPFromBitmap_O(lThumb, hBitmap, 0)\n                Set ResampleGDIP_O = BitmapToPicture(hBitmap)\n            End If\n\n            GdipDisposeImage_O lThumb\n        End If\n        GdipDisposeImage_O lBitmap\n    End If\n\nEnd Function\n\nFunction CropImage_O(ByVal image As StdPicture, _\n                   X As Long, Y As Long, _\n                   width As Long, height As Long) As StdPicture\n    Dim ret As Long\n    Dim lBitmap As Long\n    Dim lBitmap2 As Long\n    Dim lGraph As Long\n    Dim hBitmap As Long\n    Dim sx As Long, sy As Long\n\n    Const PixelFormat32bppARGB = &H26200A\n    Const UnitPixel = 2\n\n    If Not InitGDIP Then Exit Function\n\n    ret = GdipCreateBitmapFromHBITMAP_O(image.handle, 0, lBitmap)\n    If ret = 0 Then\n        ret = GdipGetImageWidth_O(lBitmap, sx)\n        ret = GdipGetImageHeight_O(lBitmap, sy)\n        If (X + width) > sx Then width = sx - X\n        If (Y + height) > sy Then height = sy - Y\n        ret = GdipCreateBitmapFromScan0_O(CLng(width), CLng(height), _\n                    0, PixelFormat32bppARGB, ByVal 0&, lBitmap2)\n        ret = GdipGetImageGraphicsContext_O(lBitmap2, lGraph)\n        ret = GdipDrawImageRectRectI_O(lGraph, lBitmap, 0&, 0&, _\n                    width, height, X, Y, width, height, UnitPixel)\n        ret = GdipCreateHBITMAPFromBitmap_O(lBitmap2, hBitmap, 0)\n        Set CropImage_O = BitmapToPicture(hBitmap)\n\n        GdipDisposeImage_O lBitmap\n        GdipDisposeImage_O lBitmap2\n        GdipDeleteGraphics_O lGraph\n    End If\n\nEnd Function\n\nFunction GetDimensionsGDIP_O(ByVal image As StdPicture) As TSize\n    Dim lRes As Long\n    Dim lBitmap As Long\n    Dim X As Long, Y As Long\n\n    If Not InitGDIP Then Exit Function\n    If image Is Nothing Then Exit Function\n    lRes = GdipCreateBitmapFromHBITMAP_O(image.handle, 0, lBitmap)\n    If lRes = 0 Then\n        GdipGetImageHeight_O lBitmap, Y\n        GdipGetImageWidth_O lBitmap, X\n        GetDimensionsGDIP_O.X = CDbl(X)\n        GetDimensionsGDIP_O.Y = CDbl(Y)\n        GdipDisposeImage_O lBitmap\n    End If\n\nEnd Function\n\nFunction SavePicGDIPlus_O(ByVal image As StdPicture, sFile As String, _\n                        PicType As PicFileType, Optional Quality As Long = 80) As Boolean\n    Dim lBitmap As Long\n    Dim TEncoder As guid\n    Dim ret As Long\n    Dim TParams As EncoderParameters\n    Dim sType As String\n\n    If Not InitGDIP Then Exit Function\n\n    If GdipCreateBitmapFromHBITMAP_O(image.handle, 0, lBitmap) = 0 Then\n        Select Case PicType\n        Case pictypeBMP: sType = \"{557CF400-1A04-11D3-9A73-0000F81EF32E}\"\n        Case pictypeGIF: sType = \"{557CF402-1A04-11D3-9A73-0000F81EF32E}\"\n        Case pictypePNG: sType = \"{557CF406-1A04-11D3-9A73-0000F81EF32E}\"\n        Case pictypeJPG: sType = \"{557CF401-1A04-11D3-9A73-0000F81EF32E}\"\n        End Select\n        CLSIDFromString StrPtr(sType), TEncoder\n        If PicType = pictypeJPG Then\n            TParams.Count = 1\n            With TParams.Parameter\n                CLSIDFromString StrPtr(\"{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}\"), .UUID\n                .NumberOfValues = 1\n                .Type = 4\n                .Value = VarPtr(CLng(Quality))\n            End With\n        Else\n            If (PicType = pictypeGIF) Then TParams.Count = 1 Else TParams.Count = 0\n        End If\n        ret = GdipSaveImageToFile_O(lBitmap, StrPtr(sFile), TEncoder, TParams)\n        GdipDisposeImage_O lBitmap\n        DoEvents\n        SavePicGDIPlus_O = (Dir(sFile) <> \"\")\n    End If\n\nEnd Function\n\nFunction ArrayFromPicture_O(ByVal image As Object, PicType As PicFileType, Optional Quality As Long = 80) As Byte()\n    Dim lBitmap As Long\n    Dim TEncoder As guid\n    Dim ret As Long\n    Dim TParams As EncoderParameters\n    Dim sType As String\n    Dim IStm As IUnknown\n\n    If Not InitGDIP Then Exit Function\n\n    If GdipCreateBitmapFromHBITMAP_O(image.handle, 0, lBitmap) = 0 Then\n        Select Case PicType\n        Case pictypeBMP: sType = \"{557CF400-1A04-11D3-9A73-0000F81EF32E}\"\n        Case pictypeGIF: sType = \"{557CF402-1A04-11D3-9A73-0000F81EF32E}\"\n        Case pictypePNG: sType = \"{557CF406-1A04-11D3-9A73-0000F81EF32E}\"\n        Case pictypeJPG: sType = \"{557CF401-1A04-11D3-9A73-0000F81EF32E}\"\n        End Select\n        CLSIDFromString StrPtr(sType), TEncoder\n\n        If PicType = pictypeJPG Then\n            TParams.Count = 1\n            With TParams.Parameter\n                CLSIDFromString StrPtr(\"{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}\"), .UUID\n                .NumberOfValues = 1\n                .Type = 4\n                .Value = VarPtr(CLng(Quality))\n            End With\n        Else\n            If (PicType = pictypeGIF) Then TParams.Count = 1 Else TParams.Count = 0\n        End If\n\n        ret = CreateStreamOnHGlobal(0&, 1, IStm)\n        ret = GdipSaveImageToStream_O(lBitmap, IStm, TEncoder, TParams)\n        If ret = 0 Then\n            Dim hMem As Long, lSize As Long, lpMem As Long\n            Dim abData() As Byte\n\n            ret = GetHGlobalFromStream(IStm, hMem)\n            If ret = 0 Then\n                lSize = GlobalSize(hMem)\n                lpMem = GlobalLock(hMem)\n                ReDim abData(lSize - 1)\n                CopyMemory abData(0), ByVal lpMem, lSize\n                GlobalUnlock hMem\n                ArrayFromPicture_O = abData\n            End If\n\n            Set IStm = Nothing\n        End If\n\n        GdipDisposeImage_O lBitmap\n    End If\n\nEnd Function\n\nPublic Function AttachmentToPicture_O(strTable As String, strAttachmentField As String, strImage As String) As StdPicture\n    Dim strSQL As String\n    Dim bin() As Byte\n    Dim nOffset As Long\n    Dim nSize As Long\n\n    strSQL = \"SELECT \" & strTable & \".\" & strAttachmentField & \".FileData AS data \" & _\n             \"FROM \" & strTable & _\n             \" WHERE \" & strTable & \".\" & strAttachmentField & \".FileName='\" & strImage & \"'\"\n    On Error Resume Next\n    bin = DBEngine(0)(0).OpenRecordset(strSQL, dbOpenSnapshot)(0)\n    If err.Number = 0 Then\n        Dim bin2() As Byte\n        nOffset = bin(0)\n        nSize = UBound(bin)\n        ReDim bin2(nSize - nOffset)\n        CopyMemory bin2(0), bin(nOffset), nSize - nOffset\n        Set AttachmentToPicture_O = ArrayToPicture_O(bin2)\n        Erase bin2\n        Erase bin\n    End If\nEnd Function\n\nPublic Function ArrayToPicture_O(ByRef PicBin() As Byte, Optional FlattenColor As Variant) As StdPicture\n    Dim IStm As IUnknown\n    Dim lBitmap As Long\n    Dim hBmp As Long\n    Dim ret As Long\n\n    If Not InitGDIP Then Exit Function\n\n    ret = CreateStreamOnHGlobal(VarPtr(PicBin(0)), 0, IStm)\n    If ret = 0 Then\n        ret = GdipLoadImageFromStream_O(IStm, lBitmap)\n        If ret = 0 Then\n            If Not IsMissing(FlattenColor) Then\n                Dim lBitmap2 As Long\n                Dim lGraph As Long\n                Dim w As Long, h As Long\n\n                ret = GdipCloneImage_O(lBitmap, lBitmap2)\n                ret = GdipGetImageGraphicsContext_O(lBitmap2, lGraph)\n                If ret = 0 Then\n                    ret = GdipGetImageWidth_O(lBitmap, w)\n                    ret = GdipGetImageHeight_O(lBitmap, h)\n                    ret = GdipGraphicsClear_O(lGraph, CLng(FlattenColor))\n                    ret = GdipDrawImageRectRectI_O(lGraph, lBitmap, 0, 0, w, h, 0, 0, w, h, _\n                                                 UnitPixel, 0, 0)\n                End If\n                GdipCreateHBITMAPFromBitmap_O lBitmap2, hBmp, 0&\n                GdipDeleteGraphics_O lGraph\n            Else\n                GdipCreateHBITMAPFromBitmap_O lBitmap, hBmp, 0&\n            End If\n            If hBmp <> 0 Then\n                Set ArrayToPicture_O = BitmapToPicture(hBmp)\n            End If\n        End If\n        GdipDisposeImage_O lBitmap\n    End If\n\nEnd Function\n\n\nFunction MaskFromPicture_O(ByVal image As StdPicture, Optional TransColor As Variant) As StdPicture\n    Dim lBitmap As Long\n    Dim hBitmap As Long\n    Dim w As Long, h As Long\n    Dim bytes() As Long\n    Dim BD As BitmapData\n    Dim rct As RECTL\n    Dim X As Long, Y As Long\n    Dim AlphaColor As Long\n    Dim ret As Long\n\n    If Not InitGDIP Then Exit Function\n\n    ret = GdipCreateBitmapFromHBITMAP_O(image.handle, 0, lBitmap)\n    If ret = 0 Then\n        ret = GdipGetImageWidth_O(lBitmap, w)\n        ret = GdipGetImageHeight_O(lBitmap, h)\n        With rct\n            .Left = 0\n            .Top = h\n            .Right = w\n            .Bottom = 0\n        End With\n        ReDim bytes(w, h)\n        With BD\n            .width = w\n            .height = h\n            .PixelFormat = PixelFormat32bppARGB\n            .stride = 4 * CLng(.width + 1)\n            .scan0 = VarPtr(bytes(0, 0))\n        End With\n        ret = GdipBitmapLockBits_O(lBitmap, rct, ImageLockModeRead Or _\n                                               ImageLockModeUserInputBuf Or ImageLockModewrite, PixelFormat32bppARGB, BD)\n        If IsMissing(TransColor) Then\n            AlphaColor = bytes(0, 0)\n        Else\n            AlphaColor = CLng(TransColor)\n        End If\n        For X = 0 To w\n            For Y = 0 To h\n                If bytes(X, Y) = AlphaColor Then bytes(X, Y) = &HFFFFFF Else bytes(X, Y) = &H0\n            Next Y\n        Next X\n\n        ret = GdipBitmapUnlockBits_O(lBitmap, BD)\n        GdipCreateHBITMAPFromBitmap_O lBitmap, hBitmap, 0&\n        Set MaskFromPicture_O = BitmapToPicture(hBitmap)\n        GdipDisposeImage_O lBitmap\n    End If\n\nEnd Function\n\n\nFunction Save_as_Jpg(strIn As String, strOut As String, Optional iQuality As Long = 70)\n\nDim myPic As StdPicture\n\nSet myPic = LoadPictureGDIP(strIn)\n\n'Save a bitmap as file (with format conversion!)\n'image = StdPicture object\n'sFile = complete file path\n'PicType = pictypeBMP, pictypeGIF, pictypePNG oder pictypeJPG\n'Quality: 0...100; (works only with pictypeJPG!)\n'Returns TRUE if successful\n'Function SavePicGDIPlus(ByVal Image As StdPicture, sFile As String, _\n'                        PicType As PicFileType, Optional Quality As Long = 80) As Boolean\n\nIf Not SavePicGDIPlus(myPic, strOut, pictypeJPG, iQuality) Then\n    MsgBox \"Problem beim Save des jpg\", vbCritical, strOut\nEnd If\n\nShutDownGDIP\n\nEnd Function\n"}
